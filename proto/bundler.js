/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const base = $root.base = (() => {

    /**
     * Namespace base.
     * @exports base
     * @namespace
     */
    const base = {};

    base.InitReq = (function() {

        /**
         * Properties of an InitReq.
         * @memberof base
         * @interface IInitReq
         * @property {base.InitReq.IC2S} c2s InitReq c2s
         */

        /**
         * Constructs a new InitReq.
         * @memberof base
         * @classdesc 初始化请求
         * @implements IInitReq
         * @constructor
         * @param {base.IInitReq=} [properties] Properties to set
         */
        function InitReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InitReq c2s.
         * @member {base.InitReq.IC2S} c2s
         * @memberof base.InitReq
         * @instance
         */
        InitReq.prototype.c2s = null;

        /**
         * Creates a new InitReq instance using the specified properties.
         * @function create
         * @memberof base.InitReq
         * @static
         * @param {base.IInitReq=} [properties] Properties to set
         * @returns {base.InitReq} InitReq instance
         */
        InitReq.create = function create(properties) {
            return new InitReq(properties);
        };

        /**
         * Encodes the specified InitReq message. Does not implicitly {@link base.InitReq.verify|verify} messages.
         * @function encode
         * @memberof base.InitReq
         * @static
         * @param {base.IInitReq} message InitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.InitReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InitReq message, length delimited. Does not implicitly {@link base.InitReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.InitReq
         * @static
         * @param {base.IInitReq} message InitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.InitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.InitReq} InitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.InitReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.InitReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes an InitReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.InitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.InitReq} InitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitReq message.
         * @function verify
         * @memberof base.InitReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.InitReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates an InitReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.InitReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.InitReq} InitReq
         */
        InitReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.InitReq)
                return object;
            let message = new $root.base.InitReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.InitReq.c2s: object expected");
                message.c2s = $root.base.InitReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from an InitReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.InitReq
         * @static
         * @param {base.InitReq} message InitReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.InitReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this InitReq to JSON.
         * @function toJSON
         * @memberof base.InitReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InitReq
         * @function getTypeUrl
         * @memberof base.InitReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InitReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.InitReq";
        };

        InitReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.InitReq
             * @interface IC2S
             * @property {number} clientVer 客户端版本号，clientVer = "."以前的数 * 100 + "."以后的，举例：1.1版本的 clientVer 为1 * 100 + 1 = 101，2.21版本为2 * 100 + 21 = 221
             * @property {string} clientID 客户端唯一标识，无生具体生成规则，客户端自己保证唯一性即可
             * @property {boolean|null} [recvNotify] 此连接是否接收市场状态、交易需要重新解锁等等事件通知，true 代表接收，OpenD 就会向此连接推送这些通知，反之 false 代表不接收不推送如果通信要加密，首先得在 OpenD 和客户端都配置 RSA 密钥，不配置始终不加密
             * @property {number|null} [packetEncAlgo] 如果配置了 RSA 密钥且指定的加密算法不为 PacketEncAlgo_None 则加密(即便这里不设置，配置了 RSA 密钥，也会采用默认加密方式)，默认采用 FTAES_ECB 算法
             * 指定包加密算法，参见 Common.PacketEncAlgo 的枚举定义
             * @property {number|null} [pushProtoFmt] 指定这条连接上的推送协议格式，若不指定则使用 push_proto_type 配置项
             */

            /**
             * Constructs a new C2S.
             * @memberof base.InitReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.InitReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * 客户端版本号，clientVer = "."以前的数 * 100 + "."以后的，举例：1.1版本的 clientVer 为1 * 100 + 1 = 101，2.21版本为2 * 100 + 21 = 221
             * @member {number} clientVer
             * @memberof base.InitReq.C2S
             * @instance
             */
            C2S.prototype.clientVer = 0;

            /**
             * 客户端唯一标识，无生具体生成规则，客户端自己保证唯一性即可
             * @member {string} clientID
             * @memberof base.InitReq.C2S
             * @instance
             */
            C2S.prototype.clientID = "";

            /**
             * 此连接是否接收市场状态、交易需要重新解锁等等事件通知，true 代表接收，OpenD 就会向此连接推送这些通知，反之 false 代表不接收不推送如果通信要加密，首先得在 OpenD 和客户端都配置 RSA 密钥，不配置始终不加密
             * @member {boolean} recvNotify
             * @memberof base.InitReq.C2S
             * @instance
             */
            C2S.prototype.recvNotify = false;

            /**
             * 如果配置了 RSA 密钥且指定的加密算法不为 PacketEncAlgo_None 则加密(即便这里不设置，配置了 RSA 密钥，也会采用默认加密方式)，默认采用 FTAES_ECB 算法
             * 指定包加密算法，参见 Common.PacketEncAlgo 的枚举定义
             * @member {number} packetEncAlgo
             * @memberof base.InitReq.C2S
             * @instance
             */
            C2S.prototype.packetEncAlgo = 0;

            /**
             * 指定这条连接上的推送协议格式，若不指定则使用 push_proto_type 配置项
             * @member {number} pushProtoFmt
             * @memberof base.InitReq.C2S
             * @instance
             */
            C2S.prototype.pushProtoFmt = 0;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.InitReq.C2S
             * @static
             * @param {base.InitReq.IC2S=} [properties] Properties to set
             * @returns {base.InitReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.InitReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.InitReq.C2S
             * @static
             * @param {base.InitReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clientVer);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientID);
                if (message.recvNotify != null && Object.hasOwnProperty.call(message, "recvNotify"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.recvNotify);
                if (message.packetEncAlgo != null && Object.hasOwnProperty.call(message, "packetEncAlgo"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.packetEncAlgo);
                if (message.pushProtoFmt != null && Object.hasOwnProperty.call(message, "pushProtoFmt"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.pushProtoFmt);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.InitReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.InitReq.C2S
             * @static
             * @param {base.InitReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.InitReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.InitReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.InitReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.clientVer = reader.int32();
                            break;
                        }
                    case 2: {
                            message.clientID = reader.string();
                            break;
                        }
                    case 3: {
                            message.recvNotify = reader.bool();
                            break;
                        }
                    case 4: {
                            message.packetEncAlgo = reader.int32();
                            break;
                        }
                    case 5: {
                            message.pushProtoFmt = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("clientVer"))
                    throw $util.ProtocolError("missing required 'clientVer'", { instance: message });
                if (!message.hasOwnProperty("clientID"))
                    throw $util.ProtocolError("missing required 'clientID'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.InitReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.InitReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.InitReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.clientVer))
                    return "clientVer: integer expected";
                if (!$util.isString(message.clientID))
                    return "clientID: string expected";
                if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                    if (typeof message.recvNotify !== "boolean")
                        return "recvNotify: boolean expected";
                if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                    if (!$util.isInteger(message.packetEncAlgo))
                        return "packetEncAlgo: integer expected";
                if (message.pushProtoFmt != null && message.hasOwnProperty("pushProtoFmt"))
                    if (!$util.isInteger(message.pushProtoFmt))
                        return "pushProtoFmt: integer expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.InitReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.InitReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.InitReq.C2S)
                    return object;
                let message = new $root.base.InitReq.C2S();
                if (object.clientVer != null)
                    message.clientVer = object.clientVer | 0;
                if (object.clientID != null)
                    message.clientID = String(object.clientID);
                if (object.recvNotify != null)
                    message.recvNotify = Boolean(object.recvNotify);
                if (object.packetEncAlgo != null)
                    message.packetEncAlgo = object.packetEncAlgo | 0;
                if (object.pushProtoFmt != null)
                    message.pushProtoFmt = object.pushProtoFmt | 0;
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.InitReq.C2S
             * @static
             * @param {base.InitReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.clientVer = 0;
                    object.clientID = "";
                    object.recvNotify = false;
                    object.packetEncAlgo = 0;
                    object.pushProtoFmt = 0;
                }
                if (message.clientVer != null && message.hasOwnProperty("clientVer"))
                    object.clientVer = message.clientVer;
                if (message.clientID != null && message.hasOwnProperty("clientID"))
                    object.clientID = message.clientID;
                if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                    object.recvNotify = message.recvNotify;
                if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                    object.packetEncAlgo = message.packetEncAlgo;
                if (message.pushProtoFmt != null && message.hasOwnProperty("pushProtoFmt"))
                    object.pushProtoFmt = message.pushProtoFmt;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.InitReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.InitReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.InitReq.C2S";
            };

            return C2S;
        })();

        return InitReq;
    })();

    base.InitRes = (function() {

        /**
         * Properties of an InitRes.
         * @memberof base
         * @interface IInitRes
         * @property {number} retType InitRes retType
         * @property {string|null} [retMsg] InitRes retMsg
         * @property {number|null} [errCode] InitRes errCode
         * @property {base.InitRes.IS2C|null} [s2c] InitRes s2c
         */

        /**
         * Constructs a new InitRes.
         * @memberof base
         * @classdesc 初始化响应
         * @implements IInitRes
         * @constructor
         * @param {base.IInitRes=} [properties] Properties to set
         */
        function InitRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InitRes retType.
         * @member {number} retType
         * @memberof base.InitRes
         * @instance
         */
        InitRes.prototype.retType = 0;

        /**
         * InitRes retMsg.
         * @member {string} retMsg
         * @memberof base.InitRes
         * @instance
         */
        InitRes.prototype.retMsg = "";

        /**
         * InitRes errCode.
         * @member {number} errCode
         * @memberof base.InitRes
         * @instance
         */
        InitRes.prototype.errCode = 0;

        /**
         * InitRes s2c.
         * @member {base.InitRes.IS2C|null|undefined} s2c
         * @memberof base.InitRes
         * @instance
         */
        InitRes.prototype.s2c = null;

        /**
         * Creates a new InitRes instance using the specified properties.
         * @function create
         * @memberof base.InitRes
         * @static
         * @param {base.IInitRes=} [properties] Properties to set
         * @returns {base.InitRes} InitRes instance
         */
        InitRes.create = function create(properties) {
            return new InitRes(properties);
        };

        /**
         * Encodes the specified InitRes message. Does not implicitly {@link base.InitRes.verify|verify} messages.
         * @function encode
         * @memberof base.InitRes
         * @static
         * @param {base.IInitRes} message InitRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.InitRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InitRes message, length delimited. Does not implicitly {@link base.InitRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.InitRes
         * @static
         * @param {base.IInitRes} message InitRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.InitRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.InitRes} InitRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.InitRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.InitRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes an InitRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.InitRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.InitRes} InitRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitRes message.
         * @function verify
         * @memberof base.InitRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.InitRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates an InitRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.InitRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.InitRes} InitRes
         */
        InitRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.InitRes)
                return object;
            let message = new $root.base.InitRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.InitRes.s2c: object expected");
                message.s2c = $root.base.InitRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from an InitRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.InitRes
         * @static
         * @param {base.InitRes} message InitRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.InitRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this InitRes to JSON.
         * @function toJSON
         * @memberof base.InitRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InitRes
         * @function getTypeUrl
         * @memberof base.InitRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InitRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.InitRes";
        };

        InitRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.InitRes
             * @interface IS2C
             * @property {number} serverVer OpenD 的版本号
             * @property {number|Long} loginUserID OpenD 登录的用户 ID
             * @property {number|Long} connID 此连接的连接 ID，连接的唯一标识
             * @property {string} connAESKey 此连接后续 AES 加密通信的 Key，固定为16字节长字符串
             * @property {number} keepAliveInterval 心跳保活间隔
             * @property {string|null} [aesCBCiv] AES 加密通信 CBC 加密模式的 iv，固定为16字节长字符串
             */

            /**
             * Constructs a new S2C.
             * @memberof base.InitRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.InitRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OpenD 的版本号
             * @member {number} serverVer
             * @memberof base.InitRes.S2C
             * @instance
             */
            S2C.prototype.serverVer = 0;

            /**
             * OpenD 登录的用户 ID
             * @member {number|Long} loginUserID
             * @memberof base.InitRes.S2C
             * @instance
             */
            S2C.prototype.loginUserID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * 此连接的连接 ID，连接的唯一标识
             * @member {number|Long} connID
             * @memberof base.InitRes.S2C
             * @instance
             */
            S2C.prototype.connID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * 此连接后续 AES 加密通信的 Key，固定为16字节长字符串
             * @member {string} connAESKey
             * @memberof base.InitRes.S2C
             * @instance
             */
            S2C.prototype.connAESKey = "";

            /**
             * 心跳保活间隔
             * @member {number} keepAliveInterval
             * @memberof base.InitRes.S2C
             * @instance
             */
            S2C.prototype.keepAliveInterval = 0;

            /**
             * AES 加密通信 CBC 加密模式的 iv，固定为16字节长字符串
             * @member {string} aesCBCiv
             * @memberof base.InitRes.S2C
             * @instance
             */
            S2C.prototype.aesCBCiv = "";

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.InitRes.S2C
             * @static
             * @param {base.InitRes.IS2C=} [properties] Properties to set
             * @returns {base.InitRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.InitRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.InitRes.S2C
             * @static
             * @param {base.InitRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverVer);
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.loginUserID);
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.connID);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.connAESKey);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.keepAliveInterval);
                if (message.aesCBCiv != null && Object.hasOwnProperty.call(message, "aesCBCiv"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.aesCBCiv);
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.InitRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.InitRes.S2C
             * @static
             * @param {base.InitRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.InitRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.InitRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.InitRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.serverVer = reader.int32();
                            break;
                        }
                    case 2: {
                            message.loginUserID = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.connID = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.connAESKey = reader.string();
                            break;
                        }
                    case 5: {
                            message.keepAliveInterval = reader.int32();
                            break;
                        }
                    case 6: {
                            message.aesCBCiv = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("serverVer"))
                    throw $util.ProtocolError("missing required 'serverVer'", { instance: message });
                if (!message.hasOwnProperty("loginUserID"))
                    throw $util.ProtocolError("missing required 'loginUserID'", { instance: message });
                if (!message.hasOwnProperty("connID"))
                    throw $util.ProtocolError("missing required 'connID'", { instance: message });
                if (!message.hasOwnProperty("connAESKey"))
                    throw $util.ProtocolError("missing required 'connAESKey'", { instance: message });
                if (!message.hasOwnProperty("keepAliveInterval"))
                    throw $util.ProtocolError("missing required 'keepAliveInterval'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.InitRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.InitRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.InitRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.serverVer))
                    return "serverVer: integer expected";
                if (!$util.isInteger(message.loginUserID) && !(message.loginUserID && $util.isInteger(message.loginUserID.low) && $util.isInteger(message.loginUserID.high)))
                    return "loginUserID: integer|Long expected";
                if (!$util.isInteger(message.connID) && !(message.connID && $util.isInteger(message.connID.low) && $util.isInteger(message.connID.high)))
                    return "connID: integer|Long expected";
                if (!$util.isString(message.connAESKey))
                    return "connAESKey: string expected";
                if (!$util.isInteger(message.keepAliveInterval))
                    return "keepAliveInterval: integer expected";
                if (message.aesCBCiv != null && message.hasOwnProperty("aesCBCiv"))
                    if (!$util.isString(message.aesCBCiv))
                        return "aesCBCiv: string expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.InitRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.InitRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.InitRes.S2C)
                    return object;
                let message = new $root.base.InitRes.S2C();
                if (object.serverVer != null)
                    message.serverVer = object.serverVer | 0;
                if (object.loginUserID != null)
                    if ($util.Long)
                        (message.loginUserID = $util.Long.fromValue(object.loginUserID)).unsigned = true;
                    else if (typeof object.loginUserID === "string")
                        message.loginUserID = parseInt(object.loginUserID, 10);
                    else if (typeof object.loginUserID === "number")
                        message.loginUserID = object.loginUserID;
                    else if (typeof object.loginUserID === "object")
                        message.loginUserID = new $util.LongBits(object.loginUserID.low >>> 0, object.loginUserID.high >>> 0).toNumber(true);
                if (object.connID != null)
                    if ($util.Long)
                        (message.connID = $util.Long.fromValue(object.connID)).unsigned = true;
                    else if (typeof object.connID === "string")
                        message.connID = parseInt(object.connID, 10);
                    else if (typeof object.connID === "number")
                        message.connID = object.connID;
                    else if (typeof object.connID === "object")
                        message.connID = new $util.LongBits(object.connID.low >>> 0, object.connID.high >>> 0).toNumber(true);
                if (object.connAESKey != null)
                    message.connAESKey = String(object.connAESKey);
                if (object.keepAliveInterval != null)
                    message.keepAliveInterval = object.keepAliveInterval | 0;
                if (object.aesCBCiv != null)
                    message.aesCBCiv = String(object.aesCBCiv);
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.InitRes.S2C
             * @static
             * @param {base.InitRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.serverVer = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.loginUserID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.loginUserID = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.connID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.connID = options.longs === String ? "0" : 0;
                    object.connAESKey = "";
                    object.keepAliveInterval = 0;
                    object.aesCBCiv = "";
                }
                if (message.serverVer != null && message.hasOwnProperty("serverVer"))
                    object.serverVer = message.serverVer;
                if (message.loginUserID != null && message.hasOwnProperty("loginUserID"))
                    if (typeof message.loginUserID === "number")
                        object.loginUserID = options.longs === String ? String(message.loginUserID) : message.loginUserID;
                    else
                        object.loginUserID = options.longs === String ? $util.Long.prototype.toString.call(message.loginUserID) : options.longs === Number ? new $util.LongBits(message.loginUserID.low >>> 0, message.loginUserID.high >>> 0).toNumber(true) : message.loginUserID;
                if (message.connID != null && message.hasOwnProperty("connID"))
                    if (typeof message.connID === "number")
                        object.connID = options.longs === String ? String(message.connID) : message.connID;
                    else
                        object.connID = options.longs === String ? $util.Long.prototype.toString.call(message.connID) : options.longs === Number ? new $util.LongBits(message.connID.low >>> 0, message.connID.high >>> 0).toNumber(true) : message.connID;
                if (message.connAESKey != null && message.hasOwnProperty("connAESKey"))
                    object.connAESKey = message.connAESKey;
                if (message.keepAliveInterval != null && message.hasOwnProperty("keepAliveInterval"))
                    object.keepAliveInterval = message.keepAliveInterval;
                if (message.aesCBCiv != null && message.hasOwnProperty("aesCBCiv"))
                    object.aesCBCiv = message.aesCBCiv;
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.InitRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.InitRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.InitRes.S2C";
            };

            return S2C;
        })();

        return InitRes;
    })();

    base.UnlockReq = (function() {

        /**
         * Properties of an UnlockReq.
         * @memberof base
         * @interface IUnlockReq
         * @property {base.UnlockReq.IC2S} c2s UnlockReq c2s
         */

        /**
         * Constructs a new UnlockReq.
         * @memberof base
         * @classdesc 交易解锁请求
         * @implements IUnlockReq
         * @constructor
         * @param {base.IUnlockReq=} [properties] Properties to set
         */
        function UnlockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlockReq c2s.
         * @member {base.UnlockReq.IC2S} c2s
         * @memberof base.UnlockReq
         * @instance
         */
        UnlockReq.prototype.c2s = null;

        /**
         * Creates a new UnlockReq instance using the specified properties.
         * @function create
         * @memberof base.UnlockReq
         * @static
         * @param {base.IUnlockReq=} [properties] Properties to set
         * @returns {base.UnlockReq} UnlockReq instance
         */
        UnlockReq.create = function create(properties) {
            return new UnlockReq(properties);
        };

        /**
         * Encodes the specified UnlockReq message. Does not implicitly {@link base.UnlockReq.verify|verify} messages.
         * @function encode
         * @memberof base.UnlockReq
         * @static
         * @param {base.IUnlockReq} message UnlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.UnlockReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlockReq message, length delimited. Does not implicitly {@link base.UnlockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.UnlockReq
         * @static
         * @param {base.IUnlockReq} message UnlockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.UnlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.UnlockReq} UnlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.UnlockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.UnlockReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnlockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.UnlockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.UnlockReq} UnlockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockReq message.
         * @function verify
         * @memberof base.UnlockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.UnlockReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates an UnlockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.UnlockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.UnlockReq} UnlockReq
         */
        UnlockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.UnlockReq)
                return object;
            let message = new $root.base.UnlockReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.UnlockReq.c2s: object expected");
                message.c2s = $root.base.UnlockReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnlockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.UnlockReq
         * @static
         * @param {base.UnlockReq} message UnlockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.UnlockReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this UnlockReq to JSON.
         * @function toJSON
         * @memberof base.UnlockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UnlockReq
         * @function getTypeUrl
         * @memberof base.UnlockReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UnlockReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.UnlockReq";
        };

        UnlockReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.UnlockReq
             * @interface IC2S
             * @property {boolean} unlock C2S unlock
             * @property {string|null} [pwdMD5] C2S pwdMD5
             * @property {common.SecurityFirm|null} [securityFirm] C2S securityFirm
             */

            /**
             * Constructs a new C2S.
             * @memberof base.UnlockReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.UnlockReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S unlock.
             * @member {boolean} unlock
             * @memberof base.UnlockReq.C2S
             * @instance
             */
            C2S.prototype.unlock = false;

            /**
             * C2S pwdMD5.
             * @member {string} pwdMD5
             * @memberof base.UnlockReq.C2S
             * @instance
             */
            C2S.prototype.pwdMD5 = "";

            /**
             * C2S securityFirm.
             * @member {common.SecurityFirm} securityFirm
             * @memberof base.UnlockReq.C2S
             * @instance
             */
            C2S.prototype.securityFirm = 0;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {base.UnlockReq.IC2S=} [properties] Properties to set
             * @returns {base.UnlockReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.UnlockReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {base.UnlockReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.unlock);
                if (message.pwdMD5 != null && Object.hasOwnProperty.call(message, "pwdMD5"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwdMD5);
                if (message.securityFirm != null && Object.hasOwnProperty.call(message, "securityFirm"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.securityFirm);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.UnlockReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {base.UnlockReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.UnlockReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.UnlockReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.unlock = reader.bool();
                            break;
                        }
                    case 2: {
                            message.pwdMD5 = reader.string();
                            break;
                        }
                    case 3: {
                            message.securityFirm = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("unlock"))
                    throw $util.ProtocolError("missing required 'unlock'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.UnlockReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.unlock !== "boolean")
                    return "unlock: boolean expected";
                if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                    if (!$util.isString(message.pwdMD5))
                        return "pwdMD5: string expected";
                if (message.securityFirm != null && message.hasOwnProperty("securityFirm"))
                    switch (message.securityFirm) {
                    default:
                        return "securityFirm: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.UnlockReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.UnlockReq.C2S)
                    return object;
                let message = new $root.base.UnlockReq.C2S();
                if (object.unlock != null)
                    message.unlock = Boolean(object.unlock);
                if (object.pwdMD5 != null)
                    message.pwdMD5 = String(object.pwdMD5);
                switch (object.securityFirm) {
                default:
                    if (typeof object.securityFirm === "number") {
                        message.securityFirm = object.securityFirm;
                        break;
                    }
                    break;
                case "SecurityFirm_Unknown":
                case 0:
                    message.securityFirm = 0;
                    break;
                case "SecurityFirm_FutuSecurities":
                case 1:
                    message.securityFirm = 1;
                    break;
                case "SecurityFirm_FutuInc":
                case 2:
                    message.securityFirm = 2;
                    break;
                case "SecurityFirm_FutuSG":
                case 3:
                    message.securityFirm = 3;
                    break;
                case "SecurityFirm_FutuAU":
                case 4:
                    message.securityFirm = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {base.UnlockReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.unlock = false;
                    object.pwdMD5 = "";
                    object.securityFirm = options.enums === String ? "SecurityFirm_Unknown" : 0;
                }
                if (message.unlock != null && message.hasOwnProperty("unlock"))
                    object.unlock = message.unlock;
                if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                    object.pwdMD5 = message.pwdMD5;
                if (message.securityFirm != null && message.hasOwnProperty("securityFirm"))
                    object.securityFirm = options.enums === String ? $root.common.SecurityFirm[message.securityFirm] === undefined ? message.securityFirm : $root.common.SecurityFirm[message.securityFirm] : message.securityFirm;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.UnlockReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.UnlockReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.UnlockReq.C2S";
            };

            return C2S;
        })();

        return UnlockReq;
    })();

    base.UnlockRes = (function() {

        /**
         * Properties of an UnlockRes.
         * @memberof base
         * @interface IUnlockRes
         * @property {number} retType UnlockRes retType
         * @property {string|null} [retMsg] UnlockRes retMsg
         * @property {number|null} [errCode] UnlockRes errCode
         * @property {base.UnlockRes.IS2C|null} [s2c] UnlockRes s2c
         */

        /**
         * Constructs a new UnlockRes.
         * @memberof base
         * @classdesc 交易解锁响应
         * @implements IUnlockRes
         * @constructor
         * @param {base.IUnlockRes=} [properties] Properties to set
         */
        function UnlockRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlockRes retType.
         * @member {number} retType
         * @memberof base.UnlockRes
         * @instance
         */
        UnlockRes.prototype.retType = 0;

        /**
         * UnlockRes retMsg.
         * @member {string} retMsg
         * @memberof base.UnlockRes
         * @instance
         */
        UnlockRes.prototype.retMsg = "";

        /**
         * UnlockRes errCode.
         * @member {number} errCode
         * @memberof base.UnlockRes
         * @instance
         */
        UnlockRes.prototype.errCode = 0;

        /**
         * UnlockRes s2c.
         * @member {base.UnlockRes.IS2C|null|undefined} s2c
         * @memberof base.UnlockRes
         * @instance
         */
        UnlockRes.prototype.s2c = null;

        /**
         * Creates a new UnlockRes instance using the specified properties.
         * @function create
         * @memberof base.UnlockRes
         * @static
         * @param {base.IUnlockRes=} [properties] Properties to set
         * @returns {base.UnlockRes} UnlockRes instance
         */
        UnlockRes.create = function create(properties) {
            return new UnlockRes(properties);
        };

        /**
         * Encodes the specified UnlockRes message. Does not implicitly {@link base.UnlockRes.verify|verify} messages.
         * @function encode
         * @memberof base.UnlockRes
         * @static
         * @param {base.IUnlockRes} message UnlockRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.UnlockRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlockRes message, length delimited. Does not implicitly {@link base.UnlockRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.UnlockRes
         * @static
         * @param {base.IUnlockRes} message UnlockRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.UnlockRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.UnlockRes} UnlockRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.UnlockRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.UnlockRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnlockRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.UnlockRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.UnlockRes} UnlockRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockRes message.
         * @function verify
         * @memberof base.UnlockRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.UnlockRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates an UnlockRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.UnlockRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.UnlockRes} UnlockRes
         */
        UnlockRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.UnlockRes)
                return object;
            let message = new $root.base.UnlockRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.UnlockRes.s2c: object expected");
                message.s2c = $root.base.UnlockRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnlockRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.UnlockRes
         * @static
         * @param {base.UnlockRes} message UnlockRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.UnlockRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this UnlockRes to JSON.
         * @function toJSON
         * @memberof base.UnlockRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UnlockRes
         * @function getTypeUrl
         * @memberof base.UnlockRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UnlockRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.UnlockRes";
        };

        UnlockRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.UnlockRes
             * @interface IS2C
             */

            /**
             * Constructs a new S2C.
             * @memberof base.UnlockRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.UnlockRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {base.UnlockRes.IS2C=} [properties] Properties to set
             * @returns {base.UnlockRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.UnlockRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {base.UnlockRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.UnlockRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {base.UnlockRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.UnlockRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.UnlockRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.UnlockRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.UnlockRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.UnlockRes.S2C)
                    return object;
                return new $root.base.UnlockRes.S2C();
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {base.UnlockRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.UnlockRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.UnlockRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.UnlockRes.S2C";
            };

            return S2C;
        })();

        return UnlockRes;
    })();

    base.Ping = (function() {

        /**
         * Properties of a Ping.
         * @memberof base
         * @interface IPing
         * @property {base.Ping.IC2S} c2s Ping c2s
         */

        /**
         * Constructs a new Ping.
         * @memberof base
         * @classdesc 心跳检测：ping
         * @implements IPing
         * @constructor
         * @param {base.IPing=} [properties] Properties to set
         */
        function Ping(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ping c2s.
         * @member {base.Ping.IC2S} c2s
         * @memberof base.Ping
         * @instance
         */
        Ping.prototype.c2s = null;

        /**
         * Creates a new Ping instance using the specified properties.
         * @function create
         * @memberof base.Ping
         * @static
         * @param {base.IPing=} [properties] Properties to set
         * @returns {base.Ping} Ping instance
         */
        Ping.create = function create(properties) {
            return new Ping(properties);
        };

        /**
         * Encodes the specified Ping message. Does not implicitly {@link base.Ping.verify|verify} messages.
         * @function encode
         * @memberof base.Ping
         * @static
         * @param {base.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.Ping.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Ping message, length delimited. Does not implicitly {@link base.Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.Ping
         * @static
         * @param {base.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ping message from the specified reader or buffer.
         * @function decode
         * @memberof base.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.Ping();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.Ping.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ping message.
         * @function verify
         * @memberof base.Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.Ping.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.Ping} Ping
         */
        Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.base.Ping)
                return object;
            let message = new $root.base.Ping();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.Ping.c2s: object expected");
                message.c2s = $root.base.Ping.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.Ping
         * @static
         * @param {base.Ping} message Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.Ping.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Ping to JSON.
         * @function toJSON
         * @memberof base.Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Ping
         * @function getTypeUrl
         * @memberof base.Ping
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Ping.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.Ping";
        };

        Ping.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.Ping
             * @interface IC2S
             * @property {number|Long} time C2S time
             */

            /**
             * Constructs a new C2S.
             * @memberof base.Ping
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.Ping.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S time.
             * @member {number|Long} time
             * @memberof base.Ping.C2S
             * @instance
             */
            C2S.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.Ping.C2S
             * @static
             * @param {base.Ping.IC2S=} [properties] Properties to set
             * @returns {base.Ping.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.Ping.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.Ping.C2S
             * @static
             * @param {base.Ping.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.Ping.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.Ping.C2S
             * @static
             * @param {base.Ping.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.Ping.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.Ping.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.Ping.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("time"))
                    throw $util.ProtocolError("missing required 'time'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.Ping.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.Ping.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.Ping.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.Ping.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.Ping.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.Ping.C2S)
                    return object;
                let message = new $root.base.Ping.C2S();
                if (object.time != null)
                    if ($util.Long)
                        (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                    else if (typeof object.time === "string")
                        message.time = parseInt(object.time, 10);
                    else if (typeof object.time === "number")
                        message.time = object.time;
                    else if (typeof object.time === "object")
                        message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.Ping.C2S
             * @static
             * @param {base.Ping.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.time = options.longs === String ? "0" : 0;
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time === "number")
                        object.time = options.longs === String ? String(message.time) : message.time;
                    else
                        object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.Ping.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.Ping.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.Ping.C2S";
            };

            return C2S;
        })();

        return Ping;
    })();

    base.Pong = (function() {

        /**
         * Properties of a Pong.
         * @memberof base
         * @interface IPong
         * @property {number} retType Pong retType
         * @property {string|null} [retMsg] Pong retMsg
         * @property {number|null} [errCode] Pong errCode
         * @property {base.Pong.IS2C|null} [s2c] Pong s2c
         */

        /**
         * Constructs a new Pong.
         * @memberof base
         * @classdesc 心跳响应
         * @implements IPong
         * @constructor
         * @param {base.IPong=} [properties] Properties to set
         */
        function Pong(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Pong retType.
         * @member {number} retType
         * @memberof base.Pong
         * @instance
         */
        Pong.prototype.retType = 0;

        /**
         * Pong retMsg.
         * @member {string} retMsg
         * @memberof base.Pong
         * @instance
         */
        Pong.prototype.retMsg = "";

        /**
         * Pong errCode.
         * @member {number} errCode
         * @memberof base.Pong
         * @instance
         */
        Pong.prototype.errCode = 0;

        /**
         * Pong s2c.
         * @member {base.Pong.IS2C|null|undefined} s2c
         * @memberof base.Pong
         * @instance
         */
        Pong.prototype.s2c = null;

        /**
         * Creates a new Pong instance using the specified properties.
         * @function create
         * @memberof base.Pong
         * @static
         * @param {base.IPong=} [properties] Properties to set
         * @returns {base.Pong} Pong instance
         */
        Pong.create = function create(properties) {
            return new Pong(properties);
        };

        /**
         * Encodes the specified Pong message. Does not implicitly {@link base.Pong.verify|verify} messages.
         * @function encode
         * @memberof base.Pong
         * @static
         * @param {base.IPong} message Pong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pong.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.Pong.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Pong message, length delimited. Does not implicitly {@link base.Pong.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.Pong
         * @static
         * @param {base.IPong} message Pong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pong.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Pong message from the specified reader or buffer.
         * @function decode
         * @memberof base.Pong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.Pong} Pong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pong.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.Pong();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.Pong.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Pong message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.Pong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.Pong} Pong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pong.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Pong message.
         * @function verify
         * @memberof base.Pong
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pong.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.Pong.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Pong message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.Pong
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.Pong} Pong
         */
        Pong.fromObject = function fromObject(object) {
            if (object instanceof $root.base.Pong)
                return object;
            let message = new $root.base.Pong();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.Pong.s2c: object expected");
                message.s2c = $root.base.Pong.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Pong message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.Pong
         * @static
         * @param {base.Pong} message Pong
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pong.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.Pong.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Pong to JSON.
         * @function toJSON
         * @memberof base.Pong
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pong.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Pong
         * @function getTypeUrl
         * @memberof base.Pong
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Pong.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.Pong";
        };

        Pong.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.Pong
             * @interface IS2C
             * @property {number|Long} time S2C time
             */

            /**
             * Constructs a new S2C.
             * @memberof base.Pong
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.Pong.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C time.
             * @member {number|Long} time
             * @memberof base.Pong.S2C
             * @instance
             */
            S2C.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.Pong.S2C
             * @static
             * @param {base.Pong.IS2C=} [properties] Properties to set
             * @returns {base.Pong.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.Pong.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.Pong.S2C
             * @static
             * @param {base.Pong.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.Pong.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.Pong.S2C
             * @static
             * @param {base.Pong.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.Pong.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.Pong.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.Pong.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("time"))
                    throw $util.ProtocolError("missing required 'time'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.Pong.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.Pong.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.Pong.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.Pong.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.Pong.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.Pong.S2C)
                    return object;
                let message = new $root.base.Pong.S2C();
                if (object.time != null)
                    if ($util.Long)
                        (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                    else if (typeof object.time === "string")
                        message.time = parseInt(object.time, 10);
                    else if (typeof object.time === "number")
                        message.time = object.time;
                    else if (typeof object.time === "object")
                        message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.Pong.S2C
             * @static
             * @param {base.Pong.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.time = options.longs === String ? "0" : 0;
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time === "number")
                        object.time = options.longs === String ? String(message.time) : message.time;
                    else
                        object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.Pong.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.Pong.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.Pong.S2C";
            };

            return S2C;
        })();

        return Pong;
    })();

    base.AccReq = (function() {

        /**
         * Properties of an AccReq.
         * @memberof base
         * @interface IAccReq
         * @property {base.AccReq.IC2S} c2s AccReq c2s
         */

        /**
         * Constructs a new AccReq.
         * @memberof base
         * @classdesc 获取账户列表请求
         * @implements IAccReq
         * @constructor
         * @param {base.IAccReq=} [properties] Properties to set
         */
        function AccReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccReq c2s.
         * @member {base.AccReq.IC2S} c2s
         * @memberof base.AccReq
         * @instance
         */
        AccReq.prototype.c2s = null;

        /**
         * Creates a new AccReq instance using the specified properties.
         * @function create
         * @memberof base.AccReq
         * @static
         * @param {base.IAccReq=} [properties] Properties to set
         * @returns {base.AccReq} AccReq instance
         */
        AccReq.create = function create(properties) {
            return new AccReq(properties);
        };

        /**
         * Encodes the specified AccReq message. Does not implicitly {@link base.AccReq.verify|verify} messages.
         * @function encode
         * @memberof base.AccReq
         * @static
         * @param {base.IAccReq} message AccReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.AccReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccReq message, length delimited. Does not implicitly {@link base.AccReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.AccReq
         * @static
         * @param {base.IAccReq} message AccReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.AccReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.AccReq} AccReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.AccReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.AccReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes an AccReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.AccReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.AccReq} AccReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccReq message.
         * @function verify
         * @memberof base.AccReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.AccReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates an AccReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.AccReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.AccReq} AccReq
         */
        AccReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.AccReq)
                return object;
            let message = new $root.base.AccReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.AccReq.c2s: object expected");
                message.c2s = $root.base.AccReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.AccReq
         * @static
         * @param {base.AccReq} message AccReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.AccReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this AccReq to JSON.
         * @function toJSON
         * @memberof base.AccReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccReq
         * @function getTypeUrl
         * @memberof base.AccReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.AccReq";
        };

        AccReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.AccReq
             * @interface IC2S
             * @property {number|Long} userID C2S userID
             * @property {common.TrdCategory|null} [trdCategory] C2S trdCategory
             * @property {boolean|null} [needGeneralSecAccount] C2S needGeneralSecAccount
             */

            /**
             * Constructs a new C2S.
             * @memberof base.AccReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.AccReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S userID.
             * @member {number|Long} userID
             * @memberof base.AccReq.C2S
             * @instance
             */
            C2S.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * C2S trdCategory.
             * @member {common.TrdCategory} trdCategory
             * @memberof base.AccReq.C2S
             * @instance
             */
            C2S.prototype.trdCategory = 0;

            /**
             * C2S needGeneralSecAccount.
             * @member {boolean} needGeneralSecAccount
             * @memberof base.AccReq.C2S
             * @instance
             */
            C2S.prototype.needGeneralSecAccount = false;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.AccReq.C2S
             * @static
             * @param {base.AccReq.IC2S=} [properties] Properties to set
             * @returns {base.AccReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.AccReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.AccReq.C2S
             * @static
             * @param {base.AccReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userID);
                if (message.trdCategory != null && Object.hasOwnProperty.call(message, "trdCategory"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trdCategory);
                if (message.needGeneralSecAccount != null && Object.hasOwnProperty.call(message, "needGeneralSecAccount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.needGeneralSecAccount);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.AccReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.AccReq.C2S
             * @static
             * @param {base.AccReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.AccReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.AccReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.AccReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userID = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.trdCategory = reader.int32();
                            break;
                        }
                    case 3: {
                            message.needGeneralSecAccount = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("userID"))
                    throw $util.ProtocolError("missing required 'userID'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.AccReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.AccReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.AccReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                    return "userID: integer|Long expected";
                if (message.trdCategory != null && message.hasOwnProperty("trdCategory"))
                    switch (message.trdCategory) {
                    default:
                        return "trdCategory: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.needGeneralSecAccount != null && message.hasOwnProperty("needGeneralSecAccount"))
                    if (typeof message.needGeneralSecAccount !== "boolean")
                        return "needGeneralSecAccount: boolean expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.AccReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.AccReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.AccReq.C2S)
                    return object;
                let message = new $root.base.AccReq.C2S();
                if (object.userID != null)
                    if ($util.Long)
                        (message.userID = $util.Long.fromValue(object.userID)).unsigned = true;
                    else if (typeof object.userID === "string")
                        message.userID = parseInt(object.userID, 10);
                    else if (typeof object.userID === "number")
                        message.userID = object.userID;
                    else if (typeof object.userID === "object")
                        message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber(true);
                switch (object.trdCategory) {
                default:
                    if (typeof object.trdCategory === "number") {
                        message.trdCategory = object.trdCategory;
                        break;
                    }
                    break;
                case "TrdCategory_Unknown":
                case 0:
                    message.trdCategory = 0;
                    break;
                case "TrdCategory_Security":
                case 1:
                    message.trdCategory = 1;
                    break;
                case "TrdCategory_Future":
                case 2:
                    message.trdCategory = 2;
                    break;
                }
                if (object.needGeneralSecAccount != null)
                    message.needGeneralSecAccount = Boolean(object.needGeneralSecAccount);
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.AccReq.C2S
             * @static
             * @param {base.AccReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.userID = options.longs === String ? "0" : 0;
                    object.trdCategory = options.enums === String ? "TrdCategory_Unknown" : 0;
                    object.needGeneralSecAccount = false;
                }
                if (message.userID != null && message.hasOwnProperty("userID"))
                    if (typeof message.userID === "number")
                        object.userID = options.longs === String ? String(message.userID) : message.userID;
                    else
                        object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber(true) : message.userID;
                if (message.trdCategory != null && message.hasOwnProperty("trdCategory"))
                    object.trdCategory = options.enums === String ? $root.common.TrdCategory[message.trdCategory] === undefined ? message.trdCategory : $root.common.TrdCategory[message.trdCategory] : message.trdCategory;
                if (message.needGeneralSecAccount != null && message.hasOwnProperty("needGeneralSecAccount"))
                    object.needGeneralSecAccount = message.needGeneralSecAccount;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.AccReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.AccReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.AccReq.C2S";
            };

            return C2S;
        })();

        return AccReq;
    })();

    base.AccRes = (function() {

        /**
         * Properties of an AccRes.
         * @memberof base
         * @interface IAccRes
         * @property {number} retType AccRes retType
         * @property {string|null} [retMsg] AccRes retMsg
         * @property {number|null} [errCode] AccRes errCode
         * @property {base.AccRes.IS2C|null} [s2c] AccRes s2c
         */

        /**
         * Constructs a new AccRes.
         * @memberof base
         * @classdesc 获取账户列表响应
         * @implements IAccRes
         * @constructor
         * @param {base.IAccRes=} [properties] Properties to set
         */
        function AccRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccRes retType.
         * @member {number} retType
         * @memberof base.AccRes
         * @instance
         */
        AccRes.prototype.retType = 0;

        /**
         * AccRes retMsg.
         * @member {string} retMsg
         * @memberof base.AccRes
         * @instance
         */
        AccRes.prototype.retMsg = "";

        /**
         * AccRes errCode.
         * @member {number} errCode
         * @memberof base.AccRes
         * @instance
         */
        AccRes.prototype.errCode = 0;

        /**
         * AccRes s2c.
         * @member {base.AccRes.IS2C|null|undefined} s2c
         * @memberof base.AccRes
         * @instance
         */
        AccRes.prototype.s2c = null;

        /**
         * Creates a new AccRes instance using the specified properties.
         * @function create
         * @memberof base.AccRes
         * @static
         * @param {base.IAccRes=} [properties] Properties to set
         * @returns {base.AccRes} AccRes instance
         */
        AccRes.create = function create(properties) {
            return new AccRes(properties);
        };

        /**
         * Encodes the specified AccRes message. Does not implicitly {@link base.AccRes.verify|verify} messages.
         * @function encode
         * @memberof base.AccRes
         * @static
         * @param {base.IAccRes} message AccRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.AccRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccRes message, length delimited. Does not implicitly {@link base.AccRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.AccRes
         * @static
         * @param {base.IAccRes} message AccRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.AccRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.AccRes} AccRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.AccRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.AccRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes an AccRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.AccRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.AccRes} AccRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccRes message.
         * @function verify
         * @memberof base.AccRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.AccRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates an AccRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.AccRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.AccRes} AccRes
         */
        AccRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.AccRes)
                return object;
            let message = new $root.base.AccRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.AccRes.s2c: object expected");
                message.s2c = $root.base.AccRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.AccRes
         * @static
         * @param {base.AccRes} message AccRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.AccRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this AccRes to JSON.
         * @function toJSON
         * @memberof base.AccRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccRes
         * @function getTypeUrl
         * @memberof base.AccRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.AccRes";
        };

        AccRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.AccRes
             * @interface IS2C
             * @property {Array.<common.ITrdAcc>|null} [accList] S2C accList
             */

            /**
             * Constructs a new S2C.
             * @memberof base.AccRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.AccRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.accList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C accList.
             * @member {Array.<common.ITrdAcc>} accList
             * @memberof base.AccRes.S2C
             * @instance
             */
            S2C.prototype.accList = $util.emptyArray;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.AccRes.S2C
             * @static
             * @param {base.AccRes.IS2C=} [properties] Properties to set
             * @returns {base.AccRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.AccRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.AccRes.S2C
             * @static
             * @param {base.AccRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accList != null && message.accList.length)
                    for (let i = 0; i < message.accList.length; ++i)
                        $root.common.TrdAcc.encode(message.accList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.AccRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.AccRes.S2C
             * @static
             * @param {base.AccRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.AccRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.AccRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.AccRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.accList && message.accList.length))
                                message.accList = [];
                            message.accList.push($root.common.TrdAcc.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.AccRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.AccRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.AccRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accList != null && message.hasOwnProperty("accList")) {
                    if (!Array.isArray(message.accList))
                        return "accList: array expected";
                    for (let i = 0; i < message.accList.length; ++i) {
                        let error = $root.common.TrdAcc.verify(message.accList[i]);
                        if (error)
                            return "accList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.AccRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.AccRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.AccRes.S2C)
                    return object;
                let message = new $root.base.AccRes.S2C();
                if (object.accList) {
                    if (!Array.isArray(object.accList))
                        throw TypeError(".base.AccRes.S2C.accList: array expected");
                    message.accList = [];
                    for (let i = 0; i < object.accList.length; ++i) {
                        if (typeof object.accList[i] !== "object")
                            throw TypeError(".base.AccRes.S2C.accList: object expected");
                        message.accList[i] = $root.common.TrdAcc.fromObject(object.accList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.AccRes.S2C
             * @static
             * @param {base.AccRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.accList = [];
                if (message.accList && message.accList.length) {
                    object.accList = [];
                    for (let j = 0; j < message.accList.length; ++j)
                        object.accList[j] = $root.common.TrdAcc.toObject(message.accList[j], options);
                }
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.AccRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.AccRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.AccRes.S2C";
            };

            return S2C;
        })();

        return AccRes;
    })();

    base.FundReq = (function() {

        /**
         * Properties of a FundReq.
         * @memberof base
         * @interface IFundReq
         * @property {base.FundReq.IC2S} c2s FundReq c2s
         */

        /**
         * Constructs a new FundReq.
         * @memberof base
         * @classdesc 查询账户资金请求
         * @implements IFundReq
         * @constructor
         * @param {base.IFundReq=} [properties] Properties to set
         */
        function FundReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundReq c2s.
         * @member {base.FundReq.IC2S} c2s
         * @memberof base.FundReq
         * @instance
         */
        FundReq.prototype.c2s = null;

        /**
         * Creates a new FundReq instance using the specified properties.
         * @function create
         * @memberof base.FundReq
         * @static
         * @param {base.IFundReq=} [properties] Properties to set
         * @returns {base.FundReq} FundReq instance
         */
        FundReq.create = function create(properties) {
            return new FundReq(properties);
        };

        /**
         * Encodes the specified FundReq message. Does not implicitly {@link base.FundReq.verify|verify} messages.
         * @function encode
         * @memberof base.FundReq
         * @static
         * @param {base.IFundReq} message FundReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.FundReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FundReq message, length delimited. Does not implicitly {@link base.FundReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.FundReq
         * @static
         * @param {base.IFundReq} message FundReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.FundReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.FundReq} FundReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.FundReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.FundReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a FundReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.FundReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.FundReq} FundReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundReq message.
         * @function verify
         * @memberof base.FundReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.FundReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a FundReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.FundReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.FundReq} FundReq
         */
        FundReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.FundReq)
                return object;
            let message = new $root.base.FundReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.FundReq.c2s: object expected");
                message.c2s = $root.base.FundReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a FundReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.FundReq
         * @static
         * @param {base.FundReq} message FundReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.FundReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this FundReq to JSON.
         * @function toJSON
         * @memberof base.FundReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FundReq
         * @function getTypeUrl
         * @memberof base.FundReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FundReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.FundReq";
        };

        FundReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.FundReq
             * @interface IC2S
             * @property {common.ITrdHeader} header C2S header
             * @property {boolean|null} [refreshCache] C2S refreshCache
             * @property {number|null} [currency] C2S currency
             */

            /**
             * Constructs a new C2S.
             * @memberof base.FundReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.FundReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S header.
             * @member {common.ITrdHeader} header
             * @memberof base.FundReq.C2S
             * @instance
             */
            C2S.prototype.header = null;

            /**
             * C2S refreshCache.
             * @member {boolean} refreshCache
             * @memberof base.FundReq.C2S
             * @instance
             */
            C2S.prototype.refreshCache = false;

            /**
             * C2S currency.
             * @member {number} currency
             * @memberof base.FundReq.C2S
             * @instance
             */
            C2S.prototype.currency = 0;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.FundReq.C2S
             * @static
             * @param {base.FundReq.IC2S=} [properties] Properties to set
             * @returns {base.FundReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.FundReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.FundReq.C2S
             * @static
             * @param {base.FundReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.refreshCache != null && Object.hasOwnProperty.call(message, "refreshCache"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refreshCache);
                if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.currency);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.FundReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.FundReq.C2S
             * @static
             * @param {base.FundReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.FundReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.FundReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.FundReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.refreshCache = reader.bool();
                            break;
                        }
                    case 3: {
                            message.currency = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.FundReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.FundReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.FundReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                    if (typeof message.refreshCache !== "boolean")
                        return "refreshCache: boolean expected";
                if (message.currency != null && message.hasOwnProperty("currency"))
                    if (!$util.isInteger(message.currency))
                        return "currency: integer expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.FundReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.FundReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.FundReq.C2S)
                    return object;
                let message = new $root.base.FundReq.C2S();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".base.FundReq.C2S.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.refreshCache != null)
                    message.refreshCache = Boolean(object.refreshCache);
                if (object.currency != null)
                    message.currency = object.currency | 0;
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.FundReq.C2S
             * @static
             * @param {base.FundReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.header = null;
                    object.refreshCache = false;
                    object.currency = 0;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                    object.refreshCache = message.refreshCache;
                if (message.currency != null && message.hasOwnProperty("currency"))
                    object.currency = message.currency;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.FundReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.FundReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.FundReq.C2S";
            };

            return C2S;
        })();

        return FundReq;
    })();

    base.FundRes = (function() {

        /**
         * Properties of a FundRes.
         * @memberof base
         * @interface IFundRes
         * @property {number} retType FundRes retType
         * @property {string|null} [retMsg] FundRes retMsg
         * @property {number|null} [errCode] FundRes errCode
         * @property {base.FundRes.IS2C|null} [s2c] FundRes s2c
         */

        /**
         * Constructs a new FundRes.
         * @memberof base
         * @classdesc 查询账户资金响应
         * @implements IFundRes
         * @constructor
         * @param {base.IFundRes=} [properties] Properties to set
         */
        function FundRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundRes retType.
         * @member {number} retType
         * @memberof base.FundRes
         * @instance
         */
        FundRes.prototype.retType = 0;

        /**
         * FundRes retMsg.
         * @member {string} retMsg
         * @memberof base.FundRes
         * @instance
         */
        FundRes.prototype.retMsg = "";

        /**
         * FundRes errCode.
         * @member {number} errCode
         * @memberof base.FundRes
         * @instance
         */
        FundRes.prototype.errCode = 0;

        /**
         * FundRes s2c.
         * @member {base.FundRes.IS2C|null|undefined} s2c
         * @memberof base.FundRes
         * @instance
         */
        FundRes.prototype.s2c = null;

        /**
         * Creates a new FundRes instance using the specified properties.
         * @function create
         * @memberof base.FundRes
         * @static
         * @param {base.IFundRes=} [properties] Properties to set
         * @returns {base.FundRes} FundRes instance
         */
        FundRes.create = function create(properties) {
            return new FundRes(properties);
        };

        /**
         * Encodes the specified FundRes message. Does not implicitly {@link base.FundRes.verify|verify} messages.
         * @function encode
         * @memberof base.FundRes
         * @static
         * @param {base.IFundRes} message FundRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.FundRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FundRes message, length delimited. Does not implicitly {@link base.FundRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.FundRes
         * @static
         * @param {base.IFundRes} message FundRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.FundRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.FundRes} FundRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.FundRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.FundRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a FundRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.FundRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.FundRes} FundRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundRes message.
         * @function verify
         * @memberof base.FundRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.FundRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a FundRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.FundRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.FundRes} FundRes
         */
        FundRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.FundRes)
                return object;
            let message = new $root.base.FundRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.FundRes.s2c: object expected");
                message.s2c = $root.base.FundRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a FundRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.FundRes
         * @static
         * @param {base.FundRes} message FundRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.FundRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this FundRes to JSON.
         * @function toJSON
         * @memberof base.FundRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FundRes
         * @function getTypeUrl
         * @memberof base.FundRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FundRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.FundRes";
        };

        FundRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.FundRes
             * @interface IS2C
             * @property {common.ITrdHeader} header S2C header
             * @property {common.IFunds|null} [funds] S2C funds
             */

            /**
             * Constructs a new S2C.
             * @memberof base.FundRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.FundRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C header.
             * @member {common.ITrdHeader} header
             * @memberof base.FundRes.S2C
             * @instance
             */
            S2C.prototype.header = null;

            /**
             * S2C funds.
             * @member {common.IFunds|null|undefined} funds
             * @memberof base.FundRes.S2C
             * @instance
             */
            S2C.prototype.funds = null;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.FundRes.S2C
             * @static
             * @param {base.FundRes.IS2C=} [properties] Properties to set
             * @returns {base.FundRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.FundRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.FundRes.S2C
             * @static
             * @param {base.FundRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.funds != null && Object.hasOwnProperty.call(message, "funds"))
                    $root.common.Funds.encode(message.funds, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.FundRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.FundRes.S2C
             * @static
             * @param {base.FundRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.FundRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.FundRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.FundRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.funds = $root.common.Funds.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.FundRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.FundRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.FundRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.funds != null && message.hasOwnProperty("funds")) {
                    let error = $root.common.Funds.verify(message.funds);
                    if (error)
                        return "funds." + error;
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.FundRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.FundRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.FundRes.S2C)
                    return object;
                let message = new $root.base.FundRes.S2C();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".base.FundRes.S2C.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.funds != null) {
                    if (typeof object.funds !== "object")
                        throw TypeError(".base.FundRes.S2C.funds: object expected");
                    message.funds = $root.common.Funds.fromObject(object.funds);
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.FundRes.S2C
             * @static
             * @param {base.FundRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.header = null;
                    object.funds = null;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.funds != null && message.hasOwnProperty("funds"))
                    object.funds = $root.common.Funds.toObject(message.funds, options);
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.FundRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.FundRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.FundRes.S2C";
            };

            return S2C;
        })();

        return FundRes;
    })();

    base.stockReq = (function() {

        /**
         * Properties of a stockReq.
         * @memberof base
         * @interface IstockReq
         * @property {base.stockReq.IC2S} c2s stockReq c2s
         */

        /**
         * Constructs a new stockReq.
         * @memberof base
         * @classdesc 查询股票基本信息请求
         * @implements IstockReq
         * @constructor
         * @param {base.IstockReq=} [properties] Properties to set
         */
        function stockReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * stockReq c2s.
         * @member {base.stockReq.IC2S} c2s
         * @memberof base.stockReq
         * @instance
         */
        stockReq.prototype.c2s = null;

        /**
         * Creates a new stockReq instance using the specified properties.
         * @function create
         * @memberof base.stockReq
         * @static
         * @param {base.IstockReq=} [properties] Properties to set
         * @returns {base.stockReq} stockReq instance
         */
        stockReq.create = function create(properties) {
            return new stockReq(properties);
        };

        /**
         * Encodes the specified stockReq message. Does not implicitly {@link base.stockReq.verify|verify} messages.
         * @function encode
         * @memberof base.stockReq
         * @static
         * @param {base.IstockReq} message stockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stockReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.stockReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified stockReq message, length delimited. Does not implicitly {@link base.stockReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.stockReq
         * @static
         * @param {base.IstockReq} message stockReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stockReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a stockReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.stockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.stockReq} stockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stockReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.stockReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.stockReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a stockReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.stockReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.stockReq} stockReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stockReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a stockReq message.
         * @function verify
         * @memberof base.stockReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        stockReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.stockReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a stockReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.stockReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.stockReq} stockReq
         */
        stockReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.stockReq)
                return object;
            let message = new $root.base.stockReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.stockReq.c2s: object expected");
                message.c2s = $root.base.stockReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a stockReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.stockReq
         * @static
         * @param {base.stockReq} message stockReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        stockReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.stockReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this stockReq to JSON.
         * @function toJSON
         * @memberof base.stockReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        stockReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for stockReq
         * @function getTypeUrl
         * @memberof base.stockReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        stockReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.stockReq";
        };

        stockReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.stockReq
             * @interface IC2S
             * @property {Array.<common.ISecurity>|null} [securityList] C2S securityList
             */

            /**
             * Constructs a new C2S.
             * @memberof base.stockReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.stockReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                this.securityList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S securityList.
             * @member {Array.<common.ISecurity>} securityList
             * @memberof base.stockReq.C2S
             * @instance
             */
            C2S.prototype.securityList = $util.emptyArray;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.stockReq.C2S
             * @static
             * @param {base.stockReq.IC2S=} [properties] Properties to set
             * @returns {base.stockReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.stockReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.stockReq.C2S
             * @static
             * @param {base.stockReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.securityList != null && message.securityList.length)
                    for (let i = 0; i < message.securityList.length; ++i)
                        $root.common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.stockReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.stockReq.C2S
             * @static
             * @param {base.stockReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.stockReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.stockReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.stockReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.securityList && message.securityList.length))
                                message.securityList = [];
                            message.securityList.push($root.common.Security.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.stockReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.stockReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.stockReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.securityList != null && message.hasOwnProperty("securityList")) {
                    if (!Array.isArray(message.securityList))
                        return "securityList: array expected";
                    for (let i = 0; i < message.securityList.length; ++i) {
                        let error = $root.common.Security.verify(message.securityList[i]);
                        if (error)
                            return "securityList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.stockReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.stockReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.stockReq.C2S)
                    return object;
                let message = new $root.base.stockReq.C2S();
                if (object.securityList) {
                    if (!Array.isArray(object.securityList))
                        throw TypeError(".base.stockReq.C2S.securityList: array expected");
                    message.securityList = [];
                    for (let i = 0; i < object.securityList.length; ++i) {
                        if (typeof object.securityList[i] !== "object")
                            throw TypeError(".base.stockReq.C2S.securityList: object expected");
                        message.securityList[i] = $root.common.Security.fromObject(object.securityList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.stockReq.C2S
             * @static
             * @param {base.stockReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.securityList = [];
                if (message.securityList && message.securityList.length) {
                    object.securityList = [];
                    for (let j = 0; j < message.securityList.length; ++j)
                        object.securityList[j] = $root.common.Security.toObject(message.securityList[j], options);
                }
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.stockReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.stockReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.stockReq.C2S";
            };

            return C2S;
        })();

        return stockReq;
    })();

    base.stockRes = (function() {

        /**
         * Properties of a stockRes.
         * @memberof base
         * @interface IstockRes
         * @property {number} retType stockRes retType
         * @property {string|null} [retMsg] stockRes retMsg
         * @property {number|null} [errCode] stockRes errCode
         * @property {base.stockRes.IS2C|null} [s2c] stockRes s2c
         */

        /**
         * Constructs a new stockRes.
         * @memberof base
         * @classdesc 查询股票基本信息响应
         * @implements IstockRes
         * @constructor
         * @param {base.IstockRes=} [properties] Properties to set
         */
        function stockRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * stockRes retType.
         * @member {number} retType
         * @memberof base.stockRes
         * @instance
         */
        stockRes.prototype.retType = 0;

        /**
         * stockRes retMsg.
         * @member {string} retMsg
         * @memberof base.stockRes
         * @instance
         */
        stockRes.prototype.retMsg = "";

        /**
         * stockRes errCode.
         * @member {number} errCode
         * @memberof base.stockRes
         * @instance
         */
        stockRes.prototype.errCode = 0;

        /**
         * stockRes s2c.
         * @member {base.stockRes.IS2C|null|undefined} s2c
         * @memberof base.stockRes
         * @instance
         */
        stockRes.prototype.s2c = null;

        /**
         * Creates a new stockRes instance using the specified properties.
         * @function create
         * @memberof base.stockRes
         * @static
         * @param {base.IstockRes=} [properties] Properties to set
         * @returns {base.stockRes} stockRes instance
         */
        stockRes.create = function create(properties) {
            return new stockRes(properties);
        };

        /**
         * Encodes the specified stockRes message. Does not implicitly {@link base.stockRes.verify|verify} messages.
         * @function encode
         * @memberof base.stockRes
         * @static
         * @param {base.IstockRes} message stockRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stockRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.stockRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified stockRes message, length delimited. Does not implicitly {@link base.stockRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.stockRes
         * @static
         * @param {base.IstockRes} message stockRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stockRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a stockRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.stockRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.stockRes} stockRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stockRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.stockRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.stockRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a stockRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.stockRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.stockRes} stockRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stockRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a stockRes message.
         * @function verify
         * @memberof base.stockRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        stockRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.stockRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a stockRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.stockRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.stockRes} stockRes
         */
        stockRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.stockRes)
                return object;
            let message = new $root.base.stockRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.stockRes.s2c: object expected");
                message.s2c = $root.base.stockRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a stockRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.stockRes
         * @static
         * @param {base.stockRes} message stockRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        stockRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.stockRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this stockRes to JSON.
         * @function toJSON
         * @memberof base.stockRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        stockRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for stockRes
         * @function getTypeUrl
         * @memberof base.stockRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        stockRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.stockRes";
        };

        stockRes.Snapshot = (function() {

            /**
             * Properties of a Snapshot.
             * @memberof base.stockRes
             * @interface ISnapshot
             * @property {common.ISnapshotBasicData} basic 快照基本数据
             * @property {common.IEquitySnapshotExData|null} [equityExData] 正股快照额外数据
             * @property {common.IWarrantSnapshotExData|null} [warrantExData] Snapshot warrantExData
             * @property {common.IOptionSnapshotExData|null} [optionExData] Snapshot optionExData
             * @property {common.IIndexSnapshotExData|null} [indexExData] Snapshot indexExData
             * @property {common.IPlateSnapshotExData|null} [plateExData] Snapshot plateExData
             * @property {common.IFutureSnapshotExData|null} [futureExData] Snapshot futureExData
             * @property {common.ITrustSnapshotExData|null} [trustExData] Snapshot trustExData
             */

            /**
             * Constructs a new Snapshot.
             * @memberof base.stockRes
             * @classdesc Represents a Snapshot.
             * @implements ISnapshot
             * @constructor
             * @param {base.stockRes.ISnapshot=} [properties] Properties to set
             */
            function Snapshot(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * 快照基本数据
             * @member {common.ISnapshotBasicData} basic
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.basic = null;

            /**
             * 正股快照额外数据
             * @member {common.IEquitySnapshotExData|null|undefined} equityExData
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.equityExData = null;

            /**
             * Snapshot warrantExData.
             * @member {common.IWarrantSnapshotExData|null|undefined} warrantExData
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.warrantExData = null;

            /**
             * Snapshot optionExData.
             * @member {common.IOptionSnapshotExData|null|undefined} optionExData
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.optionExData = null;

            /**
             * Snapshot indexExData.
             * @member {common.IIndexSnapshotExData|null|undefined} indexExData
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.indexExData = null;

            /**
             * Snapshot plateExData.
             * @member {common.IPlateSnapshotExData|null|undefined} plateExData
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.plateExData = null;

            /**
             * Snapshot futureExData.
             * @member {common.IFutureSnapshotExData|null|undefined} futureExData
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.futureExData = null;

            /**
             * Snapshot trustExData.
             * @member {common.ITrustSnapshotExData|null|undefined} trustExData
             * @memberof base.stockRes.Snapshot
             * @instance
             */
            Snapshot.prototype.trustExData = null;

            /**
             * Creates a new Snapshot instance using the specified properties.
             * @function create
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {base.stockRes.ISnapshot=} [properties] Properties to set
             * @returns {base.stockRes.Snapshot} Snapshot instance
             */
            Snapshot.create = function create(properties) {
                return new Snapshot(properties);
            };

            /**
             * Encodes the specified Snapshot message. Does not implicitly {@link base.stockRes.Snapshot.verify|verify} messages.
             * @function encode
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {base.stockRes.ISnapshot} message Snapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Snapshot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.SnapshotBasicData.encode(message.basic, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.equityExData != null && Object.hasOwnProperty.call(message, "equityExData"))
                    $root.common.EquitySnapshotExData.encode(message.equityExData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.warrantExData != null && Object.hasOwnProperty.call(message, "warrantExData"))
                    $root.common.WarrantSnapshotExData.encode(message.warrantExData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.optionExData != null && Object.hasOwnProperty.call(message, "optionExData"))
                    $root.common.OptionSnapshotExData.encode(message.optionExData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.indexExData != null && Object.hasOwnProperty.call(message, "indexExData"))
                    $root.common.IndexSnapshotExData.encode(message.indexExData, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.plateExData != null && Object.hasOwnProperty.call(message, "plateExData"))
                    $root.common.PlateSnapshotExData.encode(message.plateExData, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.futureExData != null && Object.hasOwnProperty.call(message, "futureExData"))
                    $root.common.FutureSnapshotExData.encode(message.futureExData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.trustExData != null && Object.hasOwnProperty.call(message, "trustExData"))
                    $root.common.TrustSnapshotExData.encode(message.trustExData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Snapshot message, length delimited. Does not implicitly {@link base.stockRes.Snapshot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {base.stockRes.ISnapshot} message Snapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Snapshot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Snapshot message from the specified reader or buffer.
             * @function decode
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.stockRes.Snapshot} Snapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Snapshot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.stockRes.Snapshot();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.basic = $root.common.SnapshotBasicData.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.equityExData = $root.common.EquitySnapshotExData.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.warrantExData = $root.common.WarrantSnapshotExData.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.optionExData = $root.common.OptionSnapshotExData.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.indexExData = $root.common.IndexSnapshotExData.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.plateExData = $root.common.PlateSnapshotExData.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.futureExData = $root.common.FutureSnapshotExData.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.trustExData = $root.common.TrustSnapshotExData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("basic"))
                    throw $util.ProtocolError("missing required 'basic'", { instance: message });
                return message;
            };

            /**
             * Decodes a Snapshot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.stockRes.Snapshot} Snapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Snapshot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Snapshot message.
             * @function verify
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Snapshot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.SnapshotBasicData.verify(message.basic);
                    if (error)
                        return "basic." + error;
                }
                if (message.equityExData != null && message.hasOwnProperty("equityExData")) {
                    let error = $root.common.EquitySnapshotExData.verify(message.equityExData);
                    if (error)
                        return "equityExData." + error;
                }
                if (message.warrantExData != null && message.hasOwnProperty("warrantExData")) {
                    let error = $root.common.WarrantSnapshotExData.verify(message.warrantExData);
                    if (error)
                        return "warrantExData." + error;
                }
                if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                    let error = $root.common.OptionSnapshotExData.verify(message.optionExData);
                    if (error)
                        return "optionExData." + error;
                }
                if (message.indexExData != null && message.hasOwnProperty("indexExData")) {
                    let error = $root.common.IndexSnapshotExData.verify(message.indexExData);
                    if (error)
                        return "indexExData." + error;
                }
                if (message.plateExData != null && message.hasOwnProperty("plateExData")) {
                    let error = $root.common.PlateSnapshotExData.verify(message.plateExData);
                    if (error)
                        return "plateExData." + error;
                }
                if (message.futureExData != null && message.hasOwnProperty("futureExData")) {
                    let error = $root.common.FutureSnapshotExData.verify(message.futureExData);
                    if (error)
                        return "futureExData." + error;
                }
                if (message.trustExData != null && message.hasOwnProperty("trustExData")) {
                    let error = $root.common.TrustSnapshotExData.verify(message.trustExData);
                    if (error)
                        return "trustExData." + error;
                }
                return null;
            };

            /**
             * Creates a Snapshot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.stockRes.Snapshot} Snapshot
             */
            Snapshot.fromObject = function fromObject(object) {
                if (object instanceof $root.base.stockRes.Snapshot)
                    return object;
                let message = new $root.base.stockRes.Snapshot();
                if (object.basic != null) {
                    if (typeof object.basic !== "object")
                        throw TypeError(".base.stockRes.Snapshot.basic: object expected");
                    message.basic = $root.common.SnapshotBasicData.fromObject(object.basic);
                }
                if (object.equityExData != null) {
                    if (typeof object.equityExData !== "object")
                        throw TypeError(".base.stockRes.Snapshot.equityExData: object expected");
                    message.equityExData = $root.common.EquitySnapshotExData.fromObject(object.equityExData);
                }
                if (object.warrantExData != null) {
                    if (typeof object.warrantExData !== "object")
                        throw TypeError(".base.stockRes.Snapshot.warrantExData: object expected");
                    message.warrantExData = $root.common.WarrantSnapshotExData.fromObject(object.warrantExData);
                }
                if (object.optionExData != null) {
                    if (typeof object.optionExData !== "object")
                        throw TypeError(".base.stockRes.Snapshot.optionExData: object expected");
                    message.optionExData = $root.common.OptionSnapshotExData.fromObject(object.optionExData);
                }
                if (object.indexExData != null) {
                    if (typeof object.indexExData !== "object")
                        throw TypeError(".base.stockRes.Snapshot.indexExData: object expected");
                    message.indexExData = $root.common.IndexSnapshotExData.fromObject(object.indexExData);
                }
                if (object.plateExData != null) {
                    if (typeof object.plateExData !== "object")
                        throw TypeError(".base.stockRes.Snapshot.plateExData: object expected");
                    message.plateExData = $root.common.PlateSnapshotExData.fromObject(object.plateExData);
                }
                if (object.futureExData != null) {
                    if (typeof object.futureExData !== "object")
                        throw TypeError(".base.stockRes.Snapshot.futureExData: object expected");
                    message.futureExData = $root.common.FutureSnapshotExData.fromObject(object.futureExData);
                }
                if (object.trustExData != null) {
                    if (typeof object.trustExData !== "object")
                        throw TypeError(".base.stockRes.Snapshot.trustExData: object expected");
                    message.trustExData = $root.common.TrustSnapshotExData.fromObject(object.trustExData);
                }
                return message;
            };

            /**
             * Creates a plain object from a Snapshot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {base.stockRes.Snapshot} message Snapshot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Snapshot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.basic = null;
                    object.equityExData = null;
                    object.warrantExData = null;
                    object.optionExData = null;
                    object.indexExData = null;
                    object.plateExData = null;
                    object.futureExData = null;
                    object.trustExData = null;
                }
                if (message.basic != null && message.hasOwnProperty("basic"))
                    object.basic = $root.common.SnapshotBasicData.toObject(message.basic, options);
                if (message.equityExData != null && message.hasOwnProperty("equityExData"))
                    object.equityExData = $root.common.EquitySnapshotExData.toObject(message.equityExData, options);
                if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                    object.warrantExData = $root.common.WarrantSnapshotExData.toObject(message.warrantExData, options);
                if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                    object.optionExData = $root.common.OptionSnapshotExData.toObject(message.optionExData, options);
                if (message.indexExData != null && message.hasOwnProperty("indexExData"))
                    object.indexExData = $root.common.IndexSnapshotExData.toObject(message.indexExData, options);
                if (message.plateExData != null && message.hasOwnProperty("plateExData"))
                    object.plateExData = $root.common.PlateSnapshotExData.toObject(message.plateExData, options);
                if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                    object.futureExData = $root.common.FutureSnapshotExData.toObject(message.futureExData, options);
                if (message.trustExData != null && message.hasOwnProperty("trustExData"))
                    object.trustExData = $root.common.TrustSnapshotExData.toObject(message.trustExData, options);
                return object;
            };

            /**
             * Converts this Snapshot to JSON.
             * @function toJSON
             * @memberof base.stockRes.Snapshot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Snapshot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Snapshot
             * @function getTypeUrl
             * @memberof base.stockRes.Snapshot
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Snapshot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.stockRes.Snapshot";
            };

            return Snapshot;
        })();

        stockRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.stockRes
             * @interface IS2C
             * @property {Array.<base.stockRes.ISnapshot>|null} [snapshotList] S2C snapshotList
             */

            /**
             * Constructs a new S2C.
             * @memberof base.stockRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.stockRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.snapshotList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C snapshotList.
             * @member {Array.<base.stockRes.ISnapshot>} snapshotList
             * @memberof base.stockRes.S2C
             * @instance
             */
            S2C.prototype.snapshotList = $util.emptyArray;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.stockRes.S2C
             * @static
             * @param {base.stockRes.IS2C=} [properties] Properties to set
             * @returns {base.stockRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.stockRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.stockRes.S2C
             * @static
             * @param {base.stockRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.snapshotList != null && message.snapshotList.length)
                    for (let i = 0; i < message.snapshotList.length; ++i)
                        $root.base.stockRes.Snapshot.encode(message.snapshotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.stockRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.stockRes.S2C
             * @static
             * @param {base.stockRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.stockRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.stockRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.stockRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.snapshotList && message.snapshotList.length))
                                message.snapshotList = [];
                            message.snapshotList.push($root.base.stockRes.Snapshot.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.stockRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.stockRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.stockRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.snapshotList != null && message.hasOwnProperty("snapshotList")) {
                    if (!Array.isArray(message.snapshotList))
                        return "snapshotList: array expected";
                    for (let i = 0; i < message.snapshotList.length; ++i) {
                        let error = $root.base.stockRes.Snapshot.verify(message.snapshotList[i]);
                        if (error)
                            return "snapshotList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.stockRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.stockRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.stockRes.S2C)
                    return object;
                let message = new $root.base.stockRes.S2C();
                if (object.snapshotList) {
                    if (!Array.isArray(object.snapshotList))
                        throw TypeError(".base.stockRes.S2C.snapshotList: array expected");
                    message.snapshotList = [];
                    for (let i = 0; i < object.snapshotList.length; ++i) {
                        if (typeof object.snapshotList[i] !== "object")
                            throw TypeError(".base.stockRes.S2C.snapshotList: object expected");
                        message.snapshotList[i] = $root.base.stockRes.Snapshot.fromObject(object.snapshotList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.stockRes.S2C
             * @static
             * @param {base.stockRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.snapshotList = [];
                if (message.snapshotList && message.snapshotList.length) {
                    object.snapshotList = [];
                    for (let j = 0; j < message.snapshotList.length; ++j)
                        object.snapshotList[j] = $root.base.stockRes.Snapshot.toObject(message.snapshotList[j], options);
                }
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.stockRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.stockRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.stockRes.S2C";
            };

            return S2C;
        })();

        return stockRes;
    })();

    base.CapFlowReq = (function() {

        /**
         * Properties of a CapFlowReq.
         * @memberof base
         * @interface ICapFlowReq
         * @property {base.CapFlowReq.IC2S} c2s CapFlowReq c2s
         */

        /**
         * Constructs a new CapFlowReq.
         * @memberof base
         * @classdesc 获取资金流向请求
         * @implements ICapFlowReq
         * @constructor
         * @param {base.ICapFlowReq=} [properties] Properties to set
         */
        function CapFlowReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapFlowReq c2s.
         * @member {base.CapFlowReq.IC2S} c2s
         * @memberof base.CapFlowReq
         * @instance
         */
        CapFlowReq.prototype.c2s = null;

        /**
         * Creates a new CapFlowReq instance using the specified properties.
         * @function create
         * @memberof base.CapFlowReq
         * @static
         * @param {base.ICapFlowReq=} [properties] Properties to set
         * @returns {base.CapFlowReq} CapFlowReq instance
         */
        CapFlowReq.create = function create(properties) {
            return new CapFlowReq(properties);
        };

        /**
         * Encodes the specified CapFlowReq message. Does not implicitly {@link base.CapFlowReq.verify|verify} messages.
         * @function encode
         * @memberof base.CapFlowReq
         * @static
         * @param {base.ICapFlowReq} message CapFlowReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapFlowReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.CapFlowReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CapFlowReq message, length delimited. Does not implicitly {@link base.CapFlowReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.CapFlowReq
         * @static
         * @param {base.ICapFlowReq} message CapFlowReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapFlowReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapFlowReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.CapFlowReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.CapFlowReq} CapFlowReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapFlowReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapFlowReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.CapFlowReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a CapFlowReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.CapFlowReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.CapFlowReq} CapFlowReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapFlowReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapFlowReq message.
         * @function verify
         * @memberof base.CapFlowReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapFlowReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.CapFlowReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a CapFlowReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.CapFlowReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.CapFlowReq} CapFlowReq
         */
        CapFlowReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.CapFlowReq)
                return object;
            let message = new $root.base.CapFlowReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.CapFlowReq.c2s: object expected");
                message.c2s = $root.base.CapFlowReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a CapFlowReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.CapFlowReq
         * @static
         * @param {base.CapFlowReq} message CapFlowReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CapFlowReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.CapFlowReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this CapFlowReq to JSON.
         * @function toJSON
         * @memberof base.CapFlowReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CapFlowReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CapFlowReq
         * @function getTypeUrl
         * @memberof base.CapFlowReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CapFlowReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.CapFlowReq";
        };

        CapFlowReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.CapFlowReq
             * @interface IC2S
             * @property {common.ISecurity} security C2S security
             * @property {number|null} [periodType] C2S periodType
             * @property {string|null} [beginTime] C2S beginTime
             * @property {string|null} [endTime] C2S endTime
             */

            /**
             * Constructs a new C2S.
             * @memberof base.CapFlowReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.CapFlowReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S security.
             * @member {common.ISecurity} security
             * @memberof base.CapFlowReq.C2S
             * @instance
             */
            C2S.prototype.security = null;

            /**
             * C2S periodType.
             * @member {number} periodType
             * @memberof base.CapFlowReq.C2S
             * @instance
             */
            C2S.prototype.periodType = 0;

            /**
             * C2S beginTime.
             * @member {string} beginTime
             * @memberof base.CapFlowReq.C2S
             * @instance
             */
            C2S.prototype.beginTime = "";

            /**
             * C2S endTime.
             * @member {string} endTime
             * @memberof base.CapFlowReq.C2S
             * @instance
             */
            C2S.prototype.endTime = "";

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {base.CapFlowReq.IC2S=} [properties] Properties to set
             * @returns {base.CapFlowReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.CapFlowReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {base.CapFlowReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.periodType != null && Object.hasOwnProperty.call(message, "periodType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.periodType);
                if (message.beginTime != null && Object.hasOwnProperty.call(message, "beginTime"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.beginTime);
                if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.CapFlowReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {base.CapFlowReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.CapFlowReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapFlowReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.security = $root.common.Security.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.periodType = reader.int32();
                            break;
                        }
                    case 3: {
                            message.beginTime = reader.string();
                            break;
                        }
                    case 4: {
                            message.endTime = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("security"))
                    throw $util.ProtocolError("missing required 'security'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.CapFlowReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.Security.verify(message.security);
                    if (error)
                        return "security." + error;
                }
                if (message.periodType != null && message.hasOwnProperty("periodType"))
                    if (!$util.isInteger(message.periodType))
                        return "periodType: integer expected";
                if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                    if (!$util.isString(message.beginTime))
                        return "beginTime: string expected";
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    if (!$util.isString(message.endTime))
                        return "endTime: string expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.CapFlowReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.CapFlowReq.C2S)
                    return object;
                let message = new $root.base.CapFlowReq.C2S();
                if (object.security != null) {
                    if (typeof object.security !== "object")
                        throw TypeError(".base.CapFlowReq.C2S.security: object expected");
                    message.security = $root.common.Security.fromObject(object.security);
                }
                if (object.periodType != null)
                    message.periodType = object.periodType | 0;
                if (object.beginTime != null)
                    message.beginTime = String(object.beginTime);
                if (object.endTime != null)
                    message.endTime = String(object.endTime);
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {base.CapFlowReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.security = null;
                    object.periodType = 0;
                    object.beginTime = "";
                    object.endTime = "";
                }
                if (message.security != null && message.hasOwnProperty("security"))
                    object.security = $root.common.Security.toObject(message.security, options);
                if (message.periodType != null && message.hasOwnProperty("periodType"))
                    object.periodType = message.periodType;
                if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                    object.beginTime = message.beginTime;
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    object.endTime = message.endTime;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.CapFlowReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.CapFlowReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.CapFlowReq.C2S";
            };

            return C2S;
        })();

        return CapFlowReq;
    })();

    base.CapFlowRes = (function() {

        /**
         * Properties of a CapFlowRes.
         * @memberof base
         * @interface ICapFlowRes
         * @property {number} retType CapFlowRes retType
         * @property {string|null} [retMsg] CapFlowRes retMsg
         * @property {number|null} [errCode] CapFlowRes errCode
         * @property {base.CapFlowRes.IS2C|null} [s2c] CapFlowRes s2c
         */

        /**
         * Constructs a new CapFlowRes.
         * @memberof base
         * @classdesc 获取资金流向响应
         * @implements ICapFlowRes
         * @constructor
         * @param {base.ICapFlowRes=} [properties] Properties to set
         */
        function CapFlowRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapFlowRes retType.
         * @member {number} retType
         * @memberof base.CapFlowRes
         * @instance
         */
        CapFlowRes.prototype.retType = -400;

        /**
         * CapFlowRes retMsg.
         * @member {string} retMsg
         * @memberof base.CapFlowRes
         * @instance
         */
        CapFlowRes.prototype.retMsg = "";

        /**
         * CapFlowRes errCode.
         * @member {number} errCode
         * @memberof base.CapFlowRes
         * @instance
         */
        CapFlowRes.prototype.errCode = 0;

        /**
         * CapFlowRes s2c.
         * @member {base.CapFlowRes.IS2C|null|undefined} s2c
         * @memberof base.CapFlowRes
         * @instance
         */
        CapFlowRes.prototype.s2c = null;

        /**
         * Creates a new CapFlowRes instance using the specified properties.
         * @function create
         * @memberof base.CapFlowRes
         * @static
         * @param {base.ICapFlowRes=} [properties] Properties to set
         * @returns {base.CapFlowRes} CapFlowRes instance
         */
        CapFlowRes.create = function create(properties) {
            return new CapFlowRes(properties);
        };

        /**
         * Encodes the specified CapFlowRes message. Does not implicitly {@link base.CapFlowRes.verify|verify} messages.
         * @function encode
         * @memberof base.CapFlowRes
         * @static
         * @param {base.ICapFlowRes} message CapFlowRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapFlowRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.CapFlowRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CapFlowRes message, length delimited. Does not implicitly {@link base.CapFlowRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.CapFlowRes
         * @static
         * @param {base.ICapFlowRes} message CapFlowRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapFlowRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapFlowRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.CapFlowRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.CapFlowRes} CapFlowRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapFlowRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapFlowRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.CapFlowRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a CapFlowRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.CapFlowRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.CapFlowRes} CapFlowRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapFlowRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapFlowRes message.
         * @function verify
         * @memberof base.CapFlowRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapFlowRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.CapFlowRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a CapFlowRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.CapFlowRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.CapFlowRes} CapFlowRes
         */
        CapFlowRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.CapFlowRes)
                return object;
            let message = new $root.base.CapFlowRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.CapFlowRes.s2c: object expected");
                message.s2c = $root.base.CapFlowRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a CapFlowRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.CapFlowRes
         * @static
         * @param {base.CapFlowRes} message CapFlowRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CapFlowRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.CapFlowRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this CapFlowRes to JSON.
         * @function toJSON
         * @memberof base.CapFlowRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CapFlowRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CapFlowRes
         * @function getTypeUrl
         * @memberof base.CapFlowRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CapFlowRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.CapFlowRes";
        };

        CapFlowRes.CapitalFlowItem = (function() {

            /**
             * Properties of a CapitalFlowItem.
             * @memberof base.CapFlowRes
             * @interface ICapitalFlowItem
             * @property {number} inFlow CapitalFlowItem inFlow
             * @property {string|null} [time] CapitalFlowItem time
             * @property {number|null} [timestamp] CapitalFlowItem timestamp
             * @property {number|null} [mainInFlow] CapitalFlowItem mainInFlow
             * @property {number|null} [superInFlow] CapitalFlowItem superInFlow
             * @property {number|null} [bigInFlow] CapitalFlowItem bigInFlow
             * @property {number|null} [midInFlow] CapitalFlowItem midInFlow
             * @property {number|null} [smlInFlow] CapitalFlowItem smlInFlow
             */

            /**
             * Constructs a new CapitalFlowItem.
             * @memberof base.CapFlowRes
             * @classdesc Represents a CapitalFlowItem.
             * @implements ICapitalFlowItem
             * @constructor
             * @param {base.CapFlowRes.ICapitalFlowItem=} [properties] Properties to set
             */
            function CapitalFlowItem(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CapitalFlowItem inFlow.
             * @member {number} inFlow
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.inFlow = 0;

            /**
             * CapitalFlowItem time.
             * @member {string} time
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.time = "";

            /**
             * CapitalFlowItem timestamp.
             * @member {number} timestamp
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.timestamp = 0;

            /**
             * CapitalFlowItem mainInFlow.
             * @member {number} mainInFlow
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.mainInFlow = 0;

            /**
             * CapitalFlowItem superInFlow.
             * @member {number} superInFlow
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.superInFlow = 0;

            /**
             * CapitalFlowItem bigInFlow.
             * @member {number} bigInFlow
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.bigInFlow = 0;

            /**
             * CapitalFlowItem midInFlow.
             * @member {number} midInFlow
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.midInFlow = 0;

            /**
             * CapitalFlowItem smlInFlow.
             * @member {number} smlInFlow
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             */
            CapitalFlowItem.prototype.smlInFlow = 0;

            /**
             * Creates a new CapitalFlowItem instance using the specified properties.
             * @function create
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {base.CapFlowRes.ICapitalFlowItem=} [properties] Properties to set
             * @returns {base.CapFlowRes.CapitalFlowItem} CapitalFlowItem instance
             */
            CapitalFlowItem.create = function create(properties) {
                return new CapitalFlowItem(properties);
            };

            /**
             * Encodes the specified CapitalFlowItem message. Does not implicitly {@link base.CapFlowRes.CapitalFlowItem.verify|verify} messages.
             * @function encode
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {base.CapFlowRes.ICapitalFlowItem} message CapitalFlowItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CapitalFlowItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.inFlow);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.time);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.timestamp);
                if (message.mainInFlow != null && Object.hasOwnProperty.call(message, "mainInFlow"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.mainInFlow);
                if (message.superInFlow != null && Object.hasOwnProperty.call(message, "superInFlow"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.superInFlow);
                if (message.bigInFlow != null && Object.hasOwnProperty.call(message, "bigInFlow"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.bigInFlow);
                if (message.midInFlow != null && Object.hasOwnProperty.call(message, "midInFlow"))
                    writer.uint32(/* id 7, wireType 1 =*/57).double(message.midInFlow);
                if (message.smlInFlow != null && Object.hasOwnProperty.call(message, "smlInFlow"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.smlInFlow);
                return writer;
            };

            /**
             * Encodes the specified CapitalFlowItem message, length delimited. Does not implicitly {@link base.CapFlowRes.CapitalFlowItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {base.CapFlowRes.ICapitalFlowItem} message CapitalFlowItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CapitalFlowItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CapitalFlowItem message from the specified reader or buffer.
             * @function decode
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.CapFlowRes.CapitalFlowItem} CapitalFlowItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CapitalFlowItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapFlowRes.CapitalFlowItem();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.inFlow = reader.double();
                            break;
                        }
                    case 2: {
                            message.time = reader.string();
                            break;
                        }
                    case 3: {
                            message.timestamp = reader.double();
                            break;
                        }
                    case 4: {
                            message.mainInFlow = reader.double();
                            break;
                        }
                    case 5: {
                            message.superInFlow = reader.double();
                            break;
                        }
                    case 6: {
                            message.bigInFlow = reader.double();
                            break;
                        }
                    case 7: {
                            message.midInFlow = reader.double();
                            break;
                        }
                    case 8: {
                            message.smlInFlow = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("inFlow"))
                    throw $util.ProtocolError("missing required 'inFlow'", { instance: message });
                return message;
            };

            /**
             * Decodes a CapitalFlowItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.CapFlowRes.CapitalFlowItem} CapitalFlowItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CapitalFlowItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CapitalFlowItem message.
             * @function verify
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CapitalFlowItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.inFlow !== "number")
                    return "inFlow: number expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isString(message.time))
                        return "time: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp !== "number")
                        return "timestamp: number expected";
                if (message.mainInFlow != null && message.hasOwnProperty("mainInFlow"))
                    if (typeof message.mainInFlow !== "number")
                        return "mainInFlow: number expected";
                if (message.superInFlow != null && message.hasOwnProperty("superInFlow"))
                    if (typeof message.superInFlow !== "number")
                        return "superInFlow: number expected";
                if (message.bigInFlow != null && message.hasOwnProperty("bigInFlow"))
                    if (typeof message.bigInFlow !== "number")
                        return "bigInFlow: number expected";
                if (message.midInFlow != null && message.hasOwnProperty("midInFlow"))
                    if (typeof message.midInFlow !== "number")
                        return "midInFlow: number expected";
                if (message.smlInFlow != null && message.hasOwnProperty("smlInFlow"))
                    if (typeof message.smlInFlow !== "number")
                        return "smlInFlow: number expected";
                return null;
            };

            /**
             * Creates a CapitalFlowItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.CapFlowRes.CapitalFlowItem} CapitalFlowItem
             */
            CapitalFlowItem.fromObject = function fromObject(object) {
                if (object instanceof $root.base.CapFlowRes.CapitalFlowItem)
                    return object;
                let message = new $root.base.CapFlowRes.CapitalFlowItem();
                if (object.inFlow != null)
                    message.inFlow = Number(object.inFlow);
                if (object.time != null)
                    message.time = String(object.time);
                if (object.timestamp != null)
                    message.timestamp = Number(object.timestamp);
                if (object.mainInFlow != null)
                    message.mainInFlow = Number(object.mainInFlow);
                if (object.superInFlow != null)
                    message.superInFlow = Number(object.superInFlow);
                if (object.bigInFlow != null)
                    message.bigInFlow = Number(object.bigInFlow);
                if (object.midInFlow != null)
                    message.midInFlow = Number(object.midInFlow);
                if (object.smlInFlow != null)
                    message.smlInFlow = Number(object.smlInFlow);
                return message;
            };

            /**
             * Creates a plain object from a CapitalFlowItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {base.CapFlowRes.CapitalFlowItem} message CapitalFlowItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CapitalFlowItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.inFlow = 0;
                    object.time = "";
                    object.timestamp = 0;
                    object.mainInFlow = 0;
                    object.superInFlow = 0;
                    object.bigInFlow = 0;
                    object.midInFlow = 0;
                    object.smlInFlow = 0;
                }
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    object.inFlow = options.json && !isFinite(message.inFlow) ? String(message.inFlow) : message.inFlow;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
                if (message.mainInFlow != null && message.hasOwnProperty("mainInFlow"))
                    object.mainInFlow = options.json && !isFinite(message.mainInFlow) ? String(message.mainInFlow) : message.mainInFlow;
                if (message.superInFlow != null && message.hasOwnProperty("superInFlow"))
                    object.superInFlow = options.json && !isFinite(message.superInFlow) ? String(message.superInFlow) : message.superInFlow;
                if (message.bigInFlow != null && message.hasOwnProperty("bigInFlow"))
                    object.bigInFlow = options.json && !isFinite(message.bigInFlow) ? String(message.bigInFlow) : message.bigInFlow;
                if (message.midInFlow != null && message.hasOwnProperty("midInFlow"))
                    object.midInFlow = options.json && !isFinite(message.midInFlow) ? String(message.midInFlow) : message.midInFlow;
                if (message.smlInFlow != null && message.hasOwnProperty("smlInFlow"))
                    object.smlInFlow = options.json && !isFinite(message.smlInFlow) ? String(message.smlInFlow) : message.smlInFlow;
                return object;
            };

            /**
             * Converts this CapitalFlowItem to JSON.
             * @function toJSON
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CapitalFlowItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CapitalFlowItem
             * @function getTypeUrl
             * @memberof base.CapFlowRes.CapitalFlowItem
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CapitalFlowItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.CapFlowRes.CapitalFlowItem";
            };

            return CapitalFlowItem;
        })();

        CapFlowRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.CapFlowRes
             * @interface IS2C
             * @property {Array.<base.CapFlowRes.ICapitalFlowItem>|null} [flowItemList] S2C flowItemList
             * @property {string|null} [lastValidTime] S2C lastValidTime
             * @property {number|null} [lastValidTimestamp] S2C lastValidTimestamp
             */

            /**
             * Constructs a new S2C.
             * @memberof base.CapFlowRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.CapFlowRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.flowItemList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C flowItemList.
             * @member {Array.<base.CapFlowRes.ICapitalFlowItem>} flowItemList
             * @memberof base.CapFlowRes.S2C
             * @instance
             */
            S2C.prototype.flowItemList = $util.emptyArray;

            /**
             * S2C lastValidTime.
             * @member {string} lastValidTime
             * @memberof base.CapFlowRes.S2C
             * @instance
             */
            S2C.prototype.lastValidTime = "";

            /**
             * S2C lastValidTimestamp.
             * @member {number} lastValidTimestamp
             * @memberof base.CapFlowRes.S2C
             * @instance
             */
            S2C.prototype.lastValidTimestamp = 0;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {base.CapFlowRes.IS2C=} [properties] Properties to set
             * @returns {base.CapFlowRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.CapFlowRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {base.CapFlowRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flowItemList != null && message.flowItemList.length)
                    for (let i = 0; i < message.flowItemList.length; ++i)
                        $root.base.CapFlowRes.CapitalFlowItem.encode(message.flowItemList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.lastValidTime != null && Object.hasOwnProperty.call(message, "lastValidTime"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.lastValidTime);
                if (message.lastValidTimestamp != null && Object.hasOwnProperty.call(message, "lastValidTimestamp"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.lastValidTimestamp);
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.CapFlowRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {base.CapFlowRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.CapFlowRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapFlowRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.flowItemList && message.flowItemList.length))
                                message.flowItemList = [];
                            message.flowItemList.push($root.base.CapFlowRes.CapitalFlowItem.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.lastValidTime = reader.string();
                            break;
                        }
                    case 3: {
                            message.lastValidTimestamp = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.CapFlowRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flowItemList != null && message.hasOwnProperty("flowItemList")) {
                    if (!Array.isArray(message.flowItemList))
                        return "flowItemList: array expected";
                    for (let i = 0; i < message.flowItemList.length; ++i) {
                        let error = $root.base.CapFlowRes.CapitalFlowItem.verify(message.flowItemList[i]);
                        if (error)
                            return "flowItemList." + error;
                    }
                }
                if (message.lastValidTime != null && message.hasOwnProperty("lastValidTime"))
                    if (!$util.isString(message.lastValidTime))
                        return "lastValidTime: string expected";
                if (message.lastValidTimestamp != null && message.hasOwnProperty("lastValidTimestamp"))
                    if (typeof message.lastValidTimestamp !== "number")
                        return "lastValidTimestamp: number expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.CapFlowRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.CapFlowRes.S2C)
                    return object;
                let message = new $root.base.CapFlowRes.S2C();
                if (object.flowItemList) {
                    if (!Array.isArray(object.flowItemList))
                        throw TypeError(".base.CapFlowRes.S2C.flowItemList: array expected");
                    message.flowItemList = [];
                    for (let i = 0; i < object.flowItemList.length; ++i) {
                        if (typeof object.flowItemList[i] !== "object")
                            throw TypeError(".base.CapFlowRes.S2C.flowItemList: object expected");
                        message.flowItemList[i] = $root.base.CapFlowRes.CapitalFlowItem.fromObject(object.flowItemList[i]);
                    }
                }
                if (object.lastValidTime != null)
                    message.lastValidTime = String(object.lastValidTime);
                if (object.lastValidTimestamp != null)
                    message.lastValidTimestamp = Number(object.lastValidTimestamp);
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {base.CapFlowRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.flowItemList = [];
                if (options.defaults) {
                    object.lastValidTime = "";
                    object.lastValidTimestamp = 0;
                }
                if (message.flowItemList && message.flowItemList.length) {
                    object.flowItemList = [];
                    for (let j = 0; j < message.flowItemList.length; ++j)
                        object.flowItemList[j] = $root.base.CapFlowRes.CapitalFlowItem.toObject(message.flowItemList[j], options);
                }
                if (message.lastValidTime != null && message.hasOwnProperty("lastValidTime"))
                    object.lastValidTime = message.lastValidTime;
                if (message.lastValidTimestamp != null && message.hasOwnProperty("lastValidTimestamp"))
                    object.lastValidTimestamp = options.json && !isFinite(message.lastValidTimestamp) ? String(message.lastValidTimestamp) : message.lastValidTimestamp;
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.CapFlowRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.CapFlowRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.CapFlowRes.S2C";
            };

            return S2C;
        })();

        return CapFlowRes;
    })();

    base.CapDistReq = (function() {

        /**
         * Properties of a CapDistReq.
         * @memberof base
         * @interface ICapDistReq
         * @property {base.CapDistReq.IC2S} c2s CapDistReq c2s
         */

        /**
         * Constructs a new CapDistReq.
         * @memberof base
         * @classdesc 获取资金分布请求
         * @implements ICapDistReq
         * @constructor
         * @param {base.ICapDistReq=} [properties] Properties to set
         */
        function CapDistReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapDistReq c2s.
         * @member {base.CapDistReq.IC2S} c2s
         * @memberof base.CapDistReq
         * @instance
         */
        CapDistReq.prototype.c2s = null;

        /**
         * Creates a new CapDistReq instance using the specified properties.
         * @function create
         * @memberof base.CapDistReq
         * @static
         * @param {base.ICapDistReq=} [properties] Properties to set
         * @returns {base.CapDistReq} CapDistReq instance
         */
        CapDistReq.create = function create(properties) {
            return new CapDistReq(properties);
        };

        /**
         * Encodes the specified CapDistReq message. Does not implicitly {@link base.CapDistReq.verify|verify} messages.
         * @function encode
         * @memberof base.CapDistReq
         * @static
         * @param {base.ICapDistReq} message CapDistReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapDistReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.CapDistReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CapDistReq message, length delimited. Does not implicitly {@link base.CapDistReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.CapDistReq
         * @static
         * @param {base.ICapDistReq} message CapDistReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapDistReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapDistReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.CapDistReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.CapDistReq} CapDistReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapDistReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapDistReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.CapDistReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a CapDistReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.CapDistReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.CapDistReq} CapDistReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapDistReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapDistReq message.
         * @function verify
         * @memberof base.CapDistReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapDistReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.CapDistReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a CapDistReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.CapDistReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.CapDistReq} CapDistReq
         */
        CapDistReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.CapDistReq)
                return object;
            let message = new $root.base.CapDistReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.CapDistReq.c2s: object expected");
                message.c2s = $root.base.CapDistReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a CapDistReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.CapDistReq
         * @static
         * @param {base.CapDistReq} message CapDistReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CapDistReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.CapDistReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this CapDistReq to JSON.
         * @function toJSON
         * @memberof base.CapDistReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CapDistReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CapDistReq
         * @function getTypeUrl
         * @memberof base.CapDistReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CapDistReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.CapDistReq";
        };

        CapDistReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.CapDistReq
             * @interface IC2S
             * @property {common.ISecurity} security C2S security
             */

            /**
             * Constructs a new C2S.
             * @memberof base.CapDistReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.CapDistReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S security.
             * @member {common.ISecurity} security
             * @memberof base.CapDistReq.C2S
             * @instance
             */
            C2S.prototype.security = null;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {base.CapDistReq.IC2S=} [properties] Properties to set
             * @returns {base.CapDistReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.CapDistReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {base.CapDistReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.CapDistReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {base.CapDistReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.CapDistReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapDistReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.security = $root.common.Security.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("security"))
                    throw $util.ProtocolError("missing required 'security'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.CapDistReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.Security.verify(message.security);
                    if (error)
                        return "security." + error;
                }
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.CapDistReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.CapDistReq.C2S)
                    return object;
                let message = new $root.base.CapDistReq.C2S();
                if (object.security != null) {
                    if (typeof object.security !== "object")
                        throw TypeError(".base.CapDistReq.C2S.security: object expected");
                    message.security = $root.common.Security.fromObject(object.security);
                }
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {base.CapDistReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.security = null;
                if (message.security != null && message.hasOwnProperty("security"))
                    object.security = $root.common.Security.toObject(message.security, options);
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.CapDistReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.CapDistReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.CapDistReq.C2S";
            };

            return C2S;
        })();

        return CapDistReq;
    })();

    base.CapDistRes = (function() {

        /**
         * Properties of a CapDistRes.
         * @memberof base
         * @interface ICapDistRes
         * @property {number} retType CapDistRes retType
         * @property {string|null} [retMsg] CapDistRes retMsg
         * @property {number|null} [errCode] CapDistRes errCode
         * @property {base.CapDistRes.IS2C|null} [s2c] CapDistRes s2c
         */

        /**
         * Constructs a new CapDistRes.
         * @memberof base
         * @classdesc 获取资金分布响应
         * @implements ICapDistRes
         * @constructor
         * @param {base.ICapDistRes=} [properties] Properties to set
         */
        function CapDistRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapDistRes retType.
         * @member {number} retType
         * @memberof base.CapDistRes
         * @instance
         */
        CapDistRes.prototype.retType = -400;

        /**
         * CapDistRes retMsg.
         * @member {string} retMsg
         * @memberof base.CapDistRes
         * @instance
         */
        CapDistRes.prototype.retMsg = "";

        /**
         * CapDistRes errCode.
         * @member {number} errCode
         * @memberof base.CapDistRes
         * @instance
         */
        CapDistRes.prototype.errCode = 0;

        /**
         * CapDistRes s2c.
         * @member {base.CapDistRes.IS2C|null|undefined} s2c
         * @memberof base.CapDistRes
         * @instance
         */
        CapDistRes.prototype.s2c = null;

        /**
         * Creates a new CapDistRes instance using the specified properties.
         * @function create
         * @memberof base.CapDistRes
         * @static
         * @param {base.ICapDistRes=} [properties] Properties to set
         * @returns {base.CapDistRes} CapDistRes instance
         */
        CapDistRes.create = function create(properties) {
            return new CapDistRes(properties);
        };

        /**
         * Encodes the specified CapDistRes message. Does not implicitly {@link base.CapDistRes.verify|verify} messages.
         * @function encode
         * @memberof base.CapDistRes
         * @static
         * @param {base.ICapDistRes} message CapDistRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapDistRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.CapDistRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CapDistRes message, length delimited. Does not implicitly {@link base.CapDistRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.CapDistRes
         * @static
         * @param {base.ICapDistRes} message CapDistRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapDistRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapDistRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.CapDistRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.CapDistRes} CapDistRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapDistRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapDistRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.CapDistRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a CapDistRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.CapDistRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.CapDistRes} CapDistRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapDistRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapDistRes message.
         * @function verify
         * @memberof base.CapDistRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapDistRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.CapDistRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a CapDistRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.CapDistRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.CapDistRes} CapDistRes
         */
        CapDistRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.CapDistRes)
                return object;
            let message = new $root.base.CapDistRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.CapDistRes.s2c: object expected");
                message.s2c = $root.base.CapDistRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a CapDistRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.CapDistRes
         * @static
         * @param {base.CapDistRes} message CapDistRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CapDistRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.CapDistRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this CapDistRes to JSON.
         * @function toJSON
         * @memberof base.CapDistRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CapDistRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CapDistRes
         * @function getTypeUrl
         * @memberof base.CapDistRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CapDistRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.CapDistRes";
        };

        CapDistRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.CapDistRes
             * @interface IS2C
             * @property {number|null} [capitalInSuper] S2C capitalInSuper
             * @property {number} capitalInBig S2C capitalInBig
             * @property {number} capitalInMid S2C capitalInMid
             * @property {number} capitalInSmall S2C capitalInSmall
             * @property {number|null} [capitalOutSuper] S2C capitalOutSuper
             * @property {number} capitalOutBig S2C capitalOutBig
             * @property {number} capitalOutMid S2C capitalOutMid
             * @property {number} capitalOutSmall S2C capitalOutSmall
             * @property {string|null} [updateTime] S2C updateTime
             * @property {number|null} [updateTimestamp] S2C updateTimestamp
             */

            /**
             * Constructs a new S2C.
             * @memberof base.CapDistRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.CapDistRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C capitalInSuper.
             * @member {number} capitalInSuper
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalInSuper = 0;

            /**
             * S2C capitalInBig.
             * @member {number} capitalInBig
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalInBig = 0;

            /**
             * S2C capitalInMid.
             * @member {number} capitalInMid
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalInMid = 0;

            /**
             * S2C capitalInSmall.
             * @member {number} capitalInSmall
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalInSmall = 0;

            /**
             * S2C capitalOutSuper.
             * @member {number} capitalOutSuper
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalOutSuper = 0;

            /**
             * S2C capitalOutBig.
             * @member {number} capitalOutBig
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalOutBig = 0;

            /**
             * S2C capitalOutMid.
             * @member {number} capitalOutMid
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalOutMid = 0;

            /**
             * S2C capitalOutSmall.
             * @member {number} capitalOutSmall
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.capitalOutSmall = 0;

            /**
             * S2C updateTime.
             * @member {string} updateTime
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.updateTime = "";

            /**
             * S2C updateTimestamp.
             * @member {number} updateTimestamp
             * @memberof base.CapDistRes.S2C
             * @instance
             */
            S2C.prototype.updateTimestamp = 0;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {base.CapDistRes.IS2C=} [properties] Properties to set
             * @returns {base.CapDistRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.CapDistRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {base.CapDistRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.capitalInBig);
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.capitalInMid);
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.capitalInSmall);
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.capitalOutBig);
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.capitalOutMid);
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.capitalOutSmall);
                if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.updateTime);
                if (message.updateTimestamp != null && Object.hasOwnProperty.call(message, "updateTimestamp"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.updateTimestamp);
                if (message.capitalInSuper != null && Object.hasOwnProperty.call(message, "capitalInSuper"))
                    writer.uint32(/* id 9, wireType 1 =*/73).double(message.capitalInSuper);
                if (message.capitalOutSuper != null && Object.hasOwnProperty.call(message, "capitalOutSuper"))
                    writer.uint32(/* id 10, wireType 1 =*/81).double(message.capitalOutSuper);
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.CapDistRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {base.CapDistRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.CapDistRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.CapDistRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 9: {
                            message.capitalInSuper = reader.double();
                            break;
                        }
                    case 1: {
                            message.capitalInBig = reader.double();
                            break;
                        }
                    case 2: {
                            message.capitalInMid = reader.double();
                            break;
                        }
                    case 3: {
                            message.capitalInSmall = reader.double();
                            break;
                        }
                    case 10: {
                            message.capitalOutSuper = reader.double();
                            break;
                        }
                    case 4: {
                            message.capitalOutBig = reader.double();
                            break;
                        }
                    case 5: {
                            message.capitalOutMid = reader.double();
                            break;
                        }
                    case 6: {
                            message.capitalOutSmall = reader.double();
                            break;
                        }
                    case 7: {
                            message.updateTime = reader.string();
                            break;
                        }
                    case 8: {
                            message.updateTimestamp = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("capitalInBig"))
                    throw $util.ProtocolError("missing required 'capitalInBig'", { instance: message });
                if (!message.hasOwnProperty("capitalInMid"))
                    throw $util.ProtocolError("missing required 'capitalInMid'", { instance: message });
                if (!message.hasOwnProperty("capitalInSmall"))
                    throw $util.ProtocolError("missing required 'capitalInSmall'", { instance: message });
                if (!message.hasOwnProperty("capitalOutBig"))
                    throw $util.ProtocolError("missing required 'capitalOutBig'", { instance: message });
                if (!message.hasOwnProperty("capitalOutMid"))
                    throw $util.ProtocolError("missing required 'capitalOutMid'", { instance: message });
                if (!message.hasOwnProperty("capitalOutSmall"))
                    throw $util.ProtocolError("missing required 'capitalOutSmall'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.CapDistRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.capitalInSuper != null && message.hasOwnProperty("capitalInSuper"))
                    if (typeof message.capitalInSuper !== "number")
                        return "capitalInSuper: number expected";
                if (typeof message.capitalInBig !== "number")
                    return "capitalInBig: number expected";
                if (typeof message.capitalInMid !== "number")
                    return "capitalInMid: number expected";
                if (typeof message.capitalInSmall !== "number")
                    return "capitalInSmall: number expected";
                if (message.capitalOutSuper != null && message.hasOwnProperty("capitalOutSuper"))
                    if (typeof message.capitalOutSuper !== "number")
                        return "capitalOutSuper: number expected";
                if (typeof message.capitalOutBig !== "number")
                    return "capitalOutBig: number expected";
                if (typeof message.capitalOutMid !== "number")
                    return "capitalOutMid: number expected";
                if (typeof message.capitalOutSmall !== "number")
                    return "capitalOutSmall: number expected";
                if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                    if (!$util.isString(message.updateTime))
                        return "updateTime: string expected";
                if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                    if (typeof message.updateTimestamp !== "number")
                        return "updateTimestamp: number expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.CapDistRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.CapDistRes.S2C)
                    return object;
                let message = new $root.base.CapDistRes.S2C();
                if (object.capitalInSuper != null)
                    message.capitalInSuper = Number(object.capitalInSuper);
                if (object.capitalInBig != null)
                    message.capitalInBig = Number(object.capitalInBig);
                if (object.capitalInMid != null)
                    message.capitalInMid = Number(object.capitalInMid);
                if (object.capitalInSmall != null)
                    message.capitalInSmall = Number(object.capitalInSmall);
                if (object.capitalOutSuper != null)
                    message.capitalOutSuper = Number(object.capitalOutSuper);
                if (object.capitalOutBig != null)
                    message.capitalOutBig = Number(object.capitalOutBig);
                if (object.capitalOutMid != null)
                    message.capitalOutMid = Number(object.capitalOutMid);
                if (object.capitalOutSmall != null)
                    message.capitalOutSmall = Number(object.capitalOutSmall);
                if (object.updateTime != null)
                    message.updateTime = String(object.updateTime);
                if (object.updateTimestamp != null)
                    message.updateTimestamp = Number(object.updateTimestamp);
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {base.CapDistRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.capitalInBig = 0;
                    object.capitalInMid = 0;
                    object.capitalInSmall = 0;
                    object.capitalOutBig = 0;
                    object.capitalOutMid = 0;
                    object.capitalOutSmall = 0;
                    object.updateTime = "";
                    object.updateTimestamp = 0;
                    object.capitalInSuper = 0;
                    object.capitalOutSuper = 0;
                }
                if (message.capitalInBig != null && message.hasOwnProperty("capitalInBig"))
                    object.capitalInBig = options.json && !isFinite(message.capitalInBig) ? String(message.capitalInBig) : message.capitalInBig;
                if (message.capitalInMid != null && message.hasOwnProperty("capitalInMid"))
                    object.capitalInMid = options.json && !isFinite(message.capitalInMid) ? String(message.capitalInMid) : message.capitalInMid;
                if (message.capitalInSmall != null && message.hasOwnProperty("capitalInSmall"))
                    object.capitalInSmall = options.json && !isFinite(message.capitalInSmall) ? String(message.capitalInSmall) : message.capitalInSmall;
                if (message.capitalOutBig != null && message.hasOwnProperty("capitalOutBig"))
                    object.capitalOutBig = options.json && !isFinite(message.capitalOutBig) ? String(message.capitalOutBig) : message.capitalOutBig;
                if (message.capitalOutMid != null && message.hasOwnProperty("capitalOutMid"))
                    object.capitalOutMid = options.json && !isFinite(message.capitalOutMid) ? String(message.capitalOutMid) : message.capitalOutMid;
                if (message.capitalOutSmall != null && message.hasOwnProperty("capitalOutSmall"))
                    object.capitalOutSmall = options.json && !isFinite(message.capitalOutSmall) ? String(message.capitalOutSmall) : message.capitalOutSmall;
                if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                    object.updateTime = message.updateTime;
                if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                    object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
                if (message.capitalInSuper != null && message.hasOwnProperty("capitalInSuper"))
                    object.capitalInSuper = options.json && !isFinite(message.capitalInSuper) ? String(message.capitalInSuper) : message.capitalInSuper;
                if (message.capitalOutSuper != null && message.hasOwnProperty("capitalOutSuper"))
                    object.capitalOutSuper = options.json && !isFinite(message.capitalOutSuper) ? String(message.capitalOutSuper) : message.capitalOutSuper;
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.CapDistRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.CapDistRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.CapDistRes.S2C";
            };

            return S2C;
        })();

        return CapDistRes;
    })();

    base.PositionReq = (function() {

        /**
         * Properties of a PositionReq.
         * @memberof base
         * @interface IPositionReq
         * @property {base.PositionReq.IC2S} c2s PositionReq c2s
         */

        /**
         * Constructs a new PositionReq.
         * @memberof base
         * @classdesc 获取账户持仓请求
         * @implements IPositionReq
         * @constructor
         * @param {base.IPositionReq=} [properties] Properties to set
         */
        function PositionReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PositionReq c2s.
         * @member {base.PositionReq.IC2S} c2s
         * @memberof base.PositionReq
         * @instance
         */
        PositionReq.prototype.c2s = null;

        /**
         * Creates a new PositionReq instance using the specified properties.
         * @function create
         * @memberof base.PositionReq
         * @static
         * @param {base.IPositionReq=} [properties] Properties to set
         * @returns {base.PositionReq} PositionReq instance
         */
        PositionReq.create = function create(properties) {
            return new PositionReq(properties);
        };

        /**
         * Encodes the specified PositionReq message. Does not implicitly {@link base.PositionReq.verify|verify} messages.
         * @function encode
         * @memberof base.PositionReq
         * @static
         * @param {base.IPositionReq} message PositionReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.PositionReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PositionReq message, length delimited. Does not implicitly {@link base.PositionReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.PositionReq
         * @static
         * @param {base.IPositionReq} message PositionReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PositionReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.PositionReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.PositionReq} PositionReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.PositionReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.PositionReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a PositionReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.PositionReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.PositionReq} PositionReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PositionReq message.
         * @function verify
         * @memberof base.PositionReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.PositionReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a PositionReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.PositionReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.PositionReq} PositionReq
         */
        PositionReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.PositionReq)
                return object;
            let message = new $root.base.PositionReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.PositionReq.c2s: object expected");
                message.c2s = $root.base.PositionReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a PositionReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.PositionReq
         * @static
         * @param {base.PositionReq} message PositionReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.PositionReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this PositionReq to JSON.
         * @function toJSON
         * @memberof base.PositionReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PositionReq
         * @function getTypeUrl
         * @memberof base.PositionReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PositionReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.PositionReq";
        };

        PositionReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.PositionReq
             * @interface IC2S
             * @property {common.ITrdHeader} header C2S header
             * @property {common.ITrdFilterConditions|null} [filterConditions] C2S filterConditions
             * @property {number|null} [filterPLRatioMin] 过滤盈亏百分比下限，高于此比例的会返回，比如传10.0，返回盈亏比例大于10%的持仓
             * @property {number|null} [filterPLRatioMax] 过滤盈亏百分比上限，低于此比例的会返回，比如传20.0，返回盈亏比例小于20%的持仓
             * @property {boolean|null} [refreshCache] 立即刷新 OpenD 缓存的此数据，默认不填。true 向服务器获取最新数据更新缓存并返回；flase 或没填则返回 OpenD 缓存的数据，不会向服务器请求。
             * 
             * 正常情况下，服务器有更新就会立即推送到 OpenD，OpenD 缓存着数据，API 请求过来，返回同步的缓存数据，一般不需要指定刷新缓存，保证快速返回且减少对服务器的压力。如果遇到丢包等情况，可能出现缓存数据与服务器不一致，用户如果发现数据更新有异样，可指定刷新缓存，解决数据同步的问题。
             */

            /**
             * Constructs a new C2S.
             * @memberof base.PositionReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.PositionReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S header.
             * @member {common.ITrdHeader} header
             * @memberof base.PositionReq.C2S
             * @instance
             */
            C2S.prototype.header = null;

            /**
             * C2S filterConditions.
             * @member {common.ITrdFilterConditions|null|undefined} filterConditions
             * @memberof base.PositionReq.C2S
             * @instance
             */
            C2S.prototype.filterConditions = null;

            /**
             * 过滤盈亏百分比下限，高于此比例的会返回，比如传10.0，返回盈亏比例大于10%的持仓
             * @member {number} filterPLRatioMin
             * @memberof base.PositionReq.C2S
             * @instance
             */
            C2S.prototype.filterPLRatioMin = 0;

            /**
             * 过滤盈亏百分比上限，低于此比例的会返回，比如传20.0，返回盈亏比例小于20%的持仓
             * @member {number} filterPLRatioMax
             * @memberof base.PositionReq.C2S
             * @instance
             */
            C2S.prototype.filterPLRatioMax = 0;

            /**
             * 立即刷新 OpenD 缓存的此数据，默认不填。true 向服务器获取最新数据更新缓存并返回；flase 或没填则返回 OpenD 缓存的数据，不会向服务器请求。
             * 
             * 正常情况下，服务器有更新就会立即推送到 OpenD，OpenD 缓存着数据，API 请求过来，返回同步的缓存数据，一般不需要指定刷新缓存，保证快速返回且减少对服务器的压力。如果遇到丢包等情况，可能出现缓存数据与服务器不一致，用户如果发现数据更新有异样，可指定刷新缓存，解决数据同步的问题。
             * @member {boolean} refreshCache
             * @memberof base.PositionReq.C2S
             * @instance
             */
            C2S.prototype.refreshCache = false;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.PositionReq.C2S
             * @static
             * @param {base.PositionReq.IC2S=} [properties] Properties to set
             * @returns {base.PositionReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.PositionReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.PositionReq.C2S
             * @static
             * @param {base.PositionReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.filterConditions != null && Object.hasOwnProperty.call(message, "filterConditions"))
                    $root.common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.filterPLRatioMin != null && Object.hasOwnProperty.call(message, "filterPLRatioMin"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.filterPLRatioMin);
                if (message.filterPLRatioMax != null && Object.hasOwnProperty.call(message, "filterPLRatioMax"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.filterPLRatioMax);
                if (message.refreshCache != null && Object.hasOwnProperty.call(message, "refreshCache"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.refreshCache);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.PositionReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.PositionReq.C2S
             * @static
             * @param {base.PositionReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.PositionReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.PositionReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.PositionReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.filterConditions = $root.common.TrdFilterConditions.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.filterPLRatioMin = reader.double();
                            break;
                        }
                    case 4: {
                            message.filterPLRatioMax = reader.double();
                            break;
                        }
                    case 5: {
                            message.refreshCache = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.PositionReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.PositionReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.PositionReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.filterConditions != null && message.hasOwnProperty("filterConditions")) {
                    let error = $root.common.TrdFilterConditions.verify(message.filterConditions);
                    if (error)
                        return "filterConditions." + error;
                }
                if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                    if (typeof message.filterPLRatioMin !== "number")
                        return "filterPLRatioMin: number expected";
                if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                    if (typeof message.filterPLRatioMax !== "number")
                        return "filterPLRatioMax: number expected";
                if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                    if (typeof message.refreshCache !== "boolean")
                        return "refreshCache: boolean expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.PositionReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.PositionReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.PositionReq.C2S)
                    return object;
                let message = new $root.base.PositionReq.C2S();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".base.PositionReq.C2S.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.filterConditions != null) {
                    if (typeof object.filterConditions !== "object")
                        throw TypeError(".base.PositionReq.C2S.filterConditions: object expected");
                    message.filterConditions = $root.common.TrdFilterConditions.fromObject(object.filterConditions);
                }
                if (object.filterPLRatioMin != null)
                    message.filterPLRatioMin = Number(object.filterPLRatioMin);
                if (object.filterPLRatioMax != null)
                    message.filterPLRatioMax = Number(object.filterPLRatioMax);
                if (object.refreshCache != null)
                    message.refreshCache = Boolean(object.refreshCache);
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.PositionReq.C2S
             * @static
             * @param {base.PositionReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.header = null;
                    object.filterConditions = null;
                    object.filterPLRatioMin = 0;
                    object.filterPLRatioMax = 0;
                    object.refreshCache = false;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                    object.filterConditions = $root.common.TrdFilterConditions.toObject(message.filterConditions, options);
                if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                    object.filterPLRatioMin = options.json && !isFinite(message.filterPLRatioMin) ? String(message.filterPLRatioMin) : message.filterPLRatioMin;
                if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                    object.filterPLRatioMax = options.json && !isFinite(message.filterPLRatioMax) ? String(message.filterPLRatioMax) : message.filterPLRatioMax;
                if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                    object.refreshCache = message.refreshCache;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.PositionReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.PositionReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.PositionReq.C2S";
            };

            return C2S;
        })();

        return PositionReq;
    })();

    base.PositionRes = (function() {

        /**
         * Properties of a PositionRes.
         * @memberof base
         * @interface IPositionRes
         * @property {number} retType PositionRes retType
         * @property {string|null} [retMsg] PositionRes retMsg
         * @property {number|null} [errCode] PositionRes errCode
         * @property {base.PositionRes.IS2C|null} [s2c] PositionRes s2c
         */

        /**
         * Constructs a new PositionRes.
         * @memberof base
         * @classdesc 获取账户持仓响应
         * @implements IPositionRes
         * @constructor
         * @param {base.IPositionRes=} [properties] Properties to set
         */
        function PositionRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PositionRes retType.
         * @member {number} retType
         * @memberof base.PositionRes
         * @instance
         */
        PositionRes.prototype.retType = -400;

        /**
         * PositionRes retMsg.
         * @member {string} retMsg
         * @memberof base.PositionRes
         * @instance
         */
        PositionRes.prototype.retMsg = "";

        /**
         * PositionRes errCode.
         * @member {number} errCode
         * @memberof base.PositionRes
         * @instance
         */
        PositionRes.prototype.errCode = 0;

        /**
         * PositionRes s2c.
         * @member {base.PositionRes.IS2C|null|undefined} s2c
         * @memberof base.PositionRes
         * @instance
         */
        PositionRes.prototype.s2c = null;

        /**
         * Creates a new PositionRes instance using the specified properties.
         * @function create
         * @memberof base.PositionRes
         * @static
         * @param {base.IPositionRes=} [properties] Properties to set
         * @returns {base.PositionRes} PositionRes instance
         */
        PositionRes.create = function create(properties) {
            return new PositionRes(properties);
        };

        /**
         * Encodes the specified PositionRes message. Does not implicitly {@link base.PositionRes.verify|verify} messages.
         * @function encode
         * @memberof base.PositionRes
         * @static
         * @param {base.IPositionRes} message PositionRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.PositionRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PositionRes message, length delimited. Does not implicitly {@link base.PositionRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.PositionRes
         * @static
         * @param {base.IPositionRes} message PositionRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PositionRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.PositionRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.PositionRes} PositionRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.PositionRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.PositionRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a PositionRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.PositionRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.PositionRes} PositionRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PositionRes message.
         * @function verify
         * @memberof base.PositionRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.PositionRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a PositionRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.PositionRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.PositionRes} PositionRes
         */
        PositionRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.PositionRes)
                return object;
            let message = new $root.base.PositionRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.PositionRes.s2c: object expected");
                message.s2c = $root.base.PositionRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a PositionRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.PositionRes
         * @static
         * @param {base.PositionRes} message PositionRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.PositionRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this PositionRes to JSON.
         * @function toJSON
         * @memberof base.PositionRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PositionRes
         * @function getTypeUrl
         * @memberof base.PositionRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PositionRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.PositionRes";
        };

        PositionRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.PositionRes
             * @interface IS2C
             * @property {common.ITrdHeader} header S2C header
             * @property {Array.<common.IPosition>|null} [positionList] S2C positionList
             */

            /**
             * Constructs a new S2C.
             * @memberof base.PositionRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.PositionRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.positionList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C header.
             * @member {common.ITrdHeader} header
             * @memberof base.PositionRes.S2C
             * @instance
             */
            S2C.prototype.header = null;

            /**
             * S2C positionList.
             * @member {Array.<common.IPosition>} positionList
             * @memberof base.PositionRes.S2C
             * @instance
             */
            S2C.prototype.positionList = $util.emptyArray;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.PositionRes.S2C
             * @static
             * @param {base.PositionRes.IS2C=} [properties] Properties to set
             * @returns {base.PositionRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.PositionRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.PositionRes.S2C
             * @static
             * @param {base.PositionRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.positionList != null && message.positionList.length)
                    for (let i = 0; i < message.positionList.length; ++i)
                        $root.common.Position.encode(message.positionList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.PositionRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.PositionRes.S2C
             * @static
             * @param {base.PositionRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.PositionRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.PositionRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.PositionRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.positionList && message.positionList.length))
                                message.positionList = [];
                            message.positionList.push($root.common.Position.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.PositionRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.PositionRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.PositionRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.positionList != null && message.hasOwnProperty("positionList")) {
                    if (!Array.isArray(message.positionList))
                        return "positionList: array expected";
                    for (let i = 0; i < message.positionList.length; ++i) {
                        let error = $root.common.Position.verify(message.positionList[i]);
                        if (error)
                            return "positionList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.PositionRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.PositionRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.PositionRes.S2C)
                    return object;
                let message = new $root.base.PositionRes.S2C();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".base.PositionRes.S2C.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.positionList) {
                    if (!Array.isArray(object.positionList))
                        throw TypeError(".base.PositionRes.S2C.positionList: array expected");
                    message.positionList = [];
                    for (let i = 0; i < object.positionList.length; ++i) {
                        if (typeof object.positionList[i] !== "object")
                            throw TypeError(".base.PositionRes.S2C.positionList: object expected");
                        message.positionList[i] = $root.common.Position.fromObject(object.positionList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.PositionRes.S2C
             * @static
             * @param {base.PositionRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.positionList = [];
                if (options.defaults)
                    object.header = null;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.positionList && message.positionList.length) {
                    object.positionList = [];
                    for (let j = 0; j < message.positionList.length; ++j)
                        object.positionList[j] = $root.common.Position.toObject(message.positionList[j], options);
                }
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.PositionRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.PositionRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.PositionRes.S2C";
            };

            return S2C;
        })();

        return PositionRes;
    })();

    base.SellableReq = (function() {

        /**
         * Properties of a SellableReq.
         * @memberof base
         * @interface ISellableReq
         * @property {base.SellableReq.IC2S} c2s SellableReq c2s
         */

        /**
         * Constructs a new SellableReq.
         * @memberof base
         * @classdesc 获取可卖数量请求
         * @implements ISellableReq
         * @constructor
         * @param {base.ISellableReq=} [properties] Properties to set
         */
        function SellableReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SellableReq c2s.
         * @member {base.SellableReq.IC2S} c2s
         * @memberof base.SellableReq
         * @instance
         */
        SellableReq.prototype.c2s = null;

        /**
         * Creates a new SellableReq instance using the specified properties.
         * @function create
         * @memberof base.SellableReq
         * @static
         * @param {base.ISellableReq=} [properties] Properties to set
         * @returns {base.SellableReq} SellableReq instance
         */
        SellableReq.create = function create(properties) {
            return new SellableReq(properties);
        };

        /**
         * Encodes the specified SellableReq message. Does not implicitly {@link base.SellableReq.verify|verify} messages.
         * @function encode
         * @memberof base.SellableReq
         * @static
         * @param {base.ISellableReq} message SellableReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellableReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.base.SellableReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SellableReq message, length delimited. Does not implicitly {@link base.SellableReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.SellableReq
         * @static
         * @param {base.ISellableReq} message SellableReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellableReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SellableReq message from the specified reader or buffer.
         * @function decode
         * @memberof base.SellableReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.SellableReq} SellableReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellableReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.SellableReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.base.SellableReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a SellableReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.SellableReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.SellableReq} SellableReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellableReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SellableReq message.
         * @function verify
         * @memberof base.SellableReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SellableReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.base.SellableReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a SellableReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.SellableReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.SellableReq} SellableReq
         */
        SellableReq.fromObject = function fromObject(object) {
            if (object instanceof $root.base.SellableReq)
                return object;
            let message = new $root.base.SellableReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".base.SellableReq.c2s: object expected");
                message.c2s = $root.base.SellableReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a SellableReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.SellableReq
         * @static
         * @param {base.SellableReq} message SellableReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SellableReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.base.SellableReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this SellableReq to JSON.
         * @function toJSON
         * @memberof base.SellableReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SellableReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SellableReq
         * @function getTypeUrl
         * @memberof base.SellableReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SellableReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.SellableReq";
        };

        SellableReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof base.SellableReq
             * @interface IC2S
             * @property {common.ITrdHeader} header C2S header
             * @property {common.OrderType} orderType C2S orderType
             * @property {string} code C2S code
             * @property {number} price C2S price
             * @property {number|Long|null} [orderID] C2S orderID
             * @property {boolean|null} [adjustPrice] C2S adjustPrice
             * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
             * @property {common.TrdSecMarket|null} [secMarket] C2S secMarket
             * @property {string|null} [orderIDEx] C2S orderIDEx
             */

            /**
             * Constructs a new C2S.
             * @memberof base.SellableReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {base.SellableReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S header.
             * @member {common.ITrdHeader} header
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.header = null;

            /**
             * C2S orderType.
             * @member {common.OrderType} orderType
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.orderType = 0;

            /**
             * C2S code.
             * @member {string} code
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.code = "";

            /**
             * C2S price.
             * @member {number} price
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.price = 0;

            /**
             * C2S orderID.
             * @member {number|Long} orderID
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * C2S adjustPrice.
             * @member {boolean} adjustPrice
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.adjustPrice = false;

            /**
             * C2S adjustSideAndLimit.
             * @member {number} adjustSideAndLimit
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.adjustSideAndLimit = 0;

            /**
             * C2S secMarket.
             * @member {common.TrdSecMarket} secMarket
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.secMarket = 0;

            /**
             * C2S orderIDEx.
             * @member {string} orderIDEx
             * @memberof base.SellableReq.C2S
             * @instance
             */
            C2S.prototype.orderIDEx = "";

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof base.SellableReq.C2S
             * @static
             * @param {base.SellableReq.IC2S=} [properties] Properties to set
             * @returns {base.SellableReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link base.SellableReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof base.SellableReq.C2S
             * @static
             * @param {base.SellableReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orderType);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.price);
                if (message.orderID != null && Object.hasOwnProperty.call(message, "orderID"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.orderID);
                if (message.adjustPrice != null && Object.hasOwnProperty.call(message, "adjustPrice"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.adjustPrice);
                if (message.adjustSideAndLimit != null && Object.hasOwnProperty.call(message, "adjustSideAndLimit"))
                    writer.uint32(/* id 7, wireType 1 =*/57).double(message.adjustSideAndLimit);
                if (message.secMarket != null && Object.hasOwnProperty.call(message, "secMarket"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.secMarket);
                if (message.orderIDEx != null && Object.hasOwnProperty.call(message, "orderIDEx"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.orderIDEx);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link base.SellableReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.SellableReq.C2S
             * @static
             * @param {base.SellableReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof base.SellableReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.SellableReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.SellableReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.orderType = reader.int32();
                            break;
                        }
                    case 3: {
                            message.code = reader.string();
                            break;
                        }
                    case 4: {
                            message.price = reader.double();
                            break;
                        }
                    case 5: {
                            message.orderID = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.adjustPrice = reader.bool();
                            break;
                        }
                    case 7: {
                            message.adjustSideAndLimit = reader.double();
                            break;
                        }
                    case 8: {
                            message.secMarket = reader.int32();
                            break;
                        }
                    case 9: {
                            message.orderIDEx = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                if (!message.hasOwnProperty("orderType"))
                    throw $util.ProtocolError("missing required 'orderType'", { instance: message });
                if (!message.hasOwnProperty("code"))
                    throw $util.ProtocolError("missing required 'code'", { instance: message });
                if (!message.hasOwnProperty("price"))
                    throw $util.ProtocolError("missing required 'price'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.SellableReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.SellableReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof base.SellableReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                switch (message.orderType) {
                default:
                    return "orderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                    break;
                }
                if (!$util.isString(message.code))
                    return "code: string expected";
                if (typeof message.price !== "number")
                    return "price: number expected";
                if (message.orderID != null && message.hasOwnProperty("orderID"))
                    if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                        return "orderID: integer|Long expected";
                if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                    if (typeof message.adjustPrice !== "boolean")
                        return "adjustPrice: boolean expected";
                if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                    if (typeof message.adjustSideAndLimit !== "number")
                        return "adjustSideAndLimit: number expected";
                if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                    switch (message.secMarket) {
                    default:
                        return "secMarket: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 31:
                    case 32:
                    case 41:
                    case 51:
                    case 61:
                    case 71:
                    case 81:
                    case 91:
                        break;
                    }
                if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                    if (!$util.isString(message.orderIDEx))
                        return "orderIDEx: string expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.SellableReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.SellableReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.base.SellableReq.C2S)
                    return object;
                let message = new $root.base.SellableReq.C2S();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".base.SellableReq.C2S.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                switch (object.orderType) {
                default:
                    if (typeof object.orderType === "number") {
                        message.orderType = object.orderType;
                        break;
                    }
                    break;
                case "OrderType_Unknown":
                case 0:
                    message.orderType = 0;
                    break;
                case "OrderType_Normal":
                case 1:
                    message.orderType = 1;
                    break;
                case "OrderType_Market":
                case 2:
                    message.orderType = 2;
                    break;
                case "OrderType_AbsoluteLimit":
                case 5:
                    message.orderType = 5;
                    break;
                case "OrderType_Auction":
                case 6:
                    message.orderType = 6;
                    break;
                case "OrderType_AuctionLimit":
                case 7:
                    message.orderType = 7;
                    break;
                case "OrderType_SpecialLimit":
                case 8:
                    message.orderType = 8;
                    break;
                case "OrderType_SpecialLimit_All":
                case 9:
                    message.orderType = 9;
                    break;
                case "OrderType_Stop":
                case 10:
                    message.orderType = 10;
                    break;
                case "OrderType_StopLimit":
                case 11:
                    message.orderType = 11;
                    break;
                case "OrderType_MarketifTouched":
                case 12:
                    message.orderType = 12;
                    break;
                case "OrderType_LimitifTouched":
                case 13:
                    message.orderType = 13;
                    break;
                case "OrderType_TrailingStop":
                case 14:
                    message.orderType = 14;
                    break;
                case "OrderType_TrailingStopLimit":
                case 15:
                    message.orderType = 15;
                    break;
                case "OrderType_TWAP":
                case 16:
                    message.orderType = 16;
                    break;
                case "OrderType_TWAP_LIMIT":
                case 17:
                    message.orderType = 17;
                    break;
                case "OrderType_VWAP":
                case 18:
                    message.orderType = 18;
                    break;
                case "OrderType_VWAP_LIMIT":
                case 19:
                    message.orderType = 19;
                    break;
                }
                if (object.code != null)
                    message.code = String(object.code);
                if (object.price != null)
                    message.price = Number(object.price);
                if (object.orderID != null)
                    if ($util.Long)
                        (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                    else if (typeof object.orderID === "string")
                        message.orderID = parseInt(object.orderID, 10);
                    else if (typeof object.orderID === "number")
                        message.orderID = object.orderID;
                    else if (typeof object.orderID === "object")
                        message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
                if (object.adjustPrice != null)
                    message.adjustPrice = Boolean(object.adjustPrice);
                if (object.adjustSideAndLimit != null)
                    message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
                switch (object.secMarket) {
                default:
                    if (typeof object.secMarket === "number") {
                        message.secMarket = object.secMarket;
                        break;
                    }
                    break;
                case "TrdSecMarket_Unknown":
                case 0:
                    message.secMarket = 0;
                    break;
                case "TrdSecMarket_HK":
                case 1:
                    message.secMarket = 1;
                    break;
                case "TrdSecMarket_US":
                case 2:
                    message.secMarket = 2;
                    break;
                case "TrdSecMarket_CN_SH":
                case 31:
                    message.secMarket = 31;
                    break;
                case "TrdSecMarket_CN_SZ":
                case 32:
                    message.secMarket = 32;
                    break;
                case "TrdSecMarket_SG":
                case 41:
                    message.secMarket = 41;
                    break;
                case "TrdSecMarket_JP":
                case 51:
                    message.secMarket = 51;
                    break;
                case "TrdSecMarket_AU":
                case 61:
                    message.secMarket = 61;
                    break;
                case "TrdSecMarket_MY":
                case 71:
                    message.secMarket = 71;
                    break;
                case "TrdSecMarket_CA":
                case 81:
                    message.secMarket = 81;
                    break;
                case "TrdSecMarket_FX":
                case 91:
                    message.secMarket = 91;
                    break;
                }
                if (object.orderIDEx != null)
                    message.orderIDEx = String(object.orderIDEx);
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.SellableReq.C2S
             * @static
             * @param {base.SellableReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.header = null;
                    object.orderType = options.enums === String ? "OrderType_Unknown" : 0;
                    object.code = "";
                    object.price = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.orderID = options.longs === String ? "0" : 0;
                    object.adjustPrice = false;
                    object.adjustSideAndLimit = 0;
                    object.secMarket = options.enums === String ? "TrdSecMarket_Unknown" : 0;
                    object.orderIDEx = "";
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.orderType != null && message.hasOwnProperty("orderType"))
                    object.orderType = options.enums === String ? $root.common.OrderType[message.orderType] === undefined ? message.orderType : $root.common.OrderType[message.orderType] : message.orderType;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.price != null && message.hasOwnProperty("price"))
                    object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
                if (message.orderID != null && message.hasOwnProperty("orderID"))
                    if (typeof message.orderID === "number")
                        object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                    else
                        object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
                if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                    object.adjustPrice = message.adjustPrice;
                if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                    object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
                if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                    object.secMarket = options.enums === String ? $root.common.TrdSecMarket[message.secMarket] === undefined ? message.secMarket : $root.common.TrdSecMarket[message.secMarket] : message.secMarket;
                if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                    object.orderIDEx = message.orderIDEx;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof base.SellableReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof base.SellableReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.SellableReq.C2S";
            };

            return C2S;
        })();

        return SellableReq;
    })();

    base.SellableRes = (function() {

        /**
         * Properties of a SellableRes.
         * @memberof base
         * @interface ISellableRes
         * @property {number} retType SellableRes retType
         * @property {string|null} [retMsg] SellableRes retMsg
         * @property {number|null} [errCode] SellableRes errCode
         * @property {base.SellableRes.IS2C|null} [s2c] SellableRes s2c
         */

        /**
         * Constructs a new SellableRes.
         * @memberof base
         * @classdesc 获取可卖数量响应
         * @implements ISellableRes
         * @constructor
         * @param {base.ISellableRes=} [properties] Properties to set
         */
        function SellableRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SellableRes retType.
         * @member {number} retType
         * @memberof base.SellableRes
         * @instance
         */
        SellableRes.prototype.retType = -400;

        /**
         * SellableRes retMsg.
         * @member {string} retMsg
         * @memberof base.SellableRes
         * @instance
         */
        SellableRes.prototype.retMsg = "";

        /**
         * SellableRes errCode.
         * @member {number} errCode
         * @memberof base.SellableRes
         * @instance
         */
        SellableRes.prototype.errCode = 0;

        /**
         * SellableRes s2c.
         * @member {base.SellableRes.IS2C|null|undefined} s2c
         * @memberof base.SellableRes
         * @instance
         */
        SellableRes.prototype.s2c = null;

        /**
         * Creates a new SellableRes instance using the specified properties.
         * @function create
         * @memberof base.SellableRes
         * @static
         * @param {base.ISellableRes=} [properties] Properties to set
         * @returns {base.SellableRes} SellableRes instance
         */
        SellableRes.create = function create(properties) {
            return new SellableRes(properties);
        };

        /**
         * Encodes the specified SellableRes message. Does not implicitly {@link base.SellableRes.verify|verify} messages.
         * @function encode
         * @memberof base.SellableRes
         * @static
         * @param {base.ISellableRes} message SellableRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellableRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.base.SellableRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SellableRes message, length delimited. Does not implicitly {@link base.SellableRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof base.SellableRes
         * @static
         * @param {base.ISellableRes} message SellableRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellableRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SellableRes message from the specified reader or buffer.
         * @function decode
         * @memberof base.SellableRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {base.SellableRes} SellableRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellableRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.SellableRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.base.SellableRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a SellableRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof base.SellableRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {base.SellableRes} SellableRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellableRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SellableRes message.
         * @function verify
         * @memberof base.SellableRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SellableRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.base.SellableRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a SellableRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof base.SellableRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {base.SellableRes} SellableRes
         */
        SellableRes.fromObject = function fromObject(object) {
            if (object instanceof $root.base.SellableRes)
                return object;
            let message = new $root.base.SellableRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".base.SellableRes.s2c: object expected");
                message.s2c = $root.base.SellableRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a SellableRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof base.SellableRes
         * @static
         * @param {base.SellableRes} message SellableRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SellableRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.base.SellableRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this SellableRes to JSON.
         * @function toJSON
         * @memberof base.SellableRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SellableRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SellableRes
         * @function getTypeUrl
         * @memberof base.SellableRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SellableRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/base.SellableRes";
        };

        SellableRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof base.SellableRes
             * @interface IS2C
             * @property {common.ITrdHeader} header S2C header
             * @property {Array.<common.IMaxTrdQtys>|null} [maxTrdQtys] S2C maxTrdQtys
             */

            /**
             * Constructs a new S2C.
             * @memberof base.SellableRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {base.SellableRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.maxTrdQtys = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C header.
             * @member {common.ITrdHeader} header
             * @memberof base.SellableRes.S2C
             * @instance
             */
            S2C.prototype.header = null;

            /**
             * S2C maxTrdQtys.
             * @member {Array.<common.IMaxTrdQtys>} maxTrdQtys
             * @memberof base.SellableRes.S2C
             * @instance
             */
            S2C.prototype.maxTrdQtys = $util.emptyArray;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof base.SellableRes.S2C
             * @static
             * @param {base.SellableRes.IS2C=} [properties] Properties to set
             * @returns {base.SellableRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link base.SellableRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof base.SellableRes.S2C
             * @static
             * @param {base.SellableRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.maxTrdQtys != null && message.maxTrdQtys.length)
                    for (let i = 0; i < message.maxTrdQtys.length; ++i)
                        $root.common.MaxTrdQtys.encode(message.maxTrdQtys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link base.SellableRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof base.SellableRes.S2C
             * @static
             * @param {base.SellableRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof base.SellableRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {base.SellableRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.base.SellableRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.maxTrdQtys && message.maxTrdQtys.length))
                                message.maxTrdQtys = [];
                            message.maxTrdQtys.push($root.common.MaxTrdQtys.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof base.SellableRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {base.SellableRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof base.SellableRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.maxTrdQtys != null && message.hasOwnProperty("maxTrdQtys")) {
                    if (!Array.isArray(message.maxTrdQtys))
                        return "maxTrdQtys: array expected";
                    for (let i = 0; i < message.maxTrdQtys.length; ++i) {
                        let error = $root.common.MaxTrdQtys.verify(message.maxTrdQtys[i]);
                        if (error)
                            return "maxTrdQtys." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof base.SellableRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {base.SellableRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.base.SellableRes.S2C)
                    return object;
                let message = new $root.base.SellableRes.S2C();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".base.SellableRes.S2C.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.maxTrdQtys) {
                    if (!Array.isArray(object.maxTrdQtys))
                        throw TypeError(".base.SellableRes.S2C.maxTrdQtys: array expected");
                    message.maxTrdQtys = [];
                    for (let i = 0; i < object.maxTrdQtys.length; ++i) {
                        if (typeof object.maxTrdQtys[i] !== "object")
                            throw TypeError(".base.SellableRes.S2C.maxTrdQtys: object expected");
                        message.maxTrdQtys[i] = $root.common.MaxTrdQtys.fromObject(object.maxTrdQtys[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof base.SellableRes.S2C
             * @static
             * @param {base.SellableRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.maxTrdQtys = [];
                if (options.defaults)
                    object.header = null;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.maxTrdQtys && message.maxTrdQtys.length) {
                    object.maxTrdQtys = [];
                    for (let j = 0; j < message.maxTrdQtys.length; ++j)
                        object.maxTrdQtys[j] = $root.common.MaxTrdQtys.toObject(message.maxTrdQtys[j], options);
                }
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof base.SellableRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof base.SellableRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/base.SellableRes.S2C";
            };

            return S2C;
        })();

        return SellableRes;
    })();

    return base;
})();

export const common = $root.common = (() => {

    /**
     * Namespace common.
     * @exports common
     * @namespace
     */
    const common = {};

    /**
     * PeriodType enum.
     * @name common.PeriodType
     * @enum {number}
     * @property {number} PeriodType_INTRADAY=0 PeriodType_INTRADAY value
     * @property {number} PeriodType_DAY=1 PeriodType_DAY value
     * @property {number} PeriodType_WEEK=2 PeriodType_WEEK value
     * @property {number} PeriodType_MONTH=3 PeriodType_MONTH value
     */
    common.PeriodType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PeriodType_INTRADAY"] = 0;
        values[valuesById[1] = "PeriodType_DAY"] = 1;
        values[valuesById[2] = "PeriodType_WEEK"] = 2;
        values[valuesById[3] = "PeriodType_MONTH"] = 3;
        return values;
    })();

    common.PreAfterMarketData = (function() {

        /**
         * Properties of a PreAfterMarketData.
         * @memberof common
         * @interface IPreAfterMarketData
         * @property {number|null} [price] PreAfterMarketData price
         * @property {number|null} [highPrice] PreAfterMarketData highPrice
         * @property {number|null} [lowPrice] PreAfterMarketData lowPrice
         * @property {number|Long|null} [volume] PreAfterMarketData volume
         * @property {number|null} [turnover] PreAfterMarketData turnover
         * @property {number|null} [changeVal] PreAfterMarketData changeVal
         * @property {number|null} [changeRate] PreAfterMarketData changeRate
         * @property {number|null} [amplitude] PreAfterMarketData amplitude
         */

        /**
         * Constructs a new PreAfterMarketData.
         * @memberof common
         * @classdesc 美股支持盘前盘后数据
         * 
         * 科创板仅支持盘后数据：成交量，成交额
         * @implements IPreAfterMarketData
         * @constructor
         * @param {common.IPreAfterMarketData=} [properties] Properties to set
         */
        function PreAfterMarketData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreAfterMarketData price.
         * @member {number} price
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.price = 0;

        /**
         * PreAfterMarketData highPrice.
         * @member {number} highPrice
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.highPrice = 0;

        /**
         * PreAfterMarketData lowPrice.
         * @member {number} lowPrice
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.lowPrice = 0;

        /**
         * PreAfterMarketData volume.
         * @member {number|Long} volume
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PreAfterMarketData turnover.
         * @member {number} turnover
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.turnover = 0;

        /**
         * PreAfterMarketData changeVal.
         * @member {number} changeVal
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.changeVal = 0;

        /**
         * PreAfterMarketData changeRate.
         * @member {number} changeRate
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.changeRate = 0;

        /**
         * PreAfterMarketData amplitude.
         * @member {number} amplitude
         * @memberof common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.amplitude = 0;

        /**
         * Creates a new PreAfterMarketData instance using the specified properties.
         * @function create
         * @memberof common.PreAfterMarketData
         * @static
         * @param {common.IPreAfterMarketData=} [properties] Properties to set
         * @returns {common.PreAfterMarketData} PreAfterMarketData instance
         */
        PreAfterMarketData.create = function create(properties) {
            return new PreAfterMarketData(properties);
        };

        /**
         * Encodes the specified PreAfterMarketData message. Does not implicitly {@link common.PreAfterMarketData.verify|verify} messages.
         * @function encode
         * @memberof common.PreAfterMarketData
         * @static
         * @param {common.IPreAfterMarketData} message PreAfterMarketData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAfterMarketData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.price);
            if (message.highPrice != null && Object.hasOwnProperty.call(message, "highPrice"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.highPrice);
            if (message.lowPrice != null && Object.hasOwnProperty.call(message, "lowPrice"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.lowPrice);
            if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.volume);
            if (message.turnover != null && Object.hasOwnProperty.call(message, "turnover"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.turnover);
            if (message.changeVal != null && Object.hasOwnProperty.call(message, "changeVal"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.changeVal);
            if (message.changeRate != null && Object.hasOwnProperty.call(message, "changeRate"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.changeRate);
            if (message.amplitude != null && Object.hasOwnProperty.call(message, "amplitude"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.amplitude);
            return writer;
        };

        /**
         * Encodes the specified PreAfterMarketData message, length delimited. Does not implicitly {@link common.PreAfterMarketData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.PreAfterMarketData
         * @static
         * @param {common.IPreAfterMarketData} message PreAfterMarketData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAfterMarketData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreAfterMarketData message from the specified reader or buffer.
         * @function decode
         * @memberof common.PreAfterMarketData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.PreAfterMarketData} PreAfterMarketData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAfterMarketData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.PreAfterMarketData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.price = reader.double();
                        break;
                    }
                case 2: {
                        message.highPrice = reader.double();
                        break;
                    }
                case 3: {
                        message.lowPrice = reader.double();
                        break;
                    }
                case 4: {
                        message.volume = reader.int64();
                        break;
                    }
                case 5: {
                        message.turnover = reader.double();
                        break;
                    }
                case 6: {
                        message.changeVal = reader.double();
                        break;
                    }
                case 7: {
                        message.changeRate = reader.double();
                        break;
                    }
                case 8: {
                        message.amplitude = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreAfterMarketData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.PreAfterMarketData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.PreAfterMarketData} PreAfterMarketData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAfterMarketData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreAfterMarketData message.
         * @function verify
         * @memberof common.PreAfterMarketData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreAfterMarketData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                if (typeof message.highPrice !== "number")
                    return "highPrice: number expected";
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                if (typeof message.lowPrice !== "number")
                    return "lowPrice: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                if (typeof message.turnover !== "number")
                    return "turnover: number expected";
            if (message.changeVal != null && message.hasOwnProperty("changeVal"))
                if (typeof message.changeVal !== "number")
                    return "changeVal: number expected";
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                if (typeof message.changeRate !== "number")
                    return "changeRate: number expected";
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                if (typeof message.amplitude !== "number")
                    return "amplitude: number expected";
            return null;
        };

        /**
         * Creates a PreAfterMarketData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.PreAfterMarketData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.PreAfterMarketData} PreAfterMarketData
         */
        PreAfterMarketData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.PreAfterMarketData)
                return object;
            let message = new $root.common.PreAfterMarketData();
            if (object.price != null)
                message.price = Number(object.price);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.changeVal != null)
                message.changeVal = Number(object.changeVal);
            if (object.changeRate != null)
                message.changeRate = Number(object.changeRate);
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            return message;
        };

        /**
         * Creates a plain object from a PreAfterMarketData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.PreAfterMarketData
         * @static
         * @param {common.PreAfterMarketData} message PreAfterMarketData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreAfterMarketData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.price = 0;
                object.highPrice = 0;
                object.lowPrice = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.changeVal = 0;
                object.changeRate = 0;
                object.amplitude = 0;
            }
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.changeVal != null && message.hasOwnProperty("changeVal"))
                object.changeVal = options.json && !isFinite(message.changeVal) ? String(message.changeVal) : message.changeVal;
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                object.changeRate = options.json && !isFinite(message.changeRate) ? String(message.changeRate) : message.changeRate;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            return object;
        };

        /**
         * Converts this PreAfterMarketData to JSON.
         * @function toJSON
         * @memberof common.PreAfterMarketData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreAfterMarketData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PreAfterMarketData
         * @function getTypeUrl
         * @memberof common.PreAfterMarketData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PreAfterMarketData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.PreAfterMarketData";
        };

        return PreAfterMarketData;
    })();

    common.SubInfo = (function() {

        /**
         * Properties of a SubInfo.
         * @memberof common
         * @interface ISubInfo
         * @property {common.SubType} subType SubInfo subType
         * @property {Array.<common.ISecurity>|null} [securityList] SubInfo securityList
         */

        /**
         * Constructs a new SubInfo.
         * @memberof common
         * @classdesc 订阅详情
         * @implements ISubInfo
         * @constructor
         * @param {common.ISubInfo=} [properties] Properties to set
         */
        function SubInfo(properties) {
            this.securityList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubInfo subType.
         * @member {common.SubType} subType
         * @memberof common.SubInfo
         * @instance
         */
        SubInfo.prototype.subType = 0;

        /**
         * SubInfo securityList.
         * @member {Array.<common.ISecurity>} securityList
         * @memberof common.SubInfo
         * @instance
         */
        SubInfo.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new SubInfo instance using the specified properties.
         * @function create
         * @memberof common.SubInfo
         * @static
         * @param {common.ISubInfo=} [properties] Properties to set
         * @returns {common.SubInfo} SubInfo instance
         */
        SubInfo.create = function create(properties) {
            return new SubInfo(properties);
        };

        /**
         * Encodes the specified SubInfo message. Does not implicitly {@link common.SubInfo.verify|verify} messages.
         * @function encode
         * @memberof common.SubInfo
         * @static
         * @param {common.ISubInfo} message SubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subType);
            if (message.securityList != null && message.securityList.length)
                for (let i = 0; i < message.securityList.length; ++i)
                    $root.common.Security.encode(message.securityList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubInfo message, length delimited. Does not implicitly {@link common.SubInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.SubInfo
         * @static
         * @param {common.ISubInfo} message SubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubInfo message from the specified reader or buffer.
         * @function decode
         * @memberof common.SubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.SubInfo} SubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SubInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.subType = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.securityList && message.securityList.length))
                            message.securityList = [];
                        message.securityList.push($root.common.Security.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("subType"))
                throw $util.ProtocolError("missing required 'subType'", { instance: message });
            return message;
        };

        /**
         * Decodes a SubInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.SubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.SubInfo} SubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubInfo message.
         * @function verify
         * @memberof common.SubInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.subType) {
            default:
                return "subType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
                break;
            }
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (let i = 0; i < message.securityList.length; ++i) {
                    let error = $root.common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.SubInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.SubInfo} SubInfo
         */
        SubInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.common.SubInfo)
                return object;
            let message = new $root.common.SubInfo();
            switch (object.subType) {
            default:
                if (typeof object.subType === "number") {
                    message.subType = object.subType;
                    break;
                }
                break;
            case "SubType_None":
            case 0:
                message.subType = 0;
                break;
            case "SubType_Basic":
            case 1:
                message.subType = 1;
                break;
            case "SubType_OrderBook":
            case 2:
                message.subType = 2;
                break;
            case "SubType_Ticker":
            case 4:
                message.subType = 4;
                break;
            case "SubType_RT":
            case 5:
                message.subType = 5;
                break;
            case "SubType_KL_Day":
            case 6:
                message.subType = 6;
                break;
            case "SubType_KL_5Min":
            case 7:
                message.subType = 7;
                break;
            case "SubType_KL_15Min":
            case 8:
                message.subType = 8;
                break;
            case "SubType_KL_30Min":
            case 9:
                message.subType = 9;
                break;
            case "SubType_KL_60Min":
            case 10:
                message.subType = 10;
                break;
            case "SubType_KL_1Min":
            case 11:
                message.subType = 11;
                break;
            case "SubType_KL_Week":
            case 12:
                message.subType = 12;
                break;
            case "SubType_KL_Month":
            case 13:
                message.subType = 13;
                break;
            case "SubType_Broker":
            case 14:
                message.subType = 14;
                break;
            case "SubType_KL_Qurater":
            case 15:
                message.subType = 15;
                break;
            case "SubType_KL_Year":
            case 16:
                message.subType = 16;
                break;
            case "SubType_KL_3Min":
            case 17:
                message.subType = 17;
                break;
            }
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".common.SubInfo.securityList: array expected");
                message.securityList = [];
                for (let i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".common.SubInfo.securityList: object expected");
                    message.securityList[i] = $root.common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.SubInfo
         * @static
         * @param {common.SubInfo} message SubInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults)
                object.subType = options.enums === String ? "SubType_None" : 0;
            if (message.subType != null && message.hasOwnProperty("subType"))
                object.subType = options.enums === String ? $root.common.SubType[message.subType] === undefined ? message.subType : $root.common.SubType[message.subType] : message.subType;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (let j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this SubInfo to JSON.
         * @function toJSON
         * @memberof common.SubInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubInfo
         * @function getTypeUrl
         * @memberof common.SubInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.SubInfo";
        };

        return SubInfo;
    })();

    common.ConnSubInfo = (function() {

        /**
         * Properties of a ConnSubInfo.
         * @memberof common
         * @interface IConnSubInfo
         * @property {Array.<common.ISubInfo>|null} [subInfoList] ConnSubInfo subInfoList
         * @property {number} usedQuota ConnSubInfo usedQuota
         * @property {boolean} isOwnConnData ConnSubInfo isOwnConnData
         */

        /**
         * Constructs a new ConnSubInfo.
         * @memberof common
         * @classdesc 链接订阅信息
         * @implements IConnSubInfo
         * @constructor
         * @param {common.IConnSubInfo=} [properties] Properties to set
         */
        function ConnSubInfo(properties) {
            this.subInfoList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnSubInfo subInfoList.
         * @member {Array.<common.ISubInfo>} subInfoList
         * @memberof common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.subInfoList = $util.emptyArray;

        /**
         * ConnSubInfo usedQuota.
         * @member {number} usedQuota
         * @memberof common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.usedQuota = 0;

        /**
         * ConnSubInfo isOwnConnData.
         * @member {boolean} isOwnConnData
         * @memberof common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.isOwnConnData = false;

        /**
         * Creates a new ConnSubInfo instance using the specified properties.
         * @function create
         * @memberof common.ConnSubInfo
         * @static
         * @param {common.IConnSubInfo=} [properties] Properties to set
         * @returns {common.ConnSubInfo} ConnSubInfo instance
         */
        ConnSubInfo.create = function create(properties) {
            return new ConnSubInfo(properties);
        };

        /**
         * Encodes the specified ConnSubInfo message. Does not implicitly {@link common.ConnSubInfo.verify|verify} messages.
         * @function encode
         * @memberof common.ConnSubInfo
         * @static
         * @param {common.IConnSubInfo} message ConnSubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnSubInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subInfoList != null && message.subInfoList.length)
                for (let i = 0; i < message.subInfoList.length; ++i)
                    $root.common.SubInfo.encode(message.subInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.usedQuota);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOwnConnData);
            return writer;
        };

        /**
         * Encodes the specified ConnSubInfo message, length delimited. Does not implicitly {@link common.ConnSubInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.ConnSubInfo
         * @static
         * @param {common.IConnSubInfo} message ConnSubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnSubInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnSubInfo message from the specified reader or buffer.
         * @function decode
         * @memberof common.ConnSubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.ConnSubInfo} ConnSubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnSubInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConnSubInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.subInfoList && message.subInfoList.length))
                            message.subInfoList = [];
                        message.subInfoList.push($root.common.SubInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.usedQuota = reader.int32();
                        break;
                    }
                case 3: {
                        message.isOwnConnData = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("usedQuota"))
                throw $util.ProtocolError("missing required 'usedQuota'", { instance: message });
            if (!message.hasOwnProperty("isOwnConnData"))
                throw $util.ProtocolError("missing required 'isOwnConnData'", { instance: message });
            return message;
        };

        /**
         * Decodes a ConnSubInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.ConnSubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.ConnSubInfo} ConnSubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnSubInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnSubInfo message.
         * @function verify
         * @memberof common.ConnSubInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnSubInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subInfoList != null && message.hasOwnProperty("subInfoList")) {
                if (!Array.isArray(message.subInfoList))
                    return "subInfoList: array expected";
                for (let i = 0; i < message.subInfoList.length; ++i) {
                    let error = $root.common.SubInfo.verify(message.subInfoList[i]);
                    if (error)
                        return "subInfoList." + error;
                }
            }
            if (!$util.isInteger(message.usedQuota))
                return "usedQuota: integer expected";
            if (typeof message.isOwnConnData !== "boolean")
                return "isOwnConnData: boolean expected";
            return null;
        };

        /**
         * Creates a ConnSubInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.ConnSubInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.ConnSubInfo} ConnSubInfo
         */
        ConnSubInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.common.ConnSubInfo)
                return object;
            let message = new $root.common.ConnSubInfo();
            if (object.subInfoList) {
                if (!Array.isArray(object.subInfoList))
                    throw TypeError(".common.ConnSubInfo.subInfoList: array expected");
                message.subInfoList = [];
                for (let i = 0; i < object.subInfoList.length; ++i) {
                    if (typeof object.subInfoList[i] !== "object")
                        throw TypeError(".common.ConnSubInfo.subInfoList: object expected");
                    message.subInfoList[i] = $root.common.SubInfo.fromObject(object.subInfoList[i]);
                }
            }
            if (object.usedQuota != null)
                message.usedQuota = object.usedQuota | 0;
            if (object.isOwnConnData != null)
                message.isOwnConnData = Boolean(object.isOwnConnData);
            return message;
        };

        /**
         * Creates a plain object from a ConnSubInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.ConnSubInfo
         * @static
         * @param {common.ConnSubInfo} message ConnSubInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnSubInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.subInfoList = [];
            if (options.defaults) {
                object.usedQuota = 0;
                object.isOwnConnData = false;
            }
            if (message.subInfoList && message.subInfoList.length) {
                object.subInfoList = [];
                for (let j = 0; j < message.subInfoList.length; ++j)
                    object.subInfoList[j] = $root.common.SubInfo.toObject(message.subInfoList[j], options);
            }
            if (message.usedQuota != null && message.hasOwnProperty("usedQuota"))
                object.usedQuota = message.usedQuota;
            if (message.isOwnConnData != null && message.hasOwnProperty("isOwnConnData"))
                object.isOwnConnData = message.isOwnConnData;
            return object;
        };

        /**
         * Converts this ConnSubInfo to JSON.
         * @function toJSON
         * @memberof common.ConnSubInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnSubInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ConnSubInfo
         * @function getTypeUrl
         * @memberof common.ConnSubInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConnSubInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.ConnSubInfo";
        };

        return ConnSubInfo;
    })();

    /**
     * TrdCategory enum.
     * @name common.TrdCategory
     * @enum {number}
     * @property {number} TrdCategory_Unknown=0 TrdCategory_Unknown value
     * @property {number} TrdCategory_Security=1 TrdCategory_Security value
     * @property {number} TrdCategory_Future=2 TrdCategory_Future value
     */
    common.TrdCategory = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdCategory_Unknown"] = 0;
        values[valuesById[1] = "TrdCategory_Security"] = 1;
        values[valuesById[2] = "TrdCategory_Future"] = 2;
        return values;
    })();

    /**
     * 系统通知类型
     * @name common.NotifyType
     * @enum {number}
     * @property {number} NotifyType_None=0 NotifyType_None value
     * @property {number} NotifyType_GtwEvent=1 NotifyType_GtwEvent value
     * @property {number} NotifyType_ProgramStatus=2 NotifyType_ProgramStatus value
     * @property {number} NotifyType_ConnStatus=3 NotifyType_ConnStatus value
     * @property {number} NotifyType_QotRight=4 NotifyType_QotRight value
     * @property {number} NotifyType_APILevel=5 NotifyType_APILevel value
     * @property {number} NotifyType_APIQuota=6 NotifyType_APIQuota value
     * @property {number} NotifyType_UsedQuota=7 NotifyType_UsedQuota value
     */
    common.NotifyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NotifyType_None"] = 0;
        values[valuesById[1] = "NotifyType_GtwEvent"] = 1;
        values[valuesById[2] = "NotifyType_ProgramStatus"] = 2;
        values[valuesById[3] = "NotifyType_ConnStatus"] = 3;
        values[valuesById[4] = "NotifyType_QotRight"] = 4;
        values[valuesById[5] = "NotifyType_APILevel"] = 5;
        values[valuesById[6] = "NotifyType_APIQuota"] = 6;
        values[valuesById[7] = "NotifyType_UsedQuota"] = 7;
        return values;
    })();

    common.TrdHeader = (function() {

        /**
         * Properties of a TrdHeader.
         * @memberof common
         * @interface ITrdHeader
         * @property {common.TrdEnv} trdEnv TrdHeader trdEnv
         * @property {number|Long} accID TrdHeader accID
         * @property {common.TrdMarket} trdMarket TrdHeader trdMarket
         */

        /**
         * Constructs a new TrdHeader.
         * @memberof common
         * @classdesc Represents a TrdHeader.
         * @implements ITrdHeader
         * @constructor
         * @param {common.ITrdHeader=} [properties] Properties to set
         */
        function TrdHeader(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdHeader trdEnv.
         * @member {common.TrdEnv} trdEnv
         * @memberof common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.trdEnv = 0;

        /**
         * TrdHeader accID.
         * @member {number|Long} accID
         * @memberof common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.accID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TrdHeader trdMarket.
         * @member {common.TrdMarket} trdMarket
         * @memberof common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.trdMarket = 0;

        /**
         * Creates a new TrdHeader instance using the specified properties.
         * @function create
         * @memberof common.TrdHeader
         * @static
         * @param {common.ITrdHeader=} [properties] Properties to set
         * @returns {common.TrdHeader} TrdHeader instance
         */
        TrdHeader.create = function create(properties) {
            return new TrdHeader(properties);
        };

        /**
         * Encodes the specified TrdHeader message. Does not implicitly {@link common.TrdHeader.verify|verify} messages.
         * @function encode
         * @memberof common.TrdHeader
         * @static
         * @param {common.ITrdHeader} message TrdHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdEnv);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accID);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdMarket);
            return writer;
        };

        /**
         * Encodes the specified TrdHeader message, length delimited. Does not implicitly {@link common.TrdHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.TrdHeader
         * @static
         * @param {common.ITrdHeader} message TrdHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdHeader message from the specified reader or buffer.
         * @function decode
         * @memberof common.TrdHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.TrdHeader} TrdHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.TrdHeader();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.trdEnv = reader.int32();
                        break;
                    }
                case 2: {
                        message.accID = reader.uint64();
                        break;
                    }
                case 3: {
                        message.trdMarket = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdEnv"))
                throw $util.ProtocolError("missing required 'trdEnv'", { instance: message });
            if (!message.hasOwnProperty("accID"))
                throw $util.ProtocolError("missing required 'accID'", { instance: message });
            if (!message.hasOwnProperty("trdMarket"))
                throw $util.ProtocolError("missing required 'trdMarket'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrdHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.TrdHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.TrdHeader} TrdHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdHeader message.
         * @function verify
         * @memberof common.TrdHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.trdEnv) {
            default:
                return "trdEnv: enum value expected";
            case 0:
            case 1:
                break;
            }
            if (!$util.isInteger(message.accID) && !(message.accID && $util.isInteger(message.accID.low) && $util.isInteger(message.accID.high)))
                return "accID: integer|Long expected";
            switch (message.trdMarket) {
            default:
                return "trdMarket: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 8:
            case 10:
            case 11:
            case 12:
            case 13:
            case 15:
            case 111:
            case 112:
            case 113:
            case 123:
                break;
            }
            return null;
        };

        /**
         * Creates a TrdHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.TrdHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.TrdHeader} TrdHeader
         */
        TrdHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.common.TrdHeader)
                return object;
            let message = new $root.common.TrdHeader();
            switch (object.trdEnv) {
            default:
                if (typeof object.trdEnv === "number") {
                    message.trdEnv = object.trdEnv;
                    break;
                }
                break;
            case "TrdEnv_Simulate":
            case 0:
                message.trdEnv = 0;
                break;
            case "TrdEnv_Real":
            case 1:
                message.trdEnv = 1;
                break;
            }
            if (object.accID != null)
                if ($util.Long)
                    (message.accID = $util.Long.fromValue(object.accID)).unsigned = true;
                else if (typeof object.accID === "string")
                    message.accID = parseInt(object.accID, 10);
                else if (typeof object.accID === "number")
                    message.accID = object.accID;
                else if (typeof object.accID === "object")
                    message.accID = new $util.LongBits(object.accID.low >>> 0, object.accID.high >>> 0).toNumber(true);
            switch (object.trdMarket) {
            default:
                if (typeof object.trdMarket === "number") {
                    message.trdMarket = object.trdMarket;
                    break;
                }
                break;
            case "TrdMarket_Unknown":
            case 0:
                message.trdMarket = 0;
                break;
            case "TrdMarket_HK":
            case 1:
                message.trdMarket = 1;
                break;
            case "TrdMarket_US":
            case 2:
                message.trdMarket = 2;
                break;
            case "TrdMarket_CN":
            case 3:
                message.trdMarket = 3;
                break;
            case "TrdMarket_HKCC":
            case 4:
                message.trdMarket = 4;
                break;
            case "TrdMarket_Futures":
            case 5:
                message.trdMarket = 5;
                break;
            case "TrdMarket_SG":
            case 6:
                message.trdMarket = 6;
                break;
            case "TrdMarket_AU":
            case 8:
                message.trdMarket = 8;
                break;
            case "TrdMarket_Futures_Simulate_HK":
            case 10:
                message.trdMarket = 10;
                break;
            case "TrdMarket_Futures_Simulate_US":
            case 11:
                message.trdMarket = 11;
                break;
            case "TrdMarket_Futures_Simulate_SG":
            case 12:
                message.trdMarket = 12;
                break;
            case "TrdMarket_Futures_Simulate_JP":
            case 13:
                message.trdMarket = 13;
                break;
            case "TrdMarket_JP":
            case 15:
                message.trdMarket = 15;
                break;
            case "TrdMarket_MY":
            case 111:
                message.trdMarket = 111;
                break;
            case "TrdMarket_CA":
            case 112:
                message.trdMarket = 112;
                break;
            case "TrdMarket_HK_Fund":
            case 113:
                message.trdMarket = 113;
                break;
            case "TrdMarket_US_Fund":
            case 123:
                message.trdMarket = 123;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TrdHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.TrdHeader
         * @static
         * @param {common.TrdHeader} message TrdHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.trdEnv = options.enums === String ? "TrdEnv_Simulate" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.accID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accID = options.longs === String ? "0" : 0;
                object.trdMarket = options.enums === String ? "TrdMarket_Unknown" : 0;
            }
            if (message.trdEnv != null && message.hasOwnProperty("trdEnv"))
                object.trdEnv = options.enums === String ? $root.common.TrdEnv[message.trdEnv] === undefined ? message.trdEnv : $root.common.TrdEnv[message.trdEnv] : message.trdEnv;
            if (message.accID != null && message.hasOwnProperty("accID"))
                if (typeof message.accID === "number")
                    object.accID = options.longs === String ? String(message.accID) : message.accID;
                else
                    object.accID = options.longs === String ? $util.Long.prototype.toString.call(message.accID) : options.longs === Number ? new $util.LongBits(message.accID.low >>> 0, message.accID.high >>> 0).toNumber(true) : message.accID;
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                object.trdMarket = options.enums === String ? $root.common.TrdMarket[message.trdMarket] === undefined ? message.trdMarket : $root.common.TrdMarket[message.trdMarket] : message.trdMarket;
            return object;
        };

        /**
         * Converts this TrdHeader to JSON.
         * @function toJSON
         * @memberof common.TrdHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrdHeader
         * @function getTypeUrl
         * @memberof common.TrdHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrdHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.TrdHeader";
        };

        return TrdHeader;
    })();

    common.TrdAcc = (function() {

        /**
         * Properties of a TrdAcc.
         * @memberof common
         * @interface ITrdAcc
         * @property {common.TrdEnv} trdEnv TrdAcc trdEnv
         * @property {number|Long} accID TrdAcc accID
         * @property {Array.<common.TrdMarket>|null} [trdMarketAuthList] TrdAcc trdMarketAuthList
         * @property {common.TrdAccType|null} [accType] TrdAcc accType
         * @property {string|null} [cardNum] TrdAcc cardNum
         * @property {common.SecurityFirm|null} [securityFirm] TrdAcc securityFirm
         * @property {number|null} [simAccType] TrdAcc simAccType
         * @property {string|null} [uniCardNum] TrdAcc uniCardNum
         * @property {common.TrdAccStatus|null} [accStatus] TrdAcc accStatus
         */

        /**
         * Constructs a new TrdAcc.
         * @memberof common
         * @classdesc Represents a TrdAcc.
         * @implements ITrdAcc
         * @constructor
         * @param {common.ITrdAcc=} [properties] Properties to set
         */
        function TrdAcc(properties) {
            this.trdMarketAuthList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdAcc trdEnv.
         * @member {common.TrdEnv} trdEnv
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.trdEnv = 0;

        /**
         * TrdAcc accID.
         * @member {number|Long} accID
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.accID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TrdAcc trdMarketAuthList.
         * @member {Array.<common.TrdMarket>} trdMarketAuthList
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.trdMarketAuthList = $util.emptyArray;

        /**
         * TrdAcc accType.
         * @member {common.TrdAccType} accType
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.accType = 0;

        /**
         * TrdAcc cardNum.
         * @member {string} cardNum
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.cardNum = "";

        /**
         * TrdAcc securityFirm.
         * @member {common.SecurityFirm} securityFirm
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.securityFirm = 0;

        /**
         * TrdAcc simAccType.
         * @member {number} simAccType
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.simAccType = 0;

        /**
         * TrdAcc uniCardNum.
         * @member {string} uniCardNum
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.uniCardNum = "";

        /**
         * TrdAcc accStatus.
         * @member {common.TrdAccStatus} accStatus
         * @memberof common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.accStatus = 0;

        /**
         * Creates a new TrdAcc instance using the specified properties.
         * @function create
         * @memberof common.TrdAcc
         * @static
         * @param {common.ITrdAcc=} [properties] Properties to set
         * @returns {common.TrdAcc} TrdAcc instance
         */
        TrdAcc.create = function create(properties) {
            return new TrdAcc(properties);
        };

        /**
         * Encodes the specified TrdAcc message. Does not implicitly {@link common.TrdAcc.verify|verify} messages.
         * @function encode
         * @memberof common.TrdAcc
         * @static
         * @param {common.ITrdAcc} message TrdAcc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdAcc.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdEnv);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accID);
            if (message.trdMarketAuthList != null && message.trdMarketAuthList.length)
                for (let i = 0; i < message.trdMarketAuthList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdMarketAuthList[i]);
            if (message.accType != null && Object.hasOwnProperty.call(message, "accType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.accType);
            if (message.cardNum != null && Object.hasOwnProperty.call(message, "cardNum"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.cardNum);
            if (message.securityFirm != null && Object.hasOwnProperty.call(message, "securityFirm"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.securityFirm);
            if (message.simAccType != null && Object.hasOwnProperty.call(message, "simAccType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.simAccType);
            if (message.uniCardNum != null && Object.hasOwnProperty.call(message, "uniCardNum"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.uniCardNum);
            if (message.accStatus != null && Object.hasOwnProperty.call(message, "accStatus"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.accStatus);
            return writer;
        };

        /**
         * Encodes the specified TrdAcc message, length delimited. Does not implicitly {@link common.TrdAcc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.TrdAcc
         * @static
         * @param {common.ITrdAcc} message TrdAcc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdAcc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdAcc message from the specified reader or buffer.
         * @function decode
         * @memberof common.TrdAcc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.TrdAcc} TrdAcc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdAcc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.TrdAcc();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.trdEnv = reader.int32();
                        break;
                    }
                case 2: {
                        message.accID = reader.uint64();
                        break;
                    }
                case 3: {
                        if (!(message.trdMarketAuthList && message.trdMarketAuthList.length))
                            message.trdMarketAuthList = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.trdMarketAuthList.push(reader.int32());
                        } else
                            message.trdMarketAuthList.push(reader.int32());
                        break;
                    }
                case 4: {
                        message.accType = reader.int32();
                        break;
                    }
                case 5: {
                        message.cardNum = reader.string();
                        break;
                    }
                case 6: {
                        message.securityFirm = reader.int32();
                        break;
                    }
                case 7: {
                        message.simAccType = reader.int32();
                        break;
                    }
                case 8: {
                        message.uniCardNum = reader.string();
                        break;
                    }
                case 9: {
                        message.accStatus = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdEnv"))
                throw $util.ProtocolError("missing required 'trdEnv'", { instance: message });
            if (!message.hasOwnProperty("accID"))
                throw $util.ProtocolError("missing required 'accID'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrdAcc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.TrdAcc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.TrdAcc} TrdAcc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdAcc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdAcc message.
         * @function verify
         * @memberof common.TrdAcc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdAcc.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.trdEnv) {
            default:
                return "trdEnv: enum value expected";
            case 0:
            case 1:
                break;
            }
            if (!$util.isInteger(message.accID) && !(message.accID && $util.isInteger(message.accID.low) && $util.isInteger(message.accID.high)))
                return "accID: integer|Long expected";
            if (message.trdMarketAuthList != null && message.hasOwnProperty("trdMarketAuthList")) {
                if (!Array.isArray(message.trdMarketAuthList))
                    return "trdMarketAuthList: array expected";
                for (let i = 0; i < message.trdMarketAuthList.length; ++i)
                    switch (message.trdMarketAuthList[i]) {
                    default:
                        return "trdMarketAuthList: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 8:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 15:
                    case 111:
                    case 112:
                    case 113:
                    case 123:
                        break;
                    }
            }
            if (message.accType != null && message.hasOwnProperty("accType"))
                switch (message.accType) {
                default:
                    return "accType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.cardNum != null && message.hasOwnProperty("cardNum"))
                if (!$util.isString(message.cardNum))
                    return "cardNum: string expected";
            if (message.securityFirm != null && message.hasOwnProperty("securityFirm"))
                switch (message.securityFirm) {
                default:
                    return "securityFirm: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.simAccType != null && message.hasOwnProperty("simAccType"))
                if (!$util.isInteger(message.simAccType))
                    return "simAccType: integer expected";
            if (message.uniCardNum != null && message.hasOwnProperty("uniCardNum"))
                if (!$util.isString(message.uniCardNum))
                    return "uniCardNum: string expected";
            if (message.accStatus != null && message.hasOwnProperty("accStatus"))
                switch (message.accStatus) {
                default:
                    return "accStatus: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a TrdAcc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.TrdAcc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.TrdAcc} TrdAcc
         */
        TrdAcc.fromObject = function fromObject(object) {
            if (object instanceof $root.common.TrdAcc)
                return object;
            let message = new $root.common.TrdAcc();
            switch (object.trdEnv) {
            default:
                if (typeof object.trdEnv === "number") {
                    message.trdEnv = object.trdEnv;
                    break;
                }
                break;
            case "TrdEnv_Simulate":
            case 0:
                message.trdEnv = 0;
                break;
            case "TrdEnv_Real":
            case 1:
                message.trdEnv = 1;
                break;
            }
            if (object.accID != null)
                if ($util.Long)
                    (message.accID = $util.Long.fromValue(object.accID)).unsigned = true;
                else if (typeof object.accID === "string")
                    message.accID = parseInt(object.accID, 10);
                else if (typeof object.accID === "number")
                    message.accID = object.accID;
                else if (typeof object.accID === "object")
                    message.accID = new $util.LongBits(object.accID.low >>> 0, object.accID.high >>> 0).toNumber(true);
            if (object.trdMarketAuthList) {
                if (!Array.isArray(object.trdMarketAuthList))
                    throw TypeError(".common.TrdAcc.trdMarketAuthList: array expected");
                message.trdMarketAuthList = [];
                for (let i = 0; i < object.trdMarketAuthList.length; ++i)
                    switch (object.trdMarketAuthList[i]) {
                    default:
                        if (typeof object.trdMarketAuthList[i] === "number") {
                            message.trdMarketAuthList[i] = object.trdMarketAuthList[i];
                            break;
                        }
                    case "TrdMarket_Unknown":
                    case 0:
                        message.trdMarketAuthList[i] = 0;
                        break;
                    case "TrdMarket_HK":
                    case 1:
                        message.trdMarketAuthList[i] = 1;
                        break;
                    case "TrdMarket_US":
                    case 2:
                        message.trdMarketAuthList[i] = 2;
                        break;
                    case "TrdMarket_CN":
                    case 3:
                        message.trdMarketAuthList[i] = 3;
                        break;
                    case "TrdMarket_HKCC":
                    case 4:
                        message.trdMarketAuthList[i] = 4;
                        break;
                    case "TrdMarket_Futures":
                    case 5:
                        message.trdMarketAuthList[i] = 5;
                        break;
                    case "TrdMarket_SG":
                    case 6:
                        message.trdMarketAuthList[i] = 6;
                        break;
                    case "TrdMarket_AU":
                    case 8:
                        message.trdMarketAuthList[i] = 8;
                        break;
                    case "TrdMarket_Futures_Simulate_HK":
                    case 10:
                        message.trdMarketAuthList[i] = 10;
                        break;
                    case "TrdMarket_Futures_Simulate_US":
                    case 11:
                        message.trdMarketAuthList[i] = 11;
                        break;
                    case "TrdMarket_Futures_Simulate_SG":
                    case 12:
                        message.trdMarketAuthList[i] = 12;
                        break;
                    case "TrdMarket_Futures_Simulate_JP":
                    case 13:
                        message.trdMarketAuthList[i] = 13;
                        break;
                    case "TrdMarket_JP":
                    case 15:
                        message.trdMarketAuthList[i] = 15;
                        break;
                    case "TrdMarket_MY":
                    case 111:
                        message.trdMarketAuthList[i] = 111;
                        break;
                    case "TrdMarket_CA":
                    case 112:
                        message.trdMarketAuthList[i] = 112;
                        break;
                    case "TrdMarket_HK_Fund":
                    case 113:
                        message.trdMarketAuthList[i] = 113;
                        break;
                    case "TrdMarket_US_Fund":
                    case 123:
                        message.trdMarketAuthList[i] = 123;
                        break;
                    }
            }
            switch (object.accType) {
            default:
                if (typeof object.accType === "number") {
                    message.accType = object.accType;
                    break;
                }
                break;
            case "TrdAccType_Unknown":
            case 0:
                message.accType = 0;
                break;
            case "TrdAccType_Cash":
            case 1:
                message.accType = 1;
                break;
            case "TrdAccType_Margin":
            case 2:
                message.accType = 2;
                break;
            }
            if (object.cardNum != null)
                message.cardNum = String(object.cardNum);
            switch (object.securityFirm) {
            default:
                if (typeof object.securityFirm === "number") {
                    message.securityFirm = object.securityFirm;
                    break;
                }
                break;
            case "SecurityFirm_Unknown":
            case 0:
                message.securityFirm = 0;
                break;
            case "SecurityFirm_FutuSecurities":
            case 1:
                message.securityFirm = 1;
                break;
            case "SecurityFirm_FutuInc":
            case 2:
                message.securityFirm = 2;
                break;
            case "SecurityFirm_FutuSG":
            case 3:
                message.securityFirm = 3;
                break;
            case "SecurityFirm_FutuAU":
            case 4:
                message.securityFirm = 4;
                break;
            }
            if (object.simAccType != null)
                message.simAccType = object.simAccType | 0;
            if (object.uniCardNum != null)
                message.uniCardNum = String(object.uniCardNum);
            switch (object.accStatus) {
            default:
                if (typeof object.accStatus === "number") {
                    message.accStatus = object.accStatus;
                    break;
                }
                break;
            case "TrdAccStatus_Active":
            case 0:
                message.accStatus = 0;
                break;
            case "TrdAccStatus_Disabled":
            case 1:
                message.accStatus = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TrdAcc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.TrdAcc
         * @static
         * @param {common.TrdAcc} message TrdAcc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdAcc.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.trdMarketAuthList = [];
            if (options.defaults) {
                object.trdEnv = options.enums === String ? "TrdEnv_Simulate" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.accID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accID = options.longs === String ? "0" : 0;
                object.accType = options.enums === String ? "TrdAccType_Unknown" : 0;
                object.cardNum = "";
                object.securityFirm = options.enums === String ? "SecurityFirm_Unknown" : 0;
                object.simAccType = 0;
                object.uniCardNum = "";
                object.accStatus = options.enums === String ? "TrdAccStatus_Active" : 0;
            }
            if (message.trdEnv != null && message.hasOwnProperty("trdEnv"))
                object.trdEnv = options.enums === String ? $root.common.TrdEnv[message.trdEnv] === undefined ? message.trdEnv : $root.common.TrdEnv[message.trdEnv] : message.trdEnv;
            if (message.accID != null && message.hasOwnProperty("accID"))
                if (typeof message.accID === "number")
                    object.accID = options.longs === String ? String(message.accID) : message.accID;
                else
                    object.accID = options.longs === String ? $util.Long.prototype.toString.call(message.accID) : options.longs === Number ? new $util.LongBits(message.accID.low >>> 0, message.accID.high >>> 0).toNumber(true) : message.accID;
            if (message.trdMarketAuthList && message.trdMarketAuthList.length) {
                object.trdMarketAuthList = [];
                for (let j = 0; j < message.trdMarketAuthList.length; ++j)
                    object.trdMarketAuthList[j] = options.enums === String ? $root.common.TrdMarket[message.trdMarketAuthList[j]] === undefined ? message.trdMarketAuthList[j] : $root.common.TrdMarket[message.trdMarketAuthList[j]] : message.trdMarketAuthList[j];
            }
            if (message.accType != null && message.hasOwnProperty("accType"))
                object.accType = options.enums === String ? $root.common.TrdAccType[message.accType] === undefined ? message.accType : $root.common.TrdAccType[message.accType] : message.accType;
            if (message.cardNum != null && message.hasOwnProperty("cardNum"))
                object.cardNum = message.cardNum;
            if (message.securityFirm != null && message.hasOwnProperty("securityFirm"))
                object.securityFirm = options.enums === String ? $root.common.SecurityFirm[message.securityFirm] === undefined ? message.securityFirm : $root.common.SecurityFirm[message.securityFirm] : message.securityFirm;
            if (message.simAccType != null && message.hasOwnProperty("simAccType"))
                object.simAccType = message.simAccType;
            if (message.uniCardNum != null && message.hasOwnProperty("uniCardNum"))
                object.uniCardNum = message.uniCardNum;
            if (message.accStatus != null && message.hasOwnProperty("accStatus"))
                object.accStatus = options.enums === String ? $root.common.TrdAccStatus[message.accStatus] === undefined ? message.accStatus : $root.common.TrdAccStatus[message.accStatus] : message.accStatus;
            return object;
        };

        /**
         * Converts this TrdAcc to JSON.
         * @function toJSON
         * @memberof common.TrdAcc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdAcc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrdAcc
         * @function getTypeUrl
         * @memberof common.TrdAcc
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrdAcc.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.TrdAcc";
        };

        return TrdAcc;
    })();

    common.Funds = (function() {

        /**
         * Properties of a Funds.
         * @memberof common
         * @interface IFunds
         * @property {number} power Funds power
         * @property {number} totalAssets Funds totalAssets
         * @property {number} cash Funds cash
         * @property {number} marketVal Funds marketVal
         * @property {number} frozenCash Funds frozenCash
         * @property {number} debtCash Funds debtCash
         * @property {number} avlWithdrawalCash Funds avlWithdrawalCash
         * @property {common.Currency|null} [currency] Funds currency
         * @property {number|null} [availableFunds] Funds availableFunds
         * @property {number|null} [unrealizedPL] Funds unrealizedPL
         * @property {number|null} [realizedPL] Funds realizedPL
         * @property {number|null} [riskLevel] Funds riskLevel
         * @property {number|null} [initialMargin] Funds initialMargin
         * @property {number|null} [maintenanceMargin] Funds maintenanceMargin
         * @property {Array.<common.IAccCashInfo>|null} [cashInfoList] Funds cashInfoList
         * @property {number|null} [maxPowerShort] Funds maxPowerShort
         * @property {number|null} [netCashPower] Funds netCashPower
         * @property {number|null} [longMv] Funds longMv
         * @property {number|null} [shortMv] Funds shortMv
         * @property {number|null} [pendingAsset] Funds pendingAsset
         * @property {number|null} [maxWithdrawal] Funds maxWithdrawal
         * @property {number|null} [riskStatus] Funds riskStatus
         * @property {number|null} [marginCallMargin] Funds marginCallMargin
         * @property {boolean|null} [isPdt] Funds isPdt
         * @property {string|null} [pdtSeq] Funds pdtSeq
         * @property {number|null} [beginningDTBP] Funds beginningDTBP
         * @property {number|null} [remainingDTBP] Funds remainingDTBP
         * @property {number|null} [dtCallAmount] Funds dtCallAmount
         * @property {number|null} [dtStatus] Funds dtStatus
         * @property {number|null} [securitiesAssets] Funds securitiesAssets
         * @property {number|null} [fundAssets] Funds fundAssets
         * @property {number|null} [bondAssets] Funds bondAssets
         * @property {Array.<common.IAccMarketInfo>|null} [marketInfoList] Funds marketInfoList
         */

        /**
         * Constructs a new Funds.
         * @memberof common
         * @classdesc Represents a Funds.
         * @implements IFunds
         * @constructor
         * @param {common.IFunds=} [properties] Properties to set
         */
        function Funds(properties) {
            this.cashInfoList = [];
            this.marketInfoList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Funds power.
         * @member {number} power
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.power = 0;

        /**
         * Funds totalAssets.
         * @member {number} totalAssets
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.totalAssets = 0;

        /**
         * Funds cash.
         * @member {number} cash
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.cash = 0;

        /**
         * Funds marketVal.
         * @member {number} marketVal
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.marketVal = 0;

        /**
         * Funds frozenCash.
         * @member {number} frozenCash
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.frozenCash = 0;

        /**
         * Funds debtCash.
         * @member {number} debtCash
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.debtCash = 0;

        /**
         * Funds avlWithdrawalCash.
         * @member {number} avlWithdrawalCash
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.avlWithdrawalCash = 0;

        /**
         * Funds currency.
         * @member {common.Currency} currency
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.currency = 0;

        /**
         * Funds availableFunds.
         * @member {number} availableFunds
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.availableFunds = 0;

        /**
         * Funds unrealizedPL.
         * @member {number} unrealizedPL
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.unrealizedPL = 0;

        /**
         * Funds realizedPL.
         * @member {number} realizedPL
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.realizedPL = 0;

        /**
         * Funds riskLevel.
         * @member {number} riskLevel
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.riskLevel = 0;

        /**
         * Funds initialMargin.
         * @member {number} initialMargin
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.initialMargin = 0;

        /**
         * Funds maintenanceMargin.
         * @member {number} maintenanceMargin
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.maintenanceMargin = 0;

        /**
         * Funds cashInfoList.
         * @member {Array.<common.IAccCashInfo>} cashInfoList
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.cashInfoList = $util.emptyArray;

        /**
         * Funds maxPowerShort.
         * @member {number} maxPowerShort
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.maxPowerShort = 0;

        /**
         * Funds netCashPower.
         * @member {number} netCashPower
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.netCashPower = 0;

        /**
         * Funds longMv.
         * @member {number} longMv
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.longMv = 0;

        /**
         * Funds shortMv.
         * @member {number} shortMv
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.shortMv = 0;

        /**
         * Funds pendingAsset.
         * @member {number} pendingAsset
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.pendingAsset = 0;

        /**
         * Funds maxWithdrawal.
         * @member {number} maxWithdrawal
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.maxWithdrawal = 0;

        /**
         * Funds riskStatus.
         * @member {number} riskStatus
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.riskStatus = 0;

        /**
         * Funds marginCallMargin.
         * @member {number} marginCallMargin
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.marginCallMargin = 0;

        /**
         * Funds isPdt.
         * @member {boolean} isPdt
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.isPdt = false;

        /**
         * Funds pdtSeq.
         * @member {string} pdtSeq
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.pdtSeq = "";

        /**
         * Funds beginningDTBP.
         * @member {number} beginningDTBP
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.beginningDTBP = 0;

        /**
         * Funds remainingDTBP.
         * @member {number} remainingDTBP
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.remainingDTBP = 0;

        /**
         * Funds dtCallAmount.
         * @member {number} dtCallAmount
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.dtCallAmount = 0;

        /**
         * Funds dtStatus.
         * @member {number} dtStatus
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.dtStatus = 0;

        /**
         * Funds securitiesAssets.
         * @member {number} securitiesAssets
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.securitiesAssets = 0;

        /**
         * Funds fundAssets.
         * @member {number} fundAssets
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.fundAssets = 0;

        /**
         * Funds bondAssets.
         * @member {number} bondAssets
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.bondAssets = 0;

        /**
         * Funds marketInfoList.
         * @member {Array.<common.IAccMarketInfo>} marketInfoList
         * @memberof common.Funds
         * @instance
         */
        Funds.prototype.marketInfoList = $util.emptyArray;

        /**
         * Creates a new Funds instance using the specified properties.
         * @function create
         * @memberof common.Funds
         * @static
         * @param {common.IFunds=} [properties] Properties to set
         * @returns {common.Funds} Funds instance
         */
        Funds.create = function create(properties) {
            return new Funds(properties);
        };

        /**
         * Encodes the specified Funds message. Does not implicitly {@link common.Funds.verify|verify} messages.
         * @function encode
         * @memberof common.Funds
         * @static
         * @param {common.IFunds} message Funds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Funds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.power);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.totalAssets);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.cash);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.marketVal);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.frozenCash);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.debtCash);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.avlWithdrawalCash);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.currency);
            if (message.availableFunds != null && Object.hasOwnProperty.call(message, "availableFunds"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.availableFunds);
            if (message.unrealizedPL != null && Object.hasOwnProperty.call(message, "unrealizedPL"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.unrealizedPL);
            if (message.realizedPL != null && Object.hasOwnProperty.call(message, "realizedPL"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.realizedPL);
            if (message.riskLevel != null && Object.hasOwnProperty.call(message, "riskLevel"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.riskLevel);
            if (message.initialMargin != null && Object.hasOwnProperty.call(message, "initialMargin"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.initialMargin);
            if (message.maintenanceMargin != null && Object.hasOwnProperty.call(message, "maintenanceMargin"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.maintenanceMargin);
            if (message.cashInfoList != null && message.cashInfoList.length)
                for (let i = 0; i < message.cashInfoList.length; ++i)
                    $root.common.AccCashInfo.encode(message.cashInfoList[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.maxPowerShort != null && Object.hasOwnProperty.call(message, "maxPowerShort"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.maxPowerShort);
            if (message.netCashPower != null && Object.hasOwnProperty.call(message, "netCashPower"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.netCashPower);
            if (message.longMv != null && Object.hasOwnProperty.call(message, "longMv"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.longMv);
            if (message.shortMv != null && Object.hasOwnProperty.call(message, "shortMv"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.shortMv);
            if (message.pendingAsset != null && Object.hasOwnProperty.call(message, "pendingAsset"))
                writer.uint32(/* id 20, wireType 1 =*/161).double(message.pendingAsset);
            if (message.maxWithdrawal != null && Object.hasOwnProperty.call(message, "maxWithdrawal"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.maxWithdrawal);
            if (message.riskStatus != null && Object.hasOwnProperty.call(message, "riskStatus"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.riskStatus);
            if (message.marginCallMargin != null && Object.hasOwnProperty.call(message, "marginCallMargin"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.marginCallMargin);
            if (message.isPdt != null && Object.hasOwnProperty.call(message, "isPdt"))
                writer.uint32(/* id 24, wireType 0 =*/192).bool(message.isPdt);
            if (message.pdtSeq != null && Object.hasOwnProperty.call(message, "pdtSeq"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.pdtSeq);
            if (message.beginningDTBP != null && Object.hasOwnProperty.call(message, "beginningDTBP"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.beginningDTBP);
            if (message.remainingDTBP != null && Object.hasOwnProperty.call(message, "remainingDTBP"))
                writer.uint32(/* id 27, wireType 1 =*/217).double(message.remainingDTBP);
            if (message.dtCallAmount != null && Object.hasOwnProperty.call(message, "dtCallAmount"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.dtCallAmount);
            if (message.dtStatus != null && Object.hasOwnProperty.call(message, "dtStatus"))
                writer.uint32(/* id 29, wireType 0 =*/232).int32(message.dtStatus);
            if (message.securitiesAssets != null && Object.hasOwnProperty.call(message, "securitiesAssets"))
                writer.uint32(/* id 30, wireType 1 =*/241).double(message.securitiesAssets);
            if (message.fundAssets != null && Object.hasOwnProperty.call(message, "fundAssets"))
                writer.uint32(/* id 31, wireType 1 =*/249).double(message.fundAssets);
            if (message.bondAssets != null && Object.hasOwnProperty.call(message, "bondAssets"))
                writer.uint32(/* id 32, wireType 1 =*/257).double(message.bondAssets);
            if (message.marketInfoList != null && message.marketInfoList.length)
                for (let i = 0; i < message.marketInfoList.length; ++i)
                    $root.common.AccMarketInfo.encode(message.marketInfoList[i], writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Funds message, length delimited. Does not implicitly {@link common.Funds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.Funds
         * @static
         * @param {common.IFunds} message Funds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Funds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Funds message from the specified reader or buffer.
         * @function decode
         * @memberof common.Funds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.Funds} Funds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Funds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Funds();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.power = reader.double();
                        break;
                    }
                case 2: {
                        message.totalAssets = reader.double();
                        break;
                    }
                case 3: {
                        message.cash = reader.double();
                        break;
                    }
                case 4: {
                        message.marketVal = reader.double();
                        break;
                    }
                case 5: {
                        message.frozenCash = reader.double();
                        break;
                    }
                case 6: {
                        message.debtCash = reader.double();
                        break;
                    }
                case 7: {
                        message.avlWithdrawalCash = reader.double();
                        break;
                    }
                case 8: {
                        message.currency = reader.int32();
                        break;
                    }
                case 9: {
                        message.availableFunds = reader.double();
                        break;
                    }
                case 10: {
                        message.unrealizedPL = reader.double();
                        break;
                    }
                case 11: {
                        message.realizedPL = reader.double();
                        break;
                    }
                case 12: {
                        message.riskLevel = reader.int32();
                        break;
                    }
                case 13: {
                        message.initialMargin = reader.double();
                        break;
                    }
                case 14: {
                        message.maintenanceMargin = reader.double();
                        break;
                    }
                case 15: {
                        if (!(message.cashInfoList && message.cashInfoList.length))
                            message.cashInfoList = [];
                        message.cashInfoList.push($root.common.AccCashInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 16: {
                        message.maxPowerShort = reader.double();
                        break;
                    }
                case 17: {
                        message.netCashPower = reader.double();
                        break;
                    }
                case 18: {
                        message.longMv = reader.double();
                        break;
                    }
                case 19: {
                        message.shortMv = reader.double();
                        break;
                    }
                case 20: {
                        message.pendingAsset = reader.double();
                        break;
                    }
                case 21: {
                        message.maxWithdrawal = reader.double();
                        break;
                    }
                case 22: {
                        message.riskStatus = reader.int32();
                        break;
                    }
                case 23: {
                        message.marginCallMargin = reader.double();
                        break;
                    }
                case 24: {
                        message.isPdt = reader.bool();
                        break;
                    }
                case 25: {
                        message.pdtSeq = reader.string();
                        break;
                    }
                case 26: {
                        message.beginningDTBP = reader.double();
                        break;
                    }
                case 27: {
                        message.remainingDTBP = reader.double();
                        break;
                    }
                case 28: {
                        message.dtCallAmount = reader.double();
                        break;
                    }
                case 29: {
                        message.dtStatus = reader.int32();
                        break;
                    }
                case 30: {
                        message.securitiesAssets = reader.double();
                        break;
                    }
                case 31: {
                        message.fundAssets = reader.double();
                        break;
                    }
                case 32: {
                        message.bondAssets = reader.double();
                        break;
                    }
                case 33: {
                        if (!(message.marketInfoList && message.marketInfoList.length))
                            message.marketInfoList = [];
                        message.marketInfoList.push($root.common.AccMarketInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("power"))
                throw $util.ProtocolError("missing required 'power'", { instance: message });
            if (!message.hasOwnProperty("totalAssets"))
                throw $util.ProtocolError("missing required 'totalAssets'", { instance: message });
            if (!message.hasOwnProperty("cash"))
                throw $util.ProtocolError("missing required 'cash'", { instance: message });
            if (!message.hasOwnProperty("marketVal"))
                throw $util.ProtocolError("missing required 'marketVal'", { instance: message });
            if (!message.hasOwnProperty("frozenCash"))
                throw $util.ProtocolError("missing required 'frozenCash'", { instance: message });
            if (!message.hasOwnProperty("debtCash"))
                throw $util.ProtocolError("missing required 'debtCash'", { instance: message });
            if (!message.hasOwnProperty("avlWithdrawalCash"))
                throw $util.ProtocolError("missing required 'avlWithdrawalCash'", { instance: message });
            return message;
        };

        /**
         * Decodes a Funds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.Funds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.Funds} Funds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Funds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Funds message.
         * @function verify
         * @memberof common.Funds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Funds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.power !== "number")
                return "power: number expected";
            if (typeof message.totalAssets !== "number")
                return "totalAssets: number expected";
            if (typeof message.cash !== "number")
                return "cash: number expected";
            if (typeof message.marketVal !== "number")
                return "marketVal: number expected";
            if (typeof message.frozenCash !== "number")
                return "frozenCash: number expected";
            if (typeof message.debtCash !== "number")
                return "debtCash: number expected";
            if (typeof message.avlWithdrawalCash !== "number")
                return "avlWithdrawalCash: number expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                switch (message.currency) {
                default:
                    return "currency: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.availableFunds != null && message.hasOwnProperty("availableFunds"))
                if (typeof message.availableFunds !== "number")
                    return "availableFunds: number expected";
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                if (typeof message.unrealizedPL !== "number")
                    return "unrealizedPL: number expected";
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                if (typeof message.realizedPL !== "number")
                    return "realizedPL: number expected";
            if (message.riskLevel != null && message.hasOwnProperty("riskLevel"))
                if (!$util.isInteger(message.riskLevel))
                    return "riskLevel: integer expected";
            if (message.initialMargin != null && message.hasOwnProperty("initialMargin"))
                if (typeof message.initialMargin !== "number")
                    return "initialMargin: number expected";
            if (message.maintenanceMargin != null && message.hasOwnProperty("maintenanceMargin"))
                if (typeof message.maintenanceMargin !== "number")
                    return "maintenanceMargin: number expected";
            if (message.cashInfoList != null && message.hasOwnProperty("cashInfoList")) {
                if (!Array.isArray(message.cashInfoList))
                    return "cashInfoList: array expected";
                for (let i = 0; i < message.cashInfoList.length; ++i) {
                    let error = $root.common.AccCashInfo.verify(message.cashInfoList[i]);
                    if (error)
                        return "cashInfoList." + error;
                }
            }
            if (message.maxPowerShort != null && message.hasOwnProperty("maxPowerShort"))
                if (typeof message.maxPowerShort !== "number")
                    return "maxPowerShort: number expected";
            if (message.netCashPower != null && message.hasOwnProperty("netCashPower"))
                if (typeof message.netCashPower !== "number")
                    return "netCashPower: number expected";
            if (message.longMv != null && message.hasOwnProperty("longMv"))
                if (typeof message.longMv !== "number")
                    return "longMv: number expected";
            if (message.shortMv != null && message.hasOwnProperty("shortMv"))
                if (typeof message.shortMv !== "number")
                    return "shortMv: number expected";
            if (message.pendingAsset != null && message.hasOwnProperty("pendingAsset"))
                if (typeof message.pendingAsset !== "number")
                    return "pendingAsset: number expected";
            if (message.maxWithdrawal != null && message.hasOwnProperty("maxWithdrawal"))
                if (typeof message.maxWithdrawal !== "number")
                    return "maxWithdrawal: number expected";
            if (message.riskStatus != null && message.hasOwnProperty("riskStatus"))
                if (!$util.isInteger(message.riskStatus))
                    return "riskStatus: integer expected";
            if (message.marginCallMargin != null && message.hasOwnProperty("marginCallMargin"))
                if (typeof message.marginCallMargin !== "number")
                    return "marginCallMargin: number expected";
            if (message.isPdt != null && message.hasOwnProperty("isPdt"))
                if (typeof message.isPdt !== "boolean")
                    return "isPdt: boolean expected";
            if (message.pdtSeq != null && message.hasOwnProperty("pdtSeq"))
                if (!$util.isString(message.pdtSeq))
                    return "pdtSeq: string expected";
            if (message.beginningDTBP != null && message.hasOwnProperty("beginningDTBP"))
                if (typeof message.beginningDTBP !== "number")
                    return "beginningDTBP: number expected";
            if (message.remainingDTBP != null && message.hasOwnProperty("remainingDTBP"))
                if (typeof message.remainingDTBP !== "number")
                    return "remainingDTBP: number expected";
            if (message.dtCallAmount != null && message.hasOwnProperty("dtCallAmount"))
                if (typeof message.dtCallAmount !== "number")
                    return "dtCallAmount: number expected";
            if (message.dtStatus != null && message.hasOwnProperty("dtStatus"))
                if (!$util.isInteger(message.dtStatus))
                    return "dtStatus: integer expected";
            if (message.securitiesAssets != null && message.hasOwnProperty("securitiesAssets"))
                if (typeof message.securitiesAssets !== "number")
                    return "securitiesAssets: number expected";
            if (message.fundAssets != null && message.hasOwnProperty("fundAssets"))
                if (typeof message.fundAssets !== "number")
                    return "fundAssets: number expected";
            if (message.bondAssets != null && message.hasOwnProperty("bondAssets"))
                if (typeof message.bondAssets !== "number")
                    return "bondAssets: number expected";
            if (message.marketInfoList != null && message.hasOwnProperty("marketInfoList")) {
                if (!Array.isArray(message.marketInfoList))
                    return "marketInfoList: array expected";
                for (let i = 0; i < message.marketInfoList.length; ++i) {
                    let error = $root.common.AccMarketInfo.verify(message.marketInfoList[i]);
                    if (error)
                        return "marketInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Funds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.Funds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.Funds} Funds
         */
        Funds.fromObject = function fromObject(object) {
            if (object instanceof $root.common.Funds)
                return object;
            let message = new $root.common.Funds();
            if (object.power != null)
                message.power = Number(object.power);
            if (object.totalAssets != null)
                message.totalAssets = Number(object.totalAssets);
            if (object.cash != null)
                message.cash = Number(object.cash);
            if (object.marketVal != null)
                message.marketVal = Number(object.marketVal);
            if (object.frozenCash != null)
                message.frozenCash = Number(object.frozenCash);
            if (object.debtCash != null)
                message.debtCash = Number(object.debtCash);
            if (object.avlWithdrawalCash != null)
                message.avlWithdrawalCash = Number(object.avlWithdrawalCash);
            switch (object.currency) {
            default:
                if (typeof object.currency === "number") {
                    message.currency = object.currency;
                    break;
                }
                break;
            case "Currency_Unknown":
            case 0:
                message.currency = 0;
                break;
            case "Currency_HKD":
            case 1:
                message.currency = 1;
                break;
            case "Currency_USD":
            case 2:
                message.currency = 2;
                break;
            case "Currency_CNH":
            case 3:
                message.currency = 3;
                break;
            case "Currency_JPY":
            case 4:
                message.currency = 4;
                break;
            case "Currency_SGD":
            case 5:
                message.currency = 5;
                break;
            case "Currency_AUD":
            case 6:
                message.currency = 6;
                break;
            case "Currency_CAD":
            case 7:
                message.currency = 7;
                break;
            case "Currency_MYR":
            case 8:
                message.currency = 8;
                break;
            }
            if (object.availableFunds != null)
                message.availableFunds = Number(object.availableFunds);
            if (object.unrealizedPL != null)
                message.unrealizedPL = Number(object.unrealizedPL);
            if (object.realizedPL != null)
                message.realizedPL = Number(object.realizedPL);
            if (object.riskLevel != null)
                message.riskLevel = object.riskLevel | 0;
            if (object.initialMargin != null)
                message.initialMargin = Number(object.initialMargin);
            if (object.maintenanceMargin != null)
                message.maintenanceMargin = Number(object.maintenanceMargin);
            if (object.cashInfoList) {
                if (!Array.isArray(object.cashInfoList))
                    throw TypeError(".common.Funds.cashInfoList: array expected");
                message.cashInfoList = [];
                for (let i = 0; i < object.cashInfoList.length; ++i) {
                    if (typeof object.cashInfoList[i] !== "object")
                        throw TypeError(".common.Funds.cashInfoList: object expected");
                    message.cashInfoList[i] = $root.common.AccCashInfo.fromObject(object.cashInfoList[i]);
                }
            }
            if (object.maxPowerShort != null)
                message.maxPowerShort = Number(object.maxPowerShort);
            if (object.netCashPower != null)
                message.netCashPower = Number(object.netCashPower);
            if (object.longMv != null)
                message.longMv = Number(object.longMv);
            if (object.shortMv != null)
                message.shortMv = Number(object.shortMv);
            if (object.pendingAsset != null)
                message.pendingAsset = Number(object.pendingAsset);
            if (object.maxWithdrawal != null)
                message.maxWithdrawal = Number(object.maxWithdrawal);
            if (object.riskStatus != null)
                message.riskStatus = object.riskStatus | 0;
            if (object.marginCallMargin != null)
                message.marginCallMargin = Number(object.marginCallMargin);
            if (object.isPdt != null)
                message.isPdt = Boolean(object.isPdt);
            if (object.pdtSeq != null)
                message.pdtSeq = String(object.pdtSeq);
            if (object.beginningDTBP != null)
                message.beginningDTBP = Number(object.beginningDTBP);
            if (object.remainingDTBP != null)
                message.remainingDTBP = Number(object.remainingDTBP);
            if (object.dtCallAmount != null)
                message.dtCallAmount = Number(object.dtCallAmount);
            if (object.dtStatus != null)
                message.dtStatus = object.dtStatus | 0;
            if (object.securitiesAssets != null)
                message.securitiesAssets = Number(object.securitiesAssets);
            if (object.fundAssets != null)
                message.fundAssets = Number(object.fundAssets);
            if (object.bondAssets != null)
                message.bondAssets = Number(object.bondAssets);
            if (object.marketInfoList) {
                if (!Array.isArray(object.marketInfoList))
                    throw TypeError(".common.Funds.marketInfoList: array expected");
                message.marketInfoList = [];
                for (let i = 0; i < object.marketInfoList.length; ++i) {
                    if (typeof object.marketInfoList[i] !== "object")
                        throw TypeError(".common.Funds.marketInfoList: object expected");
                    message.marketInfoList[i] = $root.common.AccMarketInfo.fromObject(object.marketInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Funds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.Funds
         * @static
         * @param {common.Funds} message Funds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Funds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.cashInfoList = [];
                object.marketInfoList = [];
            }
            if (options.defaults) {
                object.power = 0;
                object.totalAssets = 0;
                object.cash = 0;
                object.marketVal = 0;
                object.frozenCash = 0;
                object.debtCash = 0;
                object.avlWithdrawalCash = 0;
                object.currency = options.enums === String ? "Currency_Unknown" : 0;
                object.availableFunds = 0;
                object.unrealizedPL = 0;
                object.realizedPL = 0;
                object.riskLevel = 0;
                object.initialMargin = 0;
                object.maintenanceMargin = 0;
                object.maxPowerShort = 0;
                object.netCashPower = 0;
                object.longMv = 0;
                object.shortMv = 0;
                object.pendingAsset = 0;
                object.maxWithdrawal = 0;
                object.riskStatus = 0;
                object.marginCallMargin = 0;
                object.isPdt = false;
                object.pdtSeq = "";
                object.beginningDTBP = 0;
                object.remainingDTBP = 0;
                object.dtCallAmount = 0;
                object.dtStatus = 0;
                object.securitiesAssets = 0;
                object.fundAssets = 0;
                object.bondAssets = 0;
            }
            if (message.power != null && message.hasOwnProperty("power"))
                object.power = options.json && !isFinite(message.power) ? String(message.power) : message.power;
            if (message.totalAssets != null && message.hasOwnProperty("totalAssets"))
                object.totalAssets = options.json && !isFinite(message.totalAssets) ? String(message.totalAssets) : message.totalAssets;
            if (message.cash != null && message.hasOwnProperty("cash"))
                object.cash = options.json && !isFinite(message.cash) ? String(message.cash) : message.cash;
            if (message.marketVal != null && message.hasOwnProperty("marketVal"))
                object.marketVal = options.json && !isFinite(message.marketVal) ? String(message.marketVal) : message.marketVal;
            if (message.frozenCash != null && message.hasOwnProperty("frozenCash"))
                object.frozenCash = options.json && !isFinite(message.frozenCash) ? String(message.frozenCash) : message.frozenCash;
            if (message.debtCash != null && message.hasOwnProperty("debtCash"))
                object.debtCash = options.json && !isFinite(message.debtCash) ? String(message.debtCash) : message.debtCash;
            if (message.avlWithdrawalCash != null && message.hasOwnProperty("avlWithdrawalCash"))
                object.avlWithdrawalCash = options.json && !isFinite(message.avlWithdrawalCash) ? String(message.avlWithdrawalCash) : message.avlWithdrawalCash;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = options.enums === String ? $root.common.Currency[message.currency] === undefined ? message.currency : $root.common.Currency[message.currency] : message.currency;
            if (message.availableFunds != null && message.hasOwnProperty("availableFunds"))
                object.availableFunds = options.json && !isFinite(message.availableFunds) ? String(message.availableFunds) : message.availableFunds;
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                object.unrealizedPL = options.json && !isFinite(message.unrealizedPL) ? String(message.unrealizedPL) : message.unrealizedPL;
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                object.realizedPL = options.json && !isFinite(message.realizedPL) ? String(message.realizedPL) : message.realizedPL;
            if (message.riskLevel != null && message.hasOwnProperty("riskLevel"))
                object.riskLevel = message.riskLevel;
            if (message.initialMargin != null && message.hasOwnProperty("initialMargin"))
                object.initialMargin = options.json && !isFinite(message.initialMargin) ? String(message.initialMargin) : message.initialMargin;
            if (message.maintenanceMargin != null && message.hasOwnProperty("maintenanceMargin"))
                object.maintenanceMargin = options.json && !isFinite(message.maintenanceMargin) ? String(message.maintenanceMargin) : message.maintenanceMargin;
            if (message.cashInfoList && message.cashInfoList.length) {
                object.cashInfoList = [];
                for (let j = 0; j < message.cashInfoList.length; ++j)
                    object.cashInfoList[j] = $root.common.AccCashInfo.toObject(message.cashInfoList[j], options);
            }
            if (message.maxPowerShort != null && message.hasOwnProperty("maxPowerShort"))
                object.maxPowerShort = options.json && !isFinite(message.maxPowerShort) ? String(message.maxPowerShort) : message.maxPowerShort;
            if (message.netCashPower != null && message.hasOwnProperty("netCashPower"))
                object.netCashPower = options.json && !isFinite(message.netCashPower) ? String(message.netCashPower) : message.netCashPower;
            if (message.longMv != null && message.hasOwnProperty("longMv"))
                object.longMv = options.json && !isFinite(message.longMv) ? String(message.longMv) : message.longMv;
            if (message.shortMv != null && message.hasOwnProperty("shortMv"))
                object.shortMv = options.json && !isFinite(message.shortMv) ? String(message.shortMv) : message.shortMv;
            if (message.pendingAsset != null && message.hasOwnProperty("pendingAsset"))
                object.pendingAsset = options.json && !isFinite(message.pendingAsset) ? String(message.pendingAsset) : message.pendingAsset;
            if (message.maxWithdrawal != null && message.hasOwnProperty("maxWithdrawal"))
                object.maxWithdrawal = options.json && !isFinite(message.maxWithdrawal) ? String(message.maxWithdrawal) : message.maxWithdrawal;
            if (message.riskStatus != null && message.hasOwnProperty("riskStatus"))
                object.riskStatus = message.riskStatus;
            if (message.marginCallMargin != null && message.hasOwnProperty("marginCallMargin"))
                object.marginCallMargin = options.json && !isFinite(message.marginCallMargin) ? String(message.marginCallMargin) : message.marginCallMargin;
            if (message.isPdt != null && message.hasOwnProperty("isPdt"))
                object.isPdt = message.isPdt;
            if (message.pdtSeq != null && message.hasOwnProperty("pdtSeq"))
                object.pdtSeq = message.pdtSeq;
            if (message.beginningDTBP != null && message.hasOwnProperty("beginningDTBP"))
                object.beginningDTBP = options.json && !isFinite(message.beginningDTBP) ? String(message.beginningDTBP) : message.beginningDTBP;
            if (message.remainingDTBP != null && message.hasOwnProperty("remainingDTBP"))
                object.remainingDTBP = options.json && !isFinite(message.remainingDTBP) ? String(message.remainingDTBP) : message.remainingDTBP;
            if (message.dtCallAmount != null && message.hasOwnProperty("dtCallAmount"))
                object.dtCallAmount = options.json && !isFinite(message.dtCallAmount) ? String(message.dtCallAmount) : message.dtCallAmount;
            if (message.dtStatus != null && message.hasOwnProperty("dtStatus"))
                object.dtStatus = message.dtStatus;
            if (message.securitiesAssets != null && message.hasOwnProperty("securitiesAssets"))
                object.securitiesAssets = options.json && !isFinite(message.securitiesAssets) ? String(message.securitiesAssets) : message.securitiesAssets;
            if (message.fundAssets != null && message.hasOwnProperty("fundAssets"))
                object.fundAssets = options.json && !isFinite(message.fundAssets) ? String(message.fundAssets) : message.fundAssets;
            if (message.bondAssets != null && message.hasOwnProperty("bondAssets"))
                object.bondAssets = options.json && !isFinite(message.bondAssets) ? String(message.bondAssets) : message.bondAssets;
            if (message.marketInfoList && message.marketInfoList.length) {
                object.marketInfoList = [];
                for (let j = 0; j < message.marketInfoList.length; ++j)
                    object.marketInfoList[j] = $root.common.AccMarketInfo.toObject(message.marketInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this Funds to JSON.
         * @function toJSON
         * @memberof common.Funds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Funds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Funds
         * @function getTypeUrl
         * @memberof common.Funds
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Funds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.Funds";
        };

        return Funds;
    })();

    common.AccCashInfo = (function() {

        /**
         * Properties of an AccCashInfo.
         * @memberof common
         * @interface IAccCashInfo
         * @property {common.Currency|null} [currency] AccCashInfo currency
         * @property {number|null} [cash] AccCashInfo cash
         * @property {number|null} [availableBalance] AccCashInfo availableBalance
         * @property {number|null} [netCashPower] AccCashInfo netCashPower
         */

        /**
         * Constructs a new AccCashInfo.
         * @memberof common
         * @classdesc Represents an AccCashInfo.
         * @implements IAccCashInfo
         * @constructor
         * @param {common.IAccCashInfo=} [properties] Properties to set
         */
        function AccCashInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccCashInfo currency.
         * @member {common.Currency} currency
         * @memberof common.AccCashInfo
         * @instance
         */
        AccCashInfo.prototype.currency = 0;

        /**
         * AccCashInfo cash.
         * @member {number} cash
         * @memberof common.AccCashInfo
         * @instance
         */
        AccCashInfo.prototype.cash = 0;

        /**
         * AccCashInfo availableBalance.
         * @member {number} availableBalance
         * @memberof common.AccCashInfo
         * @instance
         */
        AccCashInfo.prototype.availableBalance = 0;

        /**
         * AccCashInfo netCashPower.
         * @member {number} netCashPower
         * @memberof common.AccCashInfo
         * @instance
         */
        AccCashInfo.prototype.netCashPower = 0;

        /**
         * Creates a new AccCashInfo instance using the specified properties.
         * @function create
         * @memberof common.AccCashInfo
         * @static
         * @param {common.IAccCashInfo=} [properties] Properties to set
         * @returns {common.AccCashInfo} AccCashInfo instance
         */
        AccCashInfo.create = function create(properties) {
            return new AccCashInfo(properties);
        };

        /**
         * Encodes the specified AccCashInfo message. Does not implicitly {@link common.AccCashInfo.verify|verify} messages.
         * @function encode
         * @memberof common.AccCashInfo
         * @static
         * @param {common.IAccCashInfo} message AccCashInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccCashInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currency);
            if (message.cash != null && Object.hasOwnProperty.call(message, "cash"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.cash);
            if (message.availableBalance != null && Object.hasOwnProperty.call(message, "availableBalance"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.availableBalance);
            if (message.netCashPower != null && Object.hasOwnProperty.call(message, "netCashPower"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.netCashPower);
            return writer;
        };

        /**
         * Encodes the specified AccCashInfo message, length delimited. Does not implicitly {@link common.AccCashInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.AccCashInfo
         * @static
         * @param {common.IAccCashInfo} message AccCashInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccCashInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccCashInfo message from the specified reader or buffer.
         * @function decode
         * @memberof common.AccCashInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.AccCashInfo} AccCashInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccCashInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.AccCashInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.currency = reader.int32();
                        break;
                    }
                case 2: {
                        message.cash = reader.double();
                        break;
                    }
                case 3: {
                        message.availableBalance = reader.double();
                        break;
                    }
                case 4: {
                        message.netCashPower = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccCashInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.AccCashInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.AccCashInfo} AccCashInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccCashInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccCashInfo message.
         * @function verify
         * @memberof common.AccCashInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccCashInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                switch (message.currency) {
                default:
                    return "currency: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.cash != null && message.hasOwnProperty("cash"))
                if (typeof message.cash !== "number")
                    return "cash: number expected";
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                if (typeof message.availableBalance !== "number")
                    return "availableBalance: number expected";
            if (message.netCashPower != null && message.hasOwnProperty("netCashPower"))
                if (typeof message.netCashPower !== "number")
                    return "netCashPower: number expected";
            return null;
        };

        /**
         * Creates an AccCashInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.AccCashInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.AccCashInfo} AccCashInfo
         */
        AccCashInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.common.AccCashInfo)
                return object;
            let message = new $root.common.AccCashInfo();
            switch (object.currency) {
            default:
                if (typeof object.currency === "number") {
                    message.currency = object.currency;
                    break;
                }
                break;
            case "Currency_Unknown":
            case 0:
                message.currency = 0;
                break;
            case "Currency_HKD":
            case 1:
                message.currency = 1;
                break;
            case "Currency_USD":
            case 2:
                message.currency = 2;
                break;
            case "Currency_CNH":
            case 3:
                message.currency = 3;
                break;
            case "Currency_JPY":
            case 4:
                message.currency = 4;
                break;
            case "Currency_SGD":
            case 5:
                message.currency = 5;
                break;
            case "Currency_AUD":
            case 6:
                message.currency = 6;
                break;
            case "Currency_CAD":
            case 7:
                message.currency = 7;
                break;
            case "Currency_MYR":
            case 8:
                message.currency = 8;
                break;
            }
            if (object.cash != null)
                message.cash = Number(object.cash);
            if (object.availableBalance != null)
                message.availableBalance = Number(object.availableBalance);
            if (object.netCashPower != null)
                message.netCashPower = Number(object.netCashPower);
            return message;
        };

        /**
         * Creates a plain object from an AccCashInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.AccCashInfo
         * @static
         * @param {common.AccCashInfo} message AccCashInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccCashInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.currency = options.enums === String ? "Currency_Unknown" : 0;
                object.cash = 0;
                object.availableBalance = 0;
                object.netCashPower = 0;
            }
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = options.enums === String ? $root.common.Currency[message.currency] === undefined ? message.currency : $root.common.Currency[message.currency] : message.currency;
            if (message.cash != null && message.hasOwnProperty("cash"))
                object.cash = options.json && !isFinite(message.cash) ? String(message.cash) : message.cash;
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                object.availableBalance = options.json && !isFinite(message.availableBalance) ? String(message.availableBalance) : message.availableBalance;
            if (message.netCashPower != null && message.hasOwnProperty("netCashPower"))
                object.netCashPower = options.json && !isFinite(message.netCashPower) ? String(message.netCashPower) : message.netCashPower;
            return object;
        };

        /**
         * Converts this AccCashInfo to JSON.
         * @function toJSON
         * @memberof common.AccCashInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccCashInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccCashInfo
         * @function getTypeUrl
         * @memberof common.AccCashInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccCashInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.AccCashInfo";
        };

        return AccCashInfo;
    })();

    common.AccMarketInfo = (function() {

        /**
         * Properties of an AccMarketInfo.
         * @memberof common
         * @interface IAccMarketInfo
         * @property {common.TrdMarket|null} [trdMarket] AccMarketInfo trdMarket
         * @property {number|null} [assets] AccMarketInfo assets
         */

        /**
         * Constructs a new AccMarketInfo.
         * @memberof common
         * @classdesc Represents an AccMarketInfo.
         * @implements IAccMarketInfo
         * @constructor
         * @param {common.IAccMarketInfo=} [properties] Properties to set
         */
        function AccMarketInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccMarketInfo trdMarket.
         * @member {common.TrdMarket} trdMarket
         * @memberof common.AccMarketInfo
         * @instance
         */
        AccMarketInfo.prototype.trdMarket = 0;

        /**
         * AccMarketInfo assets.
         * @member {number} assets
         * @memberof common.AccMarketInfo
         * @instance
         */
        AccMarketInfo.prototype.assets = 0;

        /**
         * Creates a new AccMarketInfo instance using the specified properties.
         * @function create
         * @memberof common.AccMarketInfo
         * @static
         * @param {common.IAccMarketInfo=} [properties] Properties to set
         * @returns {common.AccMarketInfo} AccMarketInfo instance
         */
        AccMarketInfo.create = function create(properties) {
            return new AccMarketInfo(properties);
        };

        /**
         * Encodes the specified AccMarketInfo message. Does not implicitly {@link common.AccMarketInfo.verify|verify} messages.
         * @function encode
         * @memberof common.AccMarketInfo
         * @static
         * @param {common.IAccMarketInfo} message AccMarketInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccMarketInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trdMarket != null && Object.hasOwnProperty.call(message, "trdMarket"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdMarket);
            if (message.assets != null && Object.hasOwnProperty.call(message, "assets"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.assets);
            return writer;
        };

        /**
         * Encodes the specified AccMarketInfo message, length delimited. Does not implicitly {@link common.AccMarketInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.AccMarketInfo
         * @static
         * @param {common.IAccMarketInfo} message AccMarketInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccMarketInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccMarketInfo message from the specified reader or buffer.
         * @function decode
         * @memberof common.AccMarketInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.AccMarketInfo} AccMarketInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccMarketInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.AccMarketInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.trdMarket = reader.int32();
                        break;
                    }
                case 2: {
                        message.assets = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccMarketInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.AccMarketInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.AccMarketInfo} AccMarketInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccMarketInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccMarketInfo message.
         * @function verify
         * @memberof common.AccMarketInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccMarketInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                switch (message.trdMarket) {
                default:
                    return "trdMarket: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 8:
                case 10:
                case 11:
                case 12:
                case 13:
                case 15:
                case 111:
                case 112:
                case 113:
                case 123:
                    break;
                }
            if (message.assets != null && message.hasOwnProperty("assets"))
                if (typeof message.assets !== "number")
                    return "assets: number expected";
            return null;
        };

        /**
         * Creates an AccMarketInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.AccMarketInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.AccMarketInfo} AccMarketInfo
         */
        AccMarketInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.common.AccMarketInfo)
                return object;
            let message = new $root.common.AccMarketInfo();
            switch (object.trdMarket) {
            default:
                if (typeof object.trdMarket === "number") {
                    message.trdMarket = object.trdMarket;
                    break;
                }
                break;
            case "TrdMarket_Unknown":
            case 0:
                message.trdMarket = 0;
                break;
            case "TrdMarket_HK":
            case 1:
                message.trdMarket = 1;
                break;
            case "TrdMarket_US":
            case 2:
                message.trdMarket = 2;
                break;
            case "TrdMarket_CN":
            case 3:
                message.trdMarket = 3;
                break;
            case "TrdMarket_HKCC":
            case 4:
                message.trdMarket = 4;
                break;
            case "TrdMarket_Futures":
            case 5:
                message.trdMarket = 5;
                break;
            case "TrdMarket_SG":
            case 6:
                message.trdMarket = 6;
                break;
            case "TrdMarket_AU":
            case 8:
                message.trdMarket = 8;
                break;
            case "TrdMarket_Futures_Simulate_HK":
            case 10:
                message.trdMarket = 10;
                break;
            case "TrdMarket_Futures_Simulate_US":
            case 11:
                message.trdMarket = 11;
                break;
            case "TrdMarket_Futures_Simulate_SG":
            case 12:
                message.trdMarket = 12;
                break;
            case "TrdMarket_Futures_Simulate_JP":
            case 13:
                message.trdMarket = 13;
                break;
            case "TrdMarket_JP":
            case 15:
                message.trdMarket = 15;
                break;
            case "TrdMarket_MY":
            case 111:
                message.trdMarket = 111;
                break;
            case "TrdMarket_CA":
            case 112:
                message.trdMarket = 112;
                break;
            case "TrdMarket_HK_Fund":
            case 113:
                message.trdMarket = 113;
                break;
            case "TrdMarket_US_Fund":
            case 123:
                message.trdMarket = 123;
                break;
            }
            if (object.assets != null)
                message.assets = Number(object.assets);
            return message;
        };

        /**
         * Creates a plain object from an AccMarketInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.AccMarketInfo
         * @static
         * @param {common.AccMarketInfo} message AccMarketInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccMarketInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.trdMarket = options.enums === String ? "TrdMarket_Unknown" : 0;
                object.assets = 0;
            }
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                object.trdMarket = options.enums === String ? $root.common.TrdMarket[message.trdMarket] === undefined ? message.trdMarket : $root.common.TrdMarket[message.trdMarket] : message.trdMarket;
            if (message.assets != null && message.hasOwnProperty("assets"))
                object.assets = options.json && !isFinite(message.assets) ? String(message.assets) : message.assets;
            return object;
        };

        /**
         * Converts this AccMarketInfo to JSON.
         * @function toJSON
         * @memberof common.AccMarketInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccMarketInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccMarketInfo
         * @function getTypeUrl
         * @memberof common.AccMarketInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccMarketInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.AccMarketInfo";
        };

        return AccMarketInfo;
    })();

    /**
     * GtwEventType enum.
     * @name common.GtwEventType
     * @enum {number}
     * @property {number} GtwEventType_None=0 GtwEventType_None value
     * @property {number} GtwEventType_LocalCfgLoadFailed=1 GtwEventType_LocalCfgLoadFailed value
     * @property {number} GtwEventType_APISvrRunFailed=2 GtwEventType_APISvrRunFailed value
     * @property {number} GtwEventType_ForceUpdate=3 GtwEventType_ForceUpdate value
     * @property {number} GtwEventType_LoginFailed=4 GtwEventType_LoginFailed value
     * @property {number} GtwEventType_UnAgreeDisclaimer=5 GtwEventType_UnAgreeDisclaimer value
     * @property {number} GtwEventType_NetCfgMissing=6 GtwEventType_NetCfgMissing value
     * @property {number} GtwEventType_KickedOut=7 GtwEventType_KickedOut value
     * @property {number} GtwEventType_LoginPwdChanged=8 GtwEventType_LoginPwdChanged value
     * @property {number} GtwEventType_BanLogin=9 GtwEventType_BanLogin value
     * @property {number} GtwEventType_NeedPicVerifyCode=10 GtwEventType_NeedPicVerifyCode value
     * @property {number} GtwEventType_NeedPhoneVerifyCode=11 GtwEventType_NeedPhoneVerifyCode value
     * @property {number} GtwEventType_AppDataNotExist=12 GtwEventType_AppDataNotExist value
     * @property {number} GtwEventType_NessaryDataMissing=13 GtwEventType_NessaryDataMissing value
     * @property {number} GtwEventType_TradePwdChanged=14 GtwEventType_TradePwdChanged value
     * @property {number} GtwEventType_EnableDeviceLock=15 GtwEventType_EnableDeviceLock value
     */
    common.GtwEventType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GtwEventType_None"] = 0;
        values[valuesById[1] = "GtwEventType_LocalCfgLoadFailed"] = 1;
        values[valuesById[2] = "GtwEventType_APISvrRunFailed"] = 2;
        values[valuesById[3] = "GtwEventType_ForceUpdate"] = 3;
        values[valuesById[4] = "GtwEventType_LoginFailed"] = 4;
        values[valuesById[5] = "GtwEventType_UnAgreeDisclaimer"] = 5;
        values[valuesById[6] = "GtwEventType_NetCfgMissing"] = 6;
        values[valuesById[7] = "GtwEventType_KickedOut"] = 7;
        values[valuesById[8] = "GtwEventType_LoginPwdChanged"] = 8;
        values[valuesById[9] = "GtwEventType_BanLogin"] = 9;
        values[valuesById[10] = "GtwEventType_NeedPicVerifyCode"] = 10;
        values[valuesById[11] = "GtwEventType_NeedPhoneVerifyCode"] = 11;
        values[valuesById[12] = "GtwEventType_AppDataNotExist"] = 12;
        values[valuesById[13] = "GtwEventType_NessaryDataMissing"] = 13;
        values[valuesById[14] = "GtwEventType_TradePwdChanged"] = 14;
        values[valuesById[15] = "GtwEventType_EnableDeviceLock"] = 15;
        return values;
    })();

    common.GtwEvent = (function() {

        /**
         * Properties of a GtwEvent.
         * @memberof common
         * @interface IGtwEvent
         * @property {common.GtwEventType} eventType GtwEvent eventType
         * @property {string} desc GtwEvent desc
         */

        /**
         * Constructs a new GtwEvent.
         * @memberof common
         * @classdesc Represents a GtwEvent.
         * @implements IGtwEvent
         * @constructor
         * @param {common.IGtwEvent=} [properties] Properties to set
         */
        function GtwEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GtwEvent eventType.
         * @member {common.GtwEventType} eventType
         * @memberof common.GtwEvent
         * @instance
         */
        GtwEvent.prototype.eventType = 0;

        /**
         * GtwEvent desc.
         * @member {string} desc
         * @memberof common.GtwEvent
         * @instance
         */
        GtwEvent.prototype.desc = "";

        /**
         * Creates a new GtwEvent instance using the specified properties.
         * @function create
         * @memberof common.GtwEvent
         * @static
         * @param {common.IGtwEvent=} [properties] Properties to set
         * @returns {common.GtwEvent} GtwEvent instance
         */
        GtwEvent.create = function create(properties) {
            return new GtwEvent(properties);
        };

        /**
         * Encodes the specified GtwEvent message. Does not implicitly {@link common.GtwEvent.verify|verify} messages.
         * @function encode
         * @memberof common.GtwEvent
         * @static
         * @param {common.IGtwEvent} message GtwEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GtwEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventType);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.desc);
            return writer;
        };

        /**
         * Encodes the specified GtwEvent message, length delimited. Does not implicitly {@link common.GtwEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.GtwEvent
         * @static
         * @param {common.IGtwEvent} message GtwEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GtwEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GtwEvent message from the specified reader or buffer.
         * @function decode
         * @memberof common.GtwEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.GtwEvent} GtwEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GtwEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.GtwEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eventType = reader.int32();
                        break;
                    }
                case 2: {
                        message.desc = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("eventType"))
                throw $util.ProtocolError("missing required 'eventType'", { instance: message });
            if (!message.hasOwnProperty("desc"))
                throw $util.ProtocolError("missing required 'desc'", { instance: message });
            return message;
        };

        /**
         * Decodes a GtwEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.GtwEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.GtwEvent} GtwEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GtwEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GtwEvent message.
         * @function verify
         * @memberof common.GtwEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GtwEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.eventType) {
            default:
                return "eventType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
                break;
            }
            if (!$util.isString(message.desc))
                return "desc: string expected";
            return null;
        };

        /**
         * Creates a GtwEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.GtwEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.GtwEvent} GtwEvent
         */
        GtwEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.common.GtwEvent)
                return object;
            let message = new $root.common.GtwEvent();
            switch (object.eventType) {
            default:
                if (typeof object.eventType === "number") {
                    message.eventType = object.eventType;
                    break;
                }
                break;
            case "GtwEventType_None":
            case 0:
                message.eventType = 0;
                break;
            case "GtwEventType_LocalCfgLoadFailed":
            case 1:
                message.eventType = 1;
                break;
            case "GtwEventType_APISvrRunFailed":
            case 2:
                message.eventType = 2;
                break;
            case "GtwEventType_ForceUpdate":
            case 3:
                message.eventType = 3;
                break;
            case "GtwEventType_LoginFailed":
            case 4:
                message.eventType = 4;
                break;
            case "GtwEventType_UnAgreeDisclaimer":
            case 5:
                message.eventType = 5;
                break;
            case "GtwEventType_NetCfgMissing":
            case 6:
                message.eventType = 6;
                break;
            case "GtwEventType_KickedOut":
            case 7:
                message.eventType = 7;
                break;
            case "GtwEventType_LoginPwdChanged":
            case 8:
                message.eventType = 8;
                break;
            case "GtwEventType_BanLogin":
            case 9:
                message.eventType = 9;
                break;
            case "GtwEventType_NeedPicVerifyCode":
            case 10:
                message.eventType = 10;
                break;
            case "GtwEventType_NeedPhoneVerifyCode":
            case 11:
                message.eventType = 11;
                break;
            case "GtwEventType_AppDataNotExist":
            case 12:
                message.eventType = 12;
                break;
            case "GtwEventType_NessaryDataMissing":
            case 13:
                message.eventType = 13;
                break;
            case "GtwEventType_TradePwdChanged":
            case 14:
                message.eventType = 14;
                break;
            case "GtwEventType_EnableDeviceLock":
            case 15:
                message.eventType = 15;
                break;
            }
            if (object.desc != null)
                message.desc = String(object.desc);
            return message;
        };

        /**
         * Creates a plain object from a GtwEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.GtwEvent
         * @static
         * @param {common.GtwEvent} message GtwEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GtwEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.eventType = options.enums === String ? "GtwEventType_None" : 0;
                object.desc = "";
            }
            if (message.eventType != null && message.hasOwnProperty("eventType"))
                object.eventType = options.enums === String ? $root.common.GtwEventType[message.eventType] === undefined ? message.eventType : $root.common.GtwEventType[message.eventType] : message.eventType;
            if (message.desc != null && message.hasOwnProperty("desc"))
                object.desc = message.desc;
            return object;
        };

        /**
         * Converts this GtwEvent to JSON.
         * @function toJSON
         * @memberof common.GtwEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GtwEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GtwEvent
         * @function getTypeUrl
         * @memberof common.GtwEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GtwEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.GtwEvent";
        };

        return GtwEvent;
    })();

    /**
     * ProgramStatusType enum.
     * @name common.ProgramStatusType
     * @enum {number}
     * @property {number} ProgramStatusType_None=0 ProgramStatusType_None value
     * @property {number} ProgramStatusType_Loaded=1 ProgramStatusType_Loaded value
     * @property {number} ProgramStatusType_Loging=2 ProgramStatusType_Loging value
     * @property {number} ProgramStatusType_NeedPicVerifyCode=3 ProgramStatusType_NeedPicVerifyCode value
     * @property {number} ProgramStatusType_NeedPhoneVerifyCode=4 ProgramStatusType_NeedPhoneVerifyCode value
     * @property {number} ProgramStatusType_LoginFailed=5 ProgramStatusType_LoginFailed value
     * @property {number} ProgramStatusType_ForceUpdate=6 ProgramStatusType_ForceUpdate value
     * @property {number} ProgramStatusType_NessaryDataPreparing=7 ProgramStatusType_NessaryDataPreparing value
     * @property {number} ProgramStatusType_NessaryDataMissing=8 ProgramStatusType_NessaryDataMissing value
     * @property {number} ProgramStatusType_UnAgreeDisclaimer=9 ProgramStatusType_UnAgreeDisclaimer value
     * @property {number} ProgramStatusType_Ready=10 ProgramStatusType_Ready value
     * @property {number} ProgramStatusType_ForceLogout=11 ProgramStatusType_ForceLogout value
     * @property {number} ProgramStatusType_DisclaimerPullFailed=12 ProgramStatusType_DisclaimerPullFailed value
     */
    common.ProgramStatusType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ProgramStatusType_None"] = 0;
        values[valuesById[1] = "ProgramStatusType_Loaded"] = 1;
        values[valuesById[2] = "ProgramStatusType_Loging"] = 2;
        values[valuesById[3] = "ProgramStatusType_NeedPicVerifyCode"] = 3;
        values[valuesById[4] = "ProgramStatusType_NeedPhoneVerifyCode"] = 4;
        values[valuesById[5] = "ProgramStatusType_LoginFailed"] = 5;
        values[valuesById[6] = "ProgramStatusType_ForceUpdate"] = 6;
        values[valuesById[7] = "ProgramStatusType_NessaryDataPreparing"] = 7;
        values[valuesById[8] = "ProgramStatusType_NessaryDataMissing"] = 8;
        values[valuesById[9] = "ProgramStatusType_UnAgreeDisclaimer"] = 9;
        values[valuesById[10] = "ProgramStatusType_Ready"] = 10;
        values[valuesById[11] = "ProgramStatusType_ForceLogout"] = 11;
        values[valuesById[12] = "ProgramStatusType_DisclaimerPullFailed"] = 12;
        return values;
    })();

    common.ProgramStatus = (function() {

        /**
         * Properties of a ProgramStatus.
         * @memberof common
         * @interface IProgramStatus
         * @property {common.ProgramStatusType} type ProgramStatus type
         * @property {string|null} [strExtDesc] ProgramStatus strExtDesc
         */

        /**
         * Constructs a new ProgramStatus.
         * @memberof common
         * @classdesc Represents a ProgramStatus.
         * @implements IProgramStatus
         * @constructor
         * @param {common.IProgramStatus=} [properties] Properties to set
         */
        function ProgramStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProgramStatus type.
         * @member {common.ProgramStatusType} type
         * @memberof common.ProgramStatus
         * @instance
         */
        ProgramStatus.prototype.type = 0;

        /**
         * ProgramStatus strExtDesc.
         * @member {string} strExtDesc
         * @memberof common.ProgramStatus
         * @instance
         */
        ProgramStatus.prototype.strExtDesc = "";

        /**
         * Creates a new ProgramStatus instance using the specified properties.
         * @function create
         * @memberof common.ProgramStatus
         * @static
         * @param {common.IProgramStatus=} [properties] Properties to set
         * @returns {common.ProgramStatus} ProgramStatus instance
         */
        ProgramStatus.create = function create(properties) {
            return new ProgramStatus(properties);
        };

        /**
         * Encodes the specified ProgramStatus message. Does not implicitly {@link common.ProgramStatus.verify|verify} messages.
         * @function encode
         * @memberof common.ProgramStatus
         * @static
         * @param {common.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.strExtDesc != null && Object.hasOwnProperty.call(message, "strExtDesc"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.strExtDesc);
            return writer;
        };

        /**
         * Encodes the specified ProgramStatus message, length delimited. Does not implicitly {@link common.ProgramStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.ProgramStatus
         * @static
         * @param {common.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer.
         * @function decode
         * @memberof common.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ProgramStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.strExtDesc = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProgramStatus message.
         * @function verify
         * @memberof common.ProgramStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProgramStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
                break;
            }
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                if (!$util.isString(message.strExtDesc))
                    return "strExtDesc: string expected";
            return null;
        };

        /**
         * Creates a ProgramStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.ProgramStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.ProgramStatus} ProgramStatus
         */
        ProgramStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.common.ProgramStatus)
                return object;
            let message = new $root.common.ProgramStatus();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "ProgramStatusType_None":
            case 0:
                message.type = 0;
                break;
            case "ProgramStatusType_Loaded":
            case 1:
                message.type = 1;
                break;
            case "ProgramStatusType_Loging":
            case 2:
                message.type = 2;
                break;
            case "ProgramStatusType_NeedPicVerifyCode":
            case 3:
                message.type = 3;
                break;
            case "ProgramStatusType_NeedPhoneVerifyCode":
            case 4:
                message.type = 4;
                break;
            case "ProgramStatusType_LoginFailed":
            case 5:
                message.type = 5;
                break;
            case "ProgramStatusType_ForceUpdate":
            case 6:
                message.type = 6;
                break;
            case "ProgramStatusType_NessaryDataPreparing":
            case 7:
                message.type = 7;
                break;
            case "ProgramStatusType_NessaryDataMissing":
            case 8:
                message.type = 8;
                break;
            case "ProgramStatusType_UnAgreeDisclaimer":
            case 9:
                message.type = 9;
                break;
            case "ProgramStatusType_Ready":
            case 10:
                message.type = 10;
                break;
            case "ProgramStatusType_ForceLogout":
            case 11:
                message.type = 11;
                break;
            case "ProgramStatusType_DisclaimerPullFailed":
            case 12:
                message.type = 12;
                break;
            }
            if (object.strExtDesc != null)
                message.strExtDesc = String(object.strExtDesc);
            return message;
        };

        /**
         * Creates a plain object from a ProgramStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.ProgramStatus
         * @static
         * @param {common.ProgramStatus} message ProgramStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProgramStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "ProgramStatusType_None" : 0;
                object.strExtDesc = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.common.ProgramStatusType[message.type] === undefined ? message.type : $root.common.ProgramStatusType[message.type] : message.type;
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                object.strExtDesc = message.strExtDesc;
            return object;
        };

        /**
         * Converts this ProgramStatus to JSON.
         * @function toJSON
         * @memberof common.ProgramStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProgramStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProgramStatus
         * @function getTypeUrl
         * @memberof common.ProgramStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProgramStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.ProgramStatus";
        };

        return ProgramStatus;
    })();

    common.QotRight = (function() {

        /**
         * Properties of a QotRight.
         * @memberof common
         * @interface IQotRight
         * @property {number} hkQotRight QotRight hkQotRight
         * @property {number} usQotRight QotRight usQotRight
         * @property {number} cnQotRight QotRight cnQotRight
         * @property {number|null} [hkOptionQotRight] QotRight hkOptionQotRight
         * @property {boolean|null} [hasUSOptionQotRight] QotRight hasUSOptionQotRight
         */

        /**
         * Constructs a new QotRight.
         * @memberof common
         * @classdesc Represents a QotRight.
         * @implements IQotRight
         * @constructor
         * @param {common.IQotRight=} [properties] Properties to set
         */
        function QotRight(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QotRight hkQotRight.
         * @member {number} hkQotRight
         * @memberof common.QotRight
         * @instance
         */
        QotRight.prototype.hkQotRight = 0;

        /**
         * QotRight usQotRight.
         * @member {number} usQotRight
         * @memberof common.QotRight
         * @instance
         */
        QotRight.prototype.usQotRight = 0;

        /**
         * QotRight cnQotRight.
         * @member {number} cnQotRight
         * @memberof common.QotRight
         * @instance
         */
        QotRight.prototype.cnQotRight = 0;

        /**
         * QotRight hkOptionQotRight.
         * @member {number} hkOptionQotRight
         * @memberof common.QotRight
         * @instance
         */
        QotRight.prototype.hkOptionQotRight = 0;

        /**
         * QotRight hasUSOptionQotRight.
         * @member {boolean} hasUSOptionQotRight
         * @memberof common.QotRight
         * @instance
         */
        QotRight.prototype.hasUSOptionQotRight = false;

        /**
         * Creates a new QotRight instance using the specified properties.
         * @function create
         * @memberof common.QotRight
         * @static
         * @param {common.IQotRight=} [properties] Properties to set
         * @returns {common.QotRight} QotRight instance
         */
        QotRight.create = function create(properties) {
            return new QotRight(properties);
        };

        /**
         * Encodes the specified QotRight message. Does not implicitly {@link common.QotRight.verify|verify} messages.
         * @function encode
         * @memberof common.QotRight
         * @static
         * @param {common.IQotRight} message QotRight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QotRight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hkQotRight);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.usQotRight);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cnQotRight);
            if (message.hkOptionQotRight != null && Object.hasOwnProperty.call(message, "hkOptionQotRight"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.hkOptionQotRight);
            if (message.hasUSOptionQotRight != null && Object.hasOwnProperty.call(message, "hasUSOptionQotRight"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasUSOptionQotRight);
            return writer;
        };

        /**
         * Encodes the specified QotRight message, length delimited. Does not implicitly {@link common.QotRight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.QotRight
         * @static
         * @param {common.IQotRight} message QotRight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QotRight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QotRight message from the specified reader or buffer.
         * @function decode
         * @memberof common.QotRight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.QotRight} QotRight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QotRight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.QotRight();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4: {
                        message.hkQotRight = reader.int32();
                        break;
                    }
                case 5: {
                        message.usQotRight = reader.int32();
                        break;
                    }
                case 6: {
                        message.cnQotRight = reader.int32();
                        break;
                    }
                case 7: {
                        message.hkOptionQotRight = reader.int32();
                        break;
                    }
                case 8: {
                        message.hasUSOptionQotRight = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("hkQotRight"))
                throw $util.ProtocolError("missing required 'hkQotRight'", { instance: message });
            if (!message.hasOwnProperty("usQotRight"))
                throw $util.ProtocolError("missing required 'usQotRight'", { instance: message });
            if (!message.hasOwnProperty("cnQotRight"))
                throw $util.ProtocolError("missing required 'cnQotRight'", { instance: message });
            return message;
        };

        /**
         * Decodes a QotRight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.QotRight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.QotRight} QotRight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QotRight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QotRight message.
         * @function verify
         * @memberof common.QotRight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QotRight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.hkQotRight))
                return "hkQotRight: integer expected";
            if (!$util.isInteger(message.usQotRight))
                return "usQotRight: integer expected";
            if (!$util.isInteger(message.cnQotRight))
                return "cnQotRight: integer expected";
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                if (!$util.isInteger(message.hkOptionQotRight))
                    return "hkOptionQotRight: integer expected";
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                if (typeof message.hasUSOptionQotRight !== "boolean")
                    return "hasUSOptionQotRight: boolean expected";
            return null;
        };

        /**
         * Creates a QotRight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.QotRight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.QotRight} QotRight
         */
        QotRight.fromObject = function fromObject(object) {
            if (object instanceof $root.common.QotRight)
                return object;
            let message = new $root.common.QotRight();
            if (object.hkQotRight != null)
                message.hkQotRight = object.hkQotRight | 0;
            if (object.usQotRight != null)
                message.usQotRight = object.usQotRight | 0;
            if (object.cnQotRight != null)
                message.cnQotRight = object.cnQotRight | 0;
            if (object.hkOptionQotRight != null)
                message.hkOptionQotRight = object.hkOptionQotRight | 0;
            if (object.hasUSOptionQotRight != null)
                message.hasUSOptionQotRight = Boolean(object.hasUSOptionQotRight);
            return message;
        };

        /**
         * Creates a plain object from a QotRight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.QotRight
         * @static
         * @param {common.QotRight} message QotRight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QotRight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.hkQotRight = 0;
                object.usQotRight = 0;
                object.cnQotRight = 0;
                object.hkOptionQotRight = 0;
                object.hasUSOptionQotRight = false;
            }
            if (message.hkQotRight != null && message.hasOwnProperty("hkQotRight"))
                object.hkQotRight = message.hkQotRight;
            if (message.usQotRight != null && message.hasOwnProperty("usQotRight"))
                object.usQotRight = message.usQotRight;
            if (message.cnQotRight != null && message.hasOwnProperty("cnQotRight"))
                object.cnQotRight = message.cnQotRight;
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                object.hkOptionQotRight = message.hkOptionQotRight;
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                object.hasUSOptionQotRight = message.hasUSOptionQotRight;
            return object;
        };

        /**
         * Converts this QotRight to JSON.
         * @function toJSON
         * @memberof common.QotRight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QotRight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QotRight
         * @function getTypeUrl
         * @memberof common.QotRight
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QotRight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.QotRight";
        };

        return QotRight;
    })();

    common.APILevel = (function() {

        /**
         * Properties of a APILevel.
         * @memberof common
         * @interface IAPILevel
         * @property {string} apiLevel APILevel apiLevel
         */

        /**
         * Constructs a new APILevel.
         * @memberof common
         * @classdesc Represents a APILevel.
         * @implements IAPILevel
         * @constructor
         * @param {common.IAPILevel=} [properties] Properties to set
         */
        function APILevel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * APILevel apiLevel.
         * @member {string} apiLevel
         * @memberof common.APILevel
         * @instance
         */
        APILevel.prototype.apiLevel = "";

        /**
         * Creates a new APILevel instance using the specified properties.
         * @function create
         * @memberof common.APILevel
         * @static
         * @param {common.IAPILevel=} [properties] Properties to set
         * @returns {common.APILevel} APILevel instance
         */
        APILevel.create = function create(properties) {
            return new APILevel(properties);
        };

        /**
         * Encodes the specified APILevel message. Does not implicitly {@link common.APILevel.verify|verify} messages.
         * @function encode
         * @memberof common.APILevel
         * @static
         * @param {common.IAPILevel} message APILevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APILevel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.apiLevel);
            return writer;
        };

        /**
         * Encodes the specified APILevel message, length delimited. Does not implicitly {@link common.APILevel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.APILevel
         * @static
         * @param {common.IAPILevel} message APILevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APILevel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a APILevel message from the specified reader or buffer.
         * @function decode
         * @memberof common.APILevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.APILevel} APILevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APILevel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.APILevel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.apiLevel = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("apiLevel"))
                throw $util.ProtocolError("missing required 'apiLevel'", { instance: message });
            return message;
        };

        /**
         * Decodes a APILevel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.APILevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.APILevel} APILevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APILevel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a APILevel message.
         * @function verify
         * @memberof common.APILevel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        APILevel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.apiLevel))
                return "apiLevel: string expected";
            return null;
        };

        /**
         * Creates a APILevel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.APILevel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.APILevel} APILevel
         */
        APILevel.fromObject = function fromObject(object) {
            if (object instanceof $root.common.APILevel)
                return object;
            let message = new $root.common.APILevel();
            if (object.apiLevel != null)
                message.apiLevel = String(object.apiLevel);
            return message;
        };

        /**
         * Creates a plain object from a APILevel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.APILevel
         * @static
         * @param {common.APILevel} message APILevel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        APILevel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.apiLevel = "";
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                object.apiLevel = message.apiLevel;
            return object;
        };

        /**
         * Converts this APILevel to JSON.
         * @function toJSON
         * @memberof common.APILevel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        APILevel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for APILevel
         * @function getTypeUrl
         * @memberof common.APILevel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        APILevel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.APILevel";
        };

        return APILevel;
    })();

    common.ConnectStatus = (function() {

        /**
         * Properties of a ConnectStatus.
         * @memberof common
         * @interface IConnectStatus
         * @property {boolean} qotLogined ConnectStatus qotLogined
         * @property {boolean} trdLogined ConnectStatus trdLogined
         */

        /**
         * Constructs a new ConnectStatus.
         * @memberof common
         * @classdesc Represents a ConnectStatus.
         * @implements IConnectStatus
         * @constructor
         * @param {common.IConnectStatus=} [properties] Properties to set
         */
        function ConnectStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectStatus qotLogined.
         * @member {boolean} qotLogined
         * @memberof common.ConnectStatus
         * @instance
         */
        ConnectStatus.prototype.qotLogined = false;

        /**
         * ConnectStatus trdLogined.
         * @member {boolean} trdLogined
         * @memberof common.ConnectStatus
         * @instance
         */
        ConnectStatus.prototype.trdLogined = false;

        /**
         * Creates a new ConnectStatus instance using the specified properties.
         * @function create
         * @memberof common.ConnectStatus
         * @static
         * @param {common.IConnectStatus=} [properties] Properties to set
         * @returns {common.ConnectStatus} ConnectStatus instance
         */
        ConnectStatus.create = function create(properties) {
            return new ConnectStatus(properties);
        };

        /**
         * Encodes the specified ConnectStatus message. Does not implicitly {@link common.ConnectStatus.verify|verify} messages.
         * @function encode
         * @memberof common.ConnectStatus
         * @static
         * @param {common.IConnectStatus} message ConnectStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.qotLogined);
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.trdLogined);
            return writer;
        };

        /**
         * Encodes the specified ConnectStatus message, length delimited. Does not implicitly {@link common.ConnectStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.ConnectStatus
         * @static
         * @param {common.IConnectStatus} message ConnectStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectStatus message from the specified reader or buffer.
         * @function decode
         * @memberof common.ConnectStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.ConnectStatus} ConnectStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConnectStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.qotLogined = reader.bool();
                        break;
                    }
                case 2: {
                        message.trdLogined = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("qotLogined"))
                throw $util.ProtocolError("missing required 'qotLogined'", { instance: message });
            if (!message.hasOwnProperty("trdLogined"))
                throw $util.ProtocolError("missing required 'trdLogined'", { instance: message });
            return message;
        };

        /**
         * Decodes a ConnectStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.ConnectStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.ConnectStatus} ConnectStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectStatus message.
         * @function verify
         * @memberof common.ConnectStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.qotLogined !== "boolean")
                return "qotLogined: boolean expected";
            if (typeof message.trdLogined !== "boolean")
                return "trdLogined: boolean expected";
            return null;
        };

        /**
         * Creates a ConnectStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.ConnectStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.ConnectStatus} ConnectStatus
         */
        ConnectStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.common.ConnectStatus)
                return object;
            let message = new $root.common.ConnectStatus();
            if (object.qotLogined != null)
                message.qotLogined = Boolean(object.qotLogined);
            if (object.trdLogined != null)
                message.trdLogined = Boolean(object.trdLogined);
            return message;
        };

        /**
         * Creates a plain object from a ConnectStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.ConnectStatus
         * @static
         * @param {common.ConnectStatus} message ConnectStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.qotLogined = false;
                object.trdLogined = false;
            }
            if (message.qotLogined != null && message.hasOwnProperty("qotLogined"))
                object.qotLogined = message.qotLogined;
            if (message.trdLogined != null && message.hasOwnProperty("trdLogined"))
                object.trdLogined = message.trdLogined;
            return object;
        };

        /**
         * Converts this ConnectStatus to JSON.
         * @function toJSON
         * @memberof common.ConnectStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ConnectStatus
         * @function getTypeUrl
         * @memberof common.ConnectStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConnectStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.ConnectStatus";
        };

        return ConnectStatus;
    })();

    common.APIQuota = (function() {

        /**
         * Properties of a APIQuota.
         * @memberof common
         * @interface IAPIQuota
         * @property {number} subQuota APIQuota subQuota
         * @property {number} historyKLQuota APIQuota historyKLQuota
         */

        /**
         * Constructs a new APIQuota.
         * @memberof common
         * @classdesc Represents a APIQuota.
         * @implements IAPIQuota
         * @constructor
         * @param {common.IAPIQuota=} [properties] Properties to set
         */
        function APIQuota(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * APIQuota subQuota.
         * @member {number} subQuota
         * @memberof common.APIQuota
         * @instance
         */
        APIQuota.prototype.subQuota = 0;

        /**
         * APIQuota historyKLQuota.
         * @member {number} historyKLQuota
         * @memberof common.APIQuota
         * @instance
         */
        APIQuota.prototype.historyKLQuota = 0;

        /**
         * Creates a new APIQuota instance using the specified properties.
         * @function create
         * @memberof common.APIQuota
         * @static
         * @param {common.IAPIQuota=} [properties] Properties to set
         * @returns {common.APIQuota} APIQuota instance
         */
        APIQuota.create = function create(properties) {
            return new APIQuota(properties);
        };

        /**
         * Encodes the specified APIQuota message. Does not implicitly {@link common.APIQuota.verify|verify} messages.
         * @function encode
         * @memberof common.APIQuota
         * @static
         * @param {common.IAPIQuota} message APIQuota message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIQuota.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subQuota);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.historyKLQuota);
            return writer;
        };

        /**
         * Encodes the specified APIQuota message, length delimited. Does not implicitly {@link common.APIQuota.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.APIQuota
         * @static
         * @param {common.IAPIQuota} message APIQuota message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIQuota.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a APIQuota message from the specified reader or buffer.
         * @function decode
         * @memberof common.APIQuota
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.APIQuota} APIQuota
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIQuota.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.APIQuota();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.subQuota = reader.int32();
                        break;
                    }
                case 2: {
                        message.historyKLQuota = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("subQuota"))
                throw $util.ProtocolError("missing required 'subQuota'", { instance: message });
            if (!message.hasOwnProperty("historyKLQuota"))
                throw $util.ProtocolError("missing required 'historyKLQuota'", { instance: message });
            return message;
        };

        /**
         * Decodes a APIQuota message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.APIQuota
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.APIQuota} APIQuota
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIQuota.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a APIQuota message.
         * @function verify
         * @memberof common.APIQuota
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        APIQuota.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.subQuota))
                return "subQuota: integer expected";
            if (!$util.isInteger(message.historyKLQuota))
                return "historyKLQuota: integer expected";
            return null;
        };

        /**
         * Creates a APIQuota message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.APIQuota
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.APIQuota} APIQuota
         */
        APIQuota.fromObject = function fromObject(object) {
            if (object instanceof $root.common.APIQuota)
                return object;
            let message = new $root.common.APIQuota();
            if (object.subQuota != null)
                message.subQuota = object.subQuota | 0;
            if (object.historyKLQuota != null)
                message.historyKLQuota = object.historyKLQuota | 0;
            return message;
        };

        /**
         * Creates a plain object from a APIQuota message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.APIQuota
         * @static
         * @param {common.APIQuota} message APIQuota
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        APIQuota.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.subQuota = 0;
                object.historyKLQuota = 0;
            }
            if (message.subQuota != null && message.hasOwnProperty("subQuota"))
                object.subQuota = message.subQuota;
            if (message.historyKLQuota != null && message.hasOwnProperty("historyKLQuota"))
                object.historyKLQuota = message.historyKLQuota;
            return object;
        };

        /**
         * Converts this APIQuota to JSON.
         * @function toJSON
         * @memberof common.APIQuota
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        APIQuota.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for APIQuota
         * @function getTypeUrl
         * @memberof common.APIQuota
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        APIQuota.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.APIQuota";
        };

        return APIQuota;
    })();

    common.Security = (function() {

        /**
         * Properties of a Security.
         * @memberof common
         * @interface ISecurity
         * @property {common.QotMarket} market QotMarket，行情市场
         * @property {string} code 股票代码
         */

        /**
         * Constructs a new Security.
         * @memberof common
         * @classdesc 证券标识
         * @implements ISecurity
         * @constructor
         * @param {common.ISecurity=} [properties] Properties to set
         */
        function Security(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QotMarket，行情市场
         * @member {common.QotMarket} market
         * @memberof common.Security
         * @instance
         */
        Security.prototype.market = 0;

        /**
         * 股票代码
         * @member {string} code
         * @memberof common.Security
         * @instance
         */
        Security.prototype.code = "";

        /**
         * Creates a new Security instance using the specified properties.
         * @function create
         * @memberof common.Security
         * @static
         * @param {common.ISecurity=} [properties] Properties to set
         * @returns {common.Security} Security instance
         */
        Security.create = function create(properties) {
            return new Security(properties);
        };

        /**
         * Encodes the specified Security message. Does not implicitly {@link common.Security.verify|verify} messages.
         * @function encode
         * @memberof common.Security
         * @static
         * @param {common.ISecurity} message Security message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Security.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
            return writer;
        };

        /**
         * Encodes the specified Security message, length delimited. Does not implicitly {@link common.Security.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.Security
         * @static
         * @param {common.ISecurity} message Security message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Security.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Security message from the specified reader or buffer.
         * @function decode
         * @memberof common.Security
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.Security} Security
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Security.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Security();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.market = reader.int32();
                        break;
                    }
                case 2: {
                        message.code = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            return message;
        };

        /**
         * Decodes a Security message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.Security
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.Security} Security
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Security.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Security message.
         * @function verify
         * @memberof common.Security
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Security.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.market) {
            default:
                return "market: enum value expected";
            case 0:
            case 1:
            case 2:
            case 11:
            case 21:
            case 22:
            case 31:
            case 41:
            case 51:
            case 61:
            case 71:
            case 81:
                break;
            }
            if (!$util.isString(message.code))
                return "code: string expected";
            return null;
        };

        /**
         * Creates a Security message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.Security
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.Security} Security
         */
        Security.fromObject = function fromObject(object) {
            if (object instanceof $root.common.Security)
                return object;
            let message = new $root.common.Security();
            switch (object.market) {
            default:
                if (typeof object.market === "number") {
                    message.market = object.market;
                    break;
                }
                break;
            case "QotMarket_Unknown":
            case 0:
                message.market = 0;
                break;
            case "QotMarket_HK_Security":
            case 1:
                message.market = 1;
                break;
            case "QotMarket_HK_Future":
            case 2:
                message.market = 2;
                break;
            case "QotMarket_US_Security":
            case 11:
                message.market = 11;
                break;
            case "QotMarket_CNSH_Security":
            case 21:
                message.market = 21;
                break;
            case "QotMarket_CNSZ_Security":
            case 22:
                message.market = 22;
                break;
            case "QotMarket_SG_Security":
            case 31:
                message.market = 31;
                break;
            case "QotMarket_JP_Security":
            case 41:
                message.market = 41;
                break;
            case "QotMarket_AU_Security":
            case 51:
                message.market = 51;
                break;
            case "QotMarket_MY_Security":
            case 61:
                message.market = 61;
                break;
            case "QotMarket_CA_Security":
            case 71:
                message.market = 71;
                break;
            case "QotMarket_FX_Security":
            case 81:
                message.market = 81;
                break;
            }
            if (object.code != null)
                message.code = String(object.code);
            return message;
        };

        /**
         * Creates a plain object from a Security message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.Security
         * @static
         * @param {common.Security} message Security
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Security.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.market = options.enums === String ? "QotMarket_Unknown" : 0;
                object.code = "";
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = options.enums === String ? $root.common.QotMarket[message.market] === undefined ? message.market : $root.common.QotMarket[message.market] : message.market;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            return object;
        };

        /**
         * Converts this Security to JSON.
         * @function toJSON
         * @memberof common.Security
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Security.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Security
         * @function getTypeUrl
         * @memberof common.Security
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Security.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.Security";
        };

        return Security;
    })();

    /**
     * 行情市场
     * @name common.QotMarket
     * @enum {number}
     * @property {number} QotMarket_Unknown=0 QotMarket_Unknown value
     * @property {number} QotMarket_HK_Security=1 QotMarket_HK_Security value
     * @property {number} QotMarket_HK_Future=2 QotMarket_HK_Future value
     * @property {number} QotMarket_US_Security=11 QotMarket_US_Security value
     * @property {number} QotMarket_CNSH_Security=21 QotMarket_CNSH_Security value
     * @property {number} QotMarket_CNSZ_Security=22 QotMarket_CNSZ_Security value
     * @property {number} QotMarket_SG_Security=31 QotMarket_SG_Security value
     * @property {number} QotMarket_JP_Security=41 QotMarket_JP_Security value
     * @property {number} QotMarket_AU_Security=51 QotMarket_AU_Security value
     * @property {number} QotMarket_MY_Security=61 QotMarket_MY_Security value
     * @property {number} QotMarket_CA_Security=71 QotMarket_CA_Security value
     * @property {number} QotMarket_FX_Security=81 QotMarket_FX_Security value
     */
    common.QotMarket = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotMarket_Unknown"] = 0;
        values[valuesById[1] = "QotMarket_HK_Security"] = 1;
        values[valuesById[2] = "QotMarket_HK_Future"] = 2;
        values[valuesById[11] = "QotMarket_US_Security"] = 11;
        values[valuesById[21] = "QotMarket_CNSH_Security"] = 21;
        values[valuesById[22] = "QotMarket_CNSZ_Security"] = 22;
        values[valuesById[31] = "QotMarket_SG_Security"] = 31;
        values[valuesById[41] = "QotMarket_JP_Security"] = 41;
        values[valuesById[51] = "QotMarket_AU_Security"] = 51;
        values[valuesById[61] = "QotMarket_MY_Security"] = 61;
        values[valuesById[71] = "QotMarket_CA_Security"] = 71;
        values[valuesById[81] = "QotMarket_FX_Security"] = 81;
        return values;
    })();

    /**
     * SubType enum.
     * @name common.SubType
     * @enum {number}
     * @property {number} SubType_None=0 SubType_None value
     * @property {number} SubType_Basic=1 SubType_Basic value
     * @property {number} SubType_OrderBook=2 SubType_OrderBook value
     * @property {number} SubType_Ticker=4 SubType_Ticker value
     * @property {number} SubType_RT=5 SubType_RT value
     * @property {number} SubType_KL_Day=6 SubType_KL_Day value
     * @property {number} SubType_KL_5Min=7 SubType_KL_5Min value
     * @property {number} SubType_KL_15Min=8 SubType_KL_15Min value
     * @property {number} SubType_KL_30Min=9 SubType_KL_30Min value
     * @property {number} SubType_KL_60Min=10 SubType_KL_60Min value
     * @property {number} SubType_KL_1Min=11 SubType_KL_1Min value
     * @property {number} SubType_KL_Week=12 SubType_KL_Week value
     * @property {number} SubType_KL_Month=13 SubType_KL_Month value
     * @property {number} SubType_Broker=14 SubType_Broker value
     * @property {number} SubType_KL_Qurater=15 SubType_KL_Qurater value
     * @property {number} SubType_KL_Year=16 SubType_KL_Year value
     * @property {number} SubType_KL_3Min=17 SubType_KL_3Min value
     */
    common.SubType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SubType_None"] = 0;
        values[valuesById[1] = "SubType_Basic"] = 1;
        values[valuesById[2] = "SubType_OrderBook"] = 2;
        values[valuesById[4] = "SubType_Ticker"] = 4;
        values[valuesById[5] = "SubType_RT"] = 5;
        values[valuesById[6] = "SubType_KL_Day"] = 6;
        values[valuesById[7] = "SubType_KL_5Min"] = 7;
        values[valuesById[8] = "SubType_KL_15Min"] = 8;
        values[valuesById[9] = "SubType_KL_30Min"] = 9;
        values[valuesById[10] = "SubType_KL_60Min"] = 10;
        values[valuesById[11] = "SubType_KL_1Min"] = 11;
        values[valuesById[12] = "SubType_KL_Week"] = 12;
        values[valuesById[13] = "SubType_KL_Month"] = 13;
        values[valuesById[14] = "SubType_Broker"] = 14;
        values[valuesById[15] = "SubType_KL_Qurater"] = 15;
        values[valuesById[16] = "SubType_KL_Year"] = 16;
        values[valuesById[17] = "SubType_KL_3Min"] = 17;
        return values;
    })();

    common.FutureBasicQotExData = (function() {

        /**
         * Properties of a FutureBasicQotExData.
         * @memberof common
         * @interface IFutureBasicQotExData
         * @property {number} lastSettlePrice FutureBasicQotExData lastSettlePrice
         * @property {number} position FutureBasicQotExData position
         * @property {number} positionChange FutureBasicQotExData positionChange
         * @property {number|null} [expiryDateDistance] FutureBasicQotExData expiryDateDistance
         */

        /**
         * Constructs a new FutureBasicQotExData.
         * @memberof common
         * @classdesc Represents a FutureBasicQotExData.
         * @implements IFutureBasicQotExData
         * @constructor
         * @param {common.IFutureBasicQotExData=} [properties] Properties to set
         */
        function FutureBasicQotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FutureBasicQotExData lastSettlePrice.
         * @member {number} lastSettlePrice
         * @memberof common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.lastSettlePrice = 0;

        /**
         * FutureBasicQotExData position.
         * @member {number} position
         * @memberof common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.position = 0;

        /**
         * FutureBasicQotExData positionChange.
         * @member {number} positionChange
         * @memberof common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.positionChange = 0;

        /**
         * FutureBasicQotExData expiryDateDistance.
         * @member {number} expiryDateDistance
         * @memberof common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.expiryDateDistance = 0;

        /**
         * Creates a new FutureBasicQotExData instance using the specified properties.
         * @function create
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {common.IFutureBasicQotExData=} [properties] Properties to set
         * @returns {common.FutureBasicQotExData} FutureBasicQotExData instance
         */
        FutureBasicQotExData.create = function create(properties) {
            return new FutureBasicQotExData(properties);
        };

        /**
         * Encodes the specified FutureBasicQotExData message. Does not implicitly {@link common.FutureBasicQotExData.verify|verify} messages.
         * @function encode
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {common.IFutureBasicQotExData} message FutureBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureBasicQotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.lastSettlePrice);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.position);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.positionChange);
            if (message.expiryDateDistance != null && Object.hasOwnProperty.call(message, "expiryDateDistance"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.expiryDateDistance);
            return writer;
        };

        /**
         * Encodes the specified FutureBasicQotExData message, length delimited. Does not implicitly {@link common.FutureBasicQotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {common.IFutureBasicQotExData} message FutureBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureBasicQotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FutureBasicQotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.FutureBasicQotExData} FutureBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureBasicQotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.FutureBasicQotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lastSettlePrice = reader.double();
                        break;
                    }
                case 2: {
                        message.position = reader.int32();
                        break;
                    }
                case 3: {
                        message.positionChange = reader.int32();
                        break;
                    }
                case 4: {
                        message.expiryDateDistance = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastSettlePrice"))
                throw $util.ProtocolError("missing required 'lastSettlePrice'", { instance: message });
            if (!message.hasOwnProperty("position"))
                throw $util.ProtocolError("missing required 'position'", { instance: message });
            if (!message.hasOwnProperty("positionChange"))
                throw $util.ProtocolError("missing required 'positionChange'", { instance: message });
            return message;
        };

        /**
         * Decodes a FutureBasicQotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.FutureBasicQotExData} FutureBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureBasicQotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FutureBasicQotExData message.
         * @function verify
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FutureBasicQotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.lastSettlePrice !== "number")
                return "lastSettlePrice: number expected";
            if (!$util.isInteger(message.position))
                return "position: integer expected";
            if (!$util.isInteger(message.positionChange))
                return "positionChange: integer expected";
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                if (!$util.isInteger(message.expiryDateDistance))
                    return "expiryDateDistance: integer expected";
            return null;
        };

        /**
         * Creates a FutureBasicQotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.FutureBasicQotExData} FutureBasicQotExData
         */
        FutureBasicQotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.FutureBasicQotExData)
                return object;
            let message = new $root.common.FutureBasicQotExData();
            if (object.lastSettlePrice != null)
                message.lastSettlePrice = Number(object.lastSettlePrice);
            if (object.position != null)
                message.position = object.position | 0;
            if (object.positionChange != null)
                message.positionChange = object.positionChange | 0;
            if (object.expiryDateDistance != null)
                message.expiryDateDistance = object.expiryDateDistance | 0;
            return message;
        };

        /**
         * Creates a plain object from a FutureBasicQotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {common.FutureBasicQotExData} message FutureBasicQotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FutureBasicQotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.lastSettlePrice = 0;
                object.position = 0;
                object.positionChange = 0;
                object.expiryDateDistance = 0;
            }
            if (message.lastSettlePrice != null && message.hasOwnProperty("lastSettlePrice"))
                object.lastSettlePrice = options.json && !isFinite(message.lastSettlePrice) ? String(message.lastSettlePrice) : message.lastSettlePrice;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.positionChange != null && message.hasOwnProperty("positionChange"))
                object.positionChange = message.positionChange;
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                object.expiryDateDistance = message.expiryDateDistance;
            return object;
        };

        /**
         * Converts this FutureBasicQotExData to JSON.
         * @function toJSON
         * @memberof common.FutureBasicQotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FutureBasicQotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FutureBasicQotExData
         * @function getTypeUrl
         * @memberof common.FutureBasicQotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FutureBasicQotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.FutureBasicQotExData";
        };

        return FutureBasicQotExData;
    })();

    common.WarrantBasicQotExData = (function() {

        /**
         * Properties of a WarrantBasicQotExData.
         * @memberof common
         * @interface IWarrantBasicQotExData
         * @property {number|null} [delta] WarrantBasicQotExData delta
         * @property {number|null} [impliedVolatility] WarrantBasicQotExData impliedVolatility
         * @property {number} premium WarrantBasicQotExData premium
         */

        /**
         * Constructs a new WarrantBasicQotExData.
         * @memberof common
         * @classdesc Represents a WarrantBasicQotExData.
         * @implements IWarrantBasicQotExData
         * @constructor
         * @param {common.IWarrantBasicQotExData=} [properties] Properties to set
         */
        function WarrantBasicQotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantBasicQotExData delta.
         * @member {number} delta
         * @memberof common.WarrantBasicQotExData
         * @instance
         */
        WarrantBasicQotExData.prototype.delta = 0;

        /**
         * WarrantBasicQotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof common.WarrantBasicQotExData
         * @instance
         */
        WarrantBasicQotExData.prototype.impliedVolatility = 0;

        /**
         * WarrantBasicQotExData premium.
         * @member {number} premium
         * @memberof common.WarrantBasicQotExData
         * @instance
         */
        WarrantBasicQotExData.prototype.premium = 0;

        /**
         * Creates a new WarrantBasicQotExData instance using the specified properties.
         * @function create
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {common.IWarrantBasicQotExData=} [properties] Properties to set
         * @returns {common.WarrantBasicQotExData} WarrantBasicQotExData instance
         */
        WarrantBasicQotExData.create = function create(properties) {
            return new WarrantBasicQotExData(properties);
        };

        /**
         * Encodes the specified WarrantBasicQotExData message. Does not implicitly {@link common.WarrantBasicQotExData.verify|verify} messages.
         * @function encode
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {common.IWarrantBasicQotExData} message WarrantBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantBasicQotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.delta != null && Object.hasOwnProperty.call(message, "delta"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.delta);
            if (message.impliedVolatility != null && Object.hasOwnProperty.call(message, "impliedVolatility"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.impliedVolatility);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.premium);
            return writer;
        };

        /**
         * Encodes the specified WarrantBasicQotExData message, length delimited. Does not implicitly {@link common.WarrantBasicQotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {common.IWarrantBasicQotExData} message WarrantBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantBasicQotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantBasicQotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.WarrantBasicQotExData} WarrantBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantBasicQotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.WarrantBasicQotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.delta = reader.double();
                        break;
                    }
                case 2: {
                        message.impliedVolatility = reader.double();
                        break;
                    }
                case 3: {
                        message.premium = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantBasicQotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.WarrantBasicQotExData} WarrantBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantBasicQotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantBasicQotExData message.
         * @function verify
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantBasicQotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delta != null && message.hasOwnProperty("delta"))
                if (typeof message.delta !== "number")
                    return "delta: number expected";
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                if (typeof message.impliedVolatility !== "number")
                    return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            return null;
        };

        /**
         * Creates a WarrantBasicQotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.WarrantBasicQotExData} WarrantBasicQotExData
         */
        WarrantBasicQotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.WarrantBasicQotExData)
                return object;
            let message = new $root.common.WarrantBasicQotExData();
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            return message;
        };

        /**
         * Creates a plain object from a WarrantBasicQotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {common.WarrantBasicQotExData} message WarrantBasicQotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantBasicQotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.delta = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
            }
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            return object;
        };

        /**
         * Converts this WarrantBasicQotExData to JSON.
         * @function toJSON
         * @memberof common.WarrantBasicQotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantBasicQotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WarrantBasicQotExData
         * @function getTypeUrl
         * @memberof common.WarrantBasicQotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WarrantBasicQotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.WarrantBasicQotExData";
        };

        return WarrantBasicQotExData;
    })();

    common.BasicQot = (function() {

        /**
         * Properties of a BasicQot.
         * @memberof common
         * @interface IBasicQot
         * @property {common.ISecurity} security BasicQot security
         * @property {string|null} [name] BasicQot name
         * @property {boolean} isSuspended BasicQot isSuspended
         * @property {string} listTime BasicQot listTime
         * @property {number} priceSpread BasicQot priceSpread
         * @property {string} updateTime BasicQot updateTime
         * @property {number} highPrice BasicQot highPrice
         * @property {number} openPrice BasicQot openPrice
         * @property {number} lowPrice BasicQot lowPrice
         * @property {number} curPrice BasicQot curPrice
         * @property {number} lastClosePrice BasicQot lastClosePrice
         * @property {number|Long} volume BasicQot volume
         * @property {number} turnover BasicQot turnover
         * @property {number} turnoverRate BasicQot turnoverRate
         * @property {number} amplitude BasicQot amplitude
         * @property {number|null} [darkStatus] BasicQot darkStatus
         * @property {common.IOptionBasicQotExData|null} [optionExData] BasicQot optionExData
         * @property {number|null} [listTimestamp] BasicQot listTimestamp
         * @property {number|null} [updateTimestamp] BasicQot updateTimestamp
         * @property {common.IPreAfterMarketData|null} [preMarket] BasicQot preMarket
         * @property {common.IPreAfterMarketData|null} [afterMarket] BasicQot afterMarket
         * @property {number|null} [secStatus] BasicQot secStatus
         * @property {common.IFutureBasicQotExData|null} [futureExData] BasicQot futureExData
         * @property {common.IWarrantBasicQotExData|null} [warrantExData] BasicQot warrantExData
         */

        /**
         * Constructs a new BasicQot.
         * @memberof common
         * @classdesc Represents a BasicQot.
         * @implements IBasicQot
         * @constructor
         * @param {common.IBasicQot=} [properties] Properties to set
         */
        function BasicQot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicQot security.
         * @member {common.ISecurity} security
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.security = null;

        /**
         * BasicQot name.
         * @member {string} name
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.name = "";

        /**
         * BasicQot isSuspended.
         * @member {boolean} isSuspended
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.isSuspended = false;

        /**
         * BasicQot listTime.
         * @member {string} listTime
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.listTime = "";

        /**
         * BasicQot priceSpread.
         * @member {number} priceSpread
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.priceSpread = 0;

        /**
         * BasicQot updateTime.
         * @member {string} updateTime
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.updateTime = "";

        /**
         * BasicQot highPrice.
         * @member {number} highPrice
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.highPrice = 0;

        /**
         * BasicQot openPrice.
         * @member {number} openPrice
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.openPrice = 0;

        /**
         * BasicQot lowPrice.
         * @member {number} lowPrice
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.lowPrice = 0;

        /**
         * BasicQot curPrice.
         * @member {number} curPrice
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.curPrice = 0;

        /**
         * BasicQot lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.lastClosePrice = 0;

        /**
         * BasicQot volume.
         * @member {number|Long} volume
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BasicQot turnover.
         * @member {number} turnover
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.turnover = 0;

        /**
         * BasicQot turnoverRate.
         * @member {number} turnoverRate
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.turnoverRate = 0;

        /**
         * BasicQot amplitude.
         * @member {number} amplitude
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.amplitude = 0;

        /**
         * BasicQot darkStatus.
         * @member {number} darkStatus
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.darkStatus = 0;

        /**
         * BasicQot optionExData.
         * @member {common.IOptionBasicQotExData|null|undefined} optionExData
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.optionExData = null;

        /**
         * BasicQot listTimestamp.
         * @member {number} listTimestamp
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.listTimestamp = 0;

        /**
         * BasicQot updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.updateTimestamp = 0;

        /**
         * BasicQot preMarket.
         * @member {common.IPreAfterMarketData|null|undefined} preMarket
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.preMarket = null;

        /**
         * BasicQot afterMarket.
         * @member {common.IPreAfterMarketData|null|undefined} afterMarket
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.afterMarket = null;

        /**
         * BasicQot secStatus.
         * @member {number} secStatus
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.secStatus = 0;

        /**
         * BasicQot futureExData.
         * @member {common.IFutureBasicQotExData|null|undefined} futureExData
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.futureExData = null;

        /**
         * BasicQot warrantExData.
         * @member {common.IWarrantBasicQotExData|null|undefined} warrantExData
         * @memberof common.BasicQot
         * @instance
         */
        BasicQot.prototype.warrantExData = null;

        /**
         * Creates a new BasicQot instance using the specified properties.
         * @function create
         * @memberof common.BasicQot
         * @static
         * @param {common.IBasicQot=} [properties] Properties to set
         * @returns {common.BasicQot} BasicQot instance
         */
        BasicQot.create = function create(properties) {
            return new BasicQot(properties);
        };

        /**
         * Encodes the specified BasicQot message. Does not implicitly {@link common.BasicQot.verify|verify} messages.
         * @function encode
         * @memberof common.BasicQot
         * @static
         * @param {common.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isSuspended);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.listTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.priceSpread);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.updateTime);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.highPrice);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.openPrice);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.lowPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.curPrice);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.lastClosePrice);
            writer.uint32(/* id 11, wireType 0 =*/88).int64(message.volume);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.turnover);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.turnoverRate);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.amplitude);
            if (message.darkStatus != null && Object.hasOwnProperty.call(message, "darkStatus"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.darkStatus);
            if (message.optionExData != null && Object.hasOwnProperty.call(message, "optionExData"))
                $root.common.OptionBasicQotExData.encode(message.optionExData, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.listTimestamp != null && Object.hasOwnProperty.call(message, "listTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.listTimestamp);
            if (message.updateTimestamp != null && Object.hasOwnProperty.call(message, "updateTimestamp"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.updateTimestamp);
            if (message.preMarket != null && Object.hasOwnProperty.call(message, "preMarket"))
                $root.common.PreAfterMarketData.encode(message.preMarket, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.afterMarket != null && Object.hasOwnProperty.call(message, "afterMarket"))
                $root.common.PreAfterMarketData.encode(message.afterMarket, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.secStatus != null && Object.hasOwnProperty.call(message, "secStatus"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.secStatus);
            if (message.futureExData != null && Object.hasOwnProperty.call(message, "futureExData"))
                $root.common.FutureBasicQotExData.encode(message.futureExData, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.warrantExData != null && Object.hasOwnProperty.call(message, "warrantExData"))
                $root.common.WarrantBasicQotExData.encode(message.warrantExData, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 24, wireType 2 =*/194).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified BasicQot message, length delimited. Does not implicitly {@link common.BasicQot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.BasicQot
         * @static
         * @param {common.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer.
         * @function decode
         * @memberof common.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BasicQot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.security = $root.common.Security.decode(reader, reader.uint32());
                        break;
                    }
                case 24: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.isSuspended = reader.bool();
                        break;
                    }
                case 3: {
                        message.listTime = reader.string();
                        break;
                    }
                case 4: {
                        message.priceSpread = reader.double();
                        break;
                    }
                case 5: {
                        message.updateTime = reader.string();
                        break;
                    }
                case 6: {
                        message.highPrice = reader.double();
                        break;
                    }
                case 7: {
                        message.openPrice = reader.double();
                        break;
                    }
                case 8: {
                        message.lowPrice = reader.double();
                        break;
                    }
                case 9: {
                        message.curPrice = reader.double();
                        break;
                    }
                case 10: {
                        message.lastClosePrice = reader.double();
                        break;
                    }
                case 11: {
                        message.volume = reader.int64();
                        break;
                    }
                case 12: {
                        message.turnover = reader.double();
                        break;
                    }
                case 13: {
                        message.turnoverRate = reader.double();
                        break;
                    }
                case 14: {
                        message.amplitude = reader.double();
                        break;
                    }
                case 15: {
                        message.darkStatus = reader.int32();
                        break;
                    }
                case 16: {
                        message.optionExData = $root.common.OptionBasicQotExData.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.listTimestamp = reader.double();
                        break;
                    }
                case 18: {
                        message.updateTimestamp = reader.double();
                        break;
                    }
                case 19: {
                        message.preMarket = $root.common.PreAfterMarketData.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.afterMarket = $root.common.PreAfterMarketData.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.secStatus = reader.int32();
                        break;
                    }
                case 22: {
                        message.futureExData = $root.common.FutureBasicQotExData.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        message.warrantExData = $root.common.WarrantBasicQotExData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("isSuspended"))
                throw $util.ProtocolError("missing required 'isSuspended'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("priceSpread"))
                throw $util.ProtocolError("missing required 'priceSpread'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("openPrice"))
                throw $util.ProtocolError("missing required 'openPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("turnoverRate"))
                throw $util.ProtocolError("missing required 'turnoverRate'", { instance: message });
            if (!message.hasOwnProperty("amplitude"))
                throw $util.ProtocolError("missing required 'amplitude'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicQot message.
         * @function verify
         * @memberof common.BasicQot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicQot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (typeof message.isSuspended !== "boolean")
                return "isSuspended: boolean expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (typeof message.priceSpread !== "number")
                return "priceSpread: number expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.openPrice !== "number")
                return "openPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.turnoverRate !== "number")
                return "turnoverRate: number expected";
            if (typeof message.amplitude !== "number")
                return "amplitude: number expected";
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                if (!$util.isInteger(message.darkStatus))
                    return "darkStatus: integer expected";
            if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                let error = $root.common.OptionBasicQotExData.verify(message.optionExData);
                if (error)
                    return "optionExData." + error;
            }
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.preMarket != null && message.hasOwnProperty("preMarket")) {
                let error = $root.common.PreAfterMarketData.verify(message.preMarket);
                if (error)
                    return "preMarket." + error;
            }
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket")) {
                let error = $root.common.PreAfterMarketData.verify(message.afterMarket);
                if (error)
                    return "afterMarket." + error;
            }
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                if (!$util.isInteger(message.secStatus))
                    return "secStatus: integer expected";
            if (message.futureExData != null && message.hasOwnProperty("futureExData")) {
                let error = $root.common.FutureBasicQotExData.verify(message.futureExData);
                if (error)
                    return "futureExData." + error;
            }
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData")) {
                let error = $root.common.WarrantBasicQotExData.verify(message.warrantExData);
                if (error)
                    return "warrantExData." + error;
            }
            return null;
        };

        /**
         * Creates a BasicQot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.BasicQot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.BasicQot} BasicQot
         */
        BasicQot.fromObject = function fromObject(object) {
            if (object instanceof $root.common.BasicQot)
                return object;
            let message = new $root.common.BasicQot();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".common.BasicQot.security: object expected");
                message.security = $root.common.Security.fromObject(object.security);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.isSuspended != null)
                message.isSuspended = Boolean(object.isSuspended);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.priceSpread != null)
                message.priceSpread = Number(object.priceSpread);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.darkStatus != null)
                message.darkStatus = object.darkStatus | 0;
            if (object.optionExData != null) {
                if (typeof object.optionExData !== "object")
                    throw TypeError(".common.BasicQot.optionExData: object expected");
                message.optionExData = $root.common.OptionBasicQotExData.fromObject(object.optionExData);
            }
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.preMarket != null) {
                if (typeof object.preMarket !== "object")
                    throw TypeError(".common.BasicQot.preMarket: object expected");
                message.preMarket = $root.common.PreAfterMarketData.fromObject(object.preMarket);
            }
            if (object.afterMarket != null) {
                if (typeof object.afterMarket !== "object")
                    throw TypeError(".common.BasicQot.afterMarket: object expected");
                message.afterMarket = $root.common.PreAfterMarketData.fromObject(object.afterMarket);
            }
            if (object.secStatus != null)
                message.secStatus = object.secStatus | 0;
            if (object.futureExData != null) {
                if (typeof object.futureExData !== "object")
                    throw TypeError(".common.BasicQot.futureExData: object expected");
                message.futureExData = $root.common.FutureBasicQotExData.fromObject(object.futureExData);
            }
            if (object.warrantExData != null) {
                if (typeof object.warrantExData !== "object")
                    throw TypeError(".common.BasicQot.warrantExData: object expected");
                message.warrantExData = $root.common.WarrantBasicQotExData.fromObject(object.warrantExData);
            }
            return message;
        };

        /**
         * Creates a plain object from a BasicQot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.BasicQot
         * @static
         * @param {common.BasicQot} message BasicQot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicQot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.security = null;
                object.isSuspended = false;
                object.listTime = "";
                object.priceSpread = 0;
                object.updateTime = "";
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.curPrice = 0;
                object.lastClosePrice = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.amplitude = 0;
                object.darkStatus = 0;
                object.optionExData = null;
                object.listTimestamp = 0;
                object.updateTimestamp = 0;
                object.preMarket = null;
                object.afterMarket = null;
                object.secStatus = 0;
                object.futureExData = null;
                object.warrantExData = null;
                object.name = "";
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.common.Security.toObject(message.security, options);
            if (message.isSuspended != null && message.hasOwnProperty("isSuspended"))
                object.isSuspended = message.isSuspended;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.priceSpread != null && message.hasOwnProperty("priceSpread"))
                object.priceSpread = options.json && !isFinite(message.priceSpread) ? String(message.priceSpread) : message.priceSpread;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                object.darkStatus = message.darkStatus;
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                object.optionExData = $root.common.OptionBasicQotExData.toObject(message.optionExData, options);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.preMarket != null && message.hasOwnProperty("preMarket"))
                object.preMarket = $root.common.PreAfterMarketData.toObject(message.preMarket, options);
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket"))
                object.afterMarket = $root.common.PreAfterMarketData.toObject(message.afterMarket, options);
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                object.secStatus = message.secStatus;
            if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                object.futureExData = $root.common.FutureBasicQotExData.toObject(message.futureExData, options);
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                object.warrantExData = $root.common.WarrantBasicQotExData.toObject(message.warrantExData, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this BasicQot to JSON.
         * @function toJSON
         * @memberof common.BasicQot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicQot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BasicQot
         * @function getTypeUrl
         * @memberof common.BasicQot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BasicQot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.BasicQot";
        };

        return BasicQot;
    })();

    common.OptionBasicQotExData = (function() {

        /**
         * Properties of an OptionBasicQotExData.
         * @memberof common
         * @interface IOptionBasicQotExData
         * @property {number} strikePrice OptionBasicQotExData strikePrice
         * @property {number} contractSize OptionBasicQotExData contractSize
         * @property {number|null} [contractSizeFloat] OptionBasicQotExData contractSizeFloat
         * @property {number} openInterest OptionBasicQotExData openInterest
         * @property {number} impliedVolatility OptionBasicQotExData impliedVolatility
         * @property {number} premium OptionBasicQotExData premium
         * @property {number} delta OptionBasicQotExData delta
         * @property {number} gamma OptionBasicQotExData gamma
         * @property {number} vega OptionBasicQotExData vega
         * @property {number} theta OptionBasicQotExData theta
         * @property {number} rho OptionBasicQotExData rho
         * @property {number|null} [netOpenInterest] OptionBasicQotExData netOpenInterest
         * @property {number|null} [expiryDateDistance] OptionBasicQotExData expiryDateDistance
         * @property {number|null} [contractNominalValue] OptionBasicQotExData contractNominalValue
         * @property {number|null} [ownerLotMultiplier] OptionBasicQotExData ownerLotMultiplier
         * @property {number|null} [optionAreaType] OptionBasicQotExData optionAreaType
         * @property {number|null} [contractMultiplier] OptionBasicQotExData contractMultiplier
         * @property {number|null} [indexOptionType] OptionBasicQotExData indexOptionType
         */

        /**
         * Constructs a new OptionBasicQotExData.
         * @memberof common
         * @classdesc Represents an OptionBasicQotExData.
         * @implements IOptionBasicQotExData
         * @constructor
         * @param {common.IOptionBasicQotExData=} [properties] Properties to set
         */
        function OptionBasicQotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionBasicQotExData strikePrice.
         * @member {number} strikePrice
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.strikePrice = 0;

        /**
         * OptionBasicQotExData contractSize.
         * @member {number} contractSize
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractSize = 0;

        /**
         * OptionBasicQotExData contractSizeFloat.
         * @member {number} contractSizeFloat
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractSizeFloat = 0;

        /**
         * OptionBasicQotExData openInterest.
         * @member {number} openInterest
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.openInterest = 0;

        /**
         * OptionBasicQotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.impliedVolatility = 0;

        /**
         * OptionBasicQotExData premium.
         * @member {number} premium
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.premium = 0;

        /**
         * OptionBasicQotExData delta.
         * @member {number} delta
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.delta = 0;

        /**
         * OptionBasicQotExData gamma.
         * @member {number} gamma
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.gamma = 0;

        /**
         * OptionBasicQotExData vega.
         * @member {number} vega
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.vega = 0;

        /**
         * OptionBasicQotExData theta.
         * @member {number} theta
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.theta = 0;

        /**
         * OptionBasicQotExData rho.
         * @member {number} rho
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.rho = 0;

        /**
         * OptionBasicQotExData netOpenInterest.
         * @member {number} netOpenInterest
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.netOpenInterest = 0;

        /**
         * OptionBasicQotExData expiryDateDistance.
         * @member {number} expiryDateDistance
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.expiryDateDistance = 0;

        /**
         * OptionBasicQotExData contractNominalValue.
         * @member {number} contractNominalValue
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractNominalValue = 0;

        /**
         * OptionBasicQotExData ownerLotMultiplier.
         * @member {number} ownerLotMultiplier
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.ownerLotMultiplier = 0;

        /**
         * OptionBasicQotExData optionAreaType.
         * @member {number} optionAreaType
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.optionAreaType = 0;

        /**
         * OptionBasicQotExData contractMultiplier.
         * @member {number} contractMultiplier
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractMultiplier = 0;

        /**
         * OptionBasicQotExData indexOptionType.
         * @member {number} indexOptionType
         * @memberof common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.indexOptionType = 0;

        /**
         * Creates a new OptionBasicQotExData instance using the specified properties.
         * @function create
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {common.IOptionBasicQotExData=} [properties] Properties to set
         * @returns {common.OptionBasicQotExData} OptionBasicQotExData instance
         */
        OptionBasicQotExData.create = function create(properties) {
            return new OptionBasicQotExData(properties);
        };

        /**
         * Encodes the specified OptionBasicQotExData message. Does not implicitly {@link common.OptionBasicQotExData.verify|verify} messages.
         * @function encode
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {common.IOptionBasicQotExData} message OptionBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionBasicQotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.strikePrice);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contractSize);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.openInterest);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.impliedVolatility);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.premium);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.delta);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.gamma);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.vega);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.theta);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.rho);
            if (message.netOpenInterest != null && Object.hasOwnProperty.call(message, "netOpenInterest"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.netOpenInterest);
            if (message.expiryDateDistance != null && Object.hasOwnProperty.call(message, "expiryDateDistance"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.expiryDateDistance);
            if (message.contractNominalValue != null && Object.hasOwnProperty.call(message, "contractNominalValue"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.contractNominalValue);
            if (message.ownerLotMultiplier != null && Object.hasOwnProperty.call(message, "ownerLotMultiplier"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.ownerLotMultiplier);
            if (message.optionAreaType != null && Object.hasOwnProperty.call(message, "optionAreaType"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.optionAreaType);
            if (message.contractMultiplier != null && Object.hasOwnProperty.call(message, "contractMultiplier"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.contractMultiplier);
            if (message.contractSizeFloat != null && Object.hasOwnProperty.call(message, "contractSizeFloat"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.contractSizeFloat);
            if (message.indexOptionType != null && Object.hasOwnProperty.call(message, "indexOptionType"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.indexOptionType);
            return writer;
        };

        /**
         * Encodes the specified OptionBasicQotExData message, length delimited. Does not implicitly {@link common.OptionBasicQotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {common.IOptionBasicQotExData} message OptionBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionBasicQotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionBasicQotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.OptionBasicQotExData} OptionBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionBasicQotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OptionBasicQotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.strikePrice = reader.double();
                        break;
                    }
                case 2: {
                        message.contractSize = reader.int32();
                        break;
                    }
                case 17: {
                        message.contractSizeFloat = reader.double();
                        break;
                    }
                case 3: {
                        message.openInterest = reader.int32();
                        break;
                    }
                case 4: {
                        message.impliedVolatility = reader.double();
                        break;
                    }
                case 5: {
                        message.premium = reader.double();
                        break;
                    }
                case 6: {
                        message.delta = reader.double();
                        break;
                    }
                case 7: {
                        message.gamma = reader.double();
                        break;
                    }
                case 8: {
                        message.vega = reader.double();
                        break;
                    }
                case 9: {
                        message.theta = reader.double();
                        break;
                    }
                case 10: {
                        message.rho = reader.double();
                        break;
                    }
                case 11: {
                        message.netOpenInterest = reader.int32();
                        break;
                    }
                case 12: {
                        message.expiryDateDistance = reader.int32();
                        break;
                    }
                case 13: {
                        message.contractNominalValue = reader.double();
                        break;
                    }
                case 14: {
                        message.ownerLotMultiplier = reader.double();
                        break;
                    }
                case 15: {
                        message.optionAreaType = reader.int32();
                        break;
                    }
                case 16: {
                        message.contractMultiplier = reader.double();
                        break;
                    }
                case 18: {
                        message.indexOptionType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("contractSize"))
                throw $util.ProtocolError("missing required 'contractSize'", { instance: message });
            if (!message.hasOwnProperty("openInterest"))
                throw $util.ProtocolError("missing required 'openInterest'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("gamma"))
                throw $util.ProtocolError("missing required 'gamma'", { instance: message });
            if (!message.hasOwnProperty("vega"))
                throw $util.ProtocolError("missing required 'vega'", { instance: message });
            if (!message.hasOwnProperty("theta"))
                throw $util.ProtocolError("missing required 'theta'", { instance: message });
            if (!message.hasOwnProperty("rho"))
                throw $util.ProtocolError("missing required 'rho'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionBasicQotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.OptionBasicQotExData} OptionBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionBasicQotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionBasicQotExData message.
         * @function verify
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionBasicQotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isInteger(message.contractSize))
                return "contractSize: integer expected";
            if (message.contractSizeFloat != null && message.hasOwnProperty("contractSizeFloat"))
                if (typeof message.contractSizeFloat !== "number")
                    return "contractSizeFloat: number expected";
            if (!$util.isInteger(message.openInterest))
                return "openInterest: integer expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.gamma !== "number")
                return "gamma: number expected";
            if (typeof message.vega !== "number")
                return "vega: number expected";
            if (typeof message.theta !== "number")
                return "theta: number expected";
            if (typeof message.rho !== "number")
                return "rho: number expected";
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                if (!$util.isInteger(message.netOpenInterest))
                    return "netOpenInterest: integer expected";
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                if (!$util.isInteger(message.expiryDateDistance))
                    return "expiryDateDistance: integer expected";
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                if (typeof message.contractNominalValue !== "number")
                    return "contractNominalValue: number expected";
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                if (typeof message.ownerLotMultiplier !== "number")
                    return "ownerLotMultiplier: number expected";
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                if (!$util.isInteger(message.optionAreaType))
                    return "optionAreaType: integer expected";
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                if (typeof message.contractMultiplier !== "number")
                    return "contractMultiplier: number expected";
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                if (!$util.isInteger(message.indexOptionType))
                    return "indexOptionType: integer expected";
            return null;
        };

        /**
         * Creates an OptionBasicQotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.OptionBasicQotExData} OptionBasicQotExData
         */
        OptionBasicQotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.OptionBasicQotExData)
                return object;
            let message = new $root.common.OptionBasicQotExData();
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.contractSize != null)
                message.contractSize = object.contractSize | 0;
            if (object.contractSizeFloat != null)
                message.contractSizeFloat = Number(object.contractSizeFloat);
            if (object.openInterest != null)
                message.openInterest = object.openInterest | 0;
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.gamma != null)
                message.gamma = Number(object.gamma);
            if (object.vega != null)
                message.vega = Number(object.vega);
            if (object.theta != null)
                message.theta = Number(object.theta);
            if (object.rho != null)
                message.rho = Number(object.rho);
            if (object.netOpenInterest != null)
                message.netOpenInterest = object.netOpenInterest | 0;
            if (object.expiryDateDistance != null)
                message.expiryDateDistance = object.expiryDateDistance | 0;
            if (object.contractNominalValue != null)
                message.contractNominalValue = Number(object.contractNominalValue);
            if (object.ownerLotMultiplier != null)
                message.ownerLotMultiplier = Number(object.ownerLotMultiplier);
            if (object.optionAreaType != null)
                message.optionAreaType = object.optionAreaType | 0;
            if (object.contractMultiplier != null)
                message.contractMultiplier = Number(object.contractMultiplier);
            if (object.indexOptionType != null)
                message.indexOptionType = object.indexOptionType | 0;
            return message;
        };

        /**
         * Creates a plain object from an OptionBasicQotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {common.OptionBasicQotExData} message OptionBasicQotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionBasicQotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.strikePrice = 0;
                object.contractSize = 0;
                object.openInterest = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.delta = 0;
                object.gamma = 0;
                object.vega = 0;
                object.theta = 0;
                object.rho = 0;
                object.netOpenInterest = 0;
                object.expiryDateDistance = 0;
                object.contractNominalValue = 0;
                object.ownerLotMultiplier = 0;
                object.optionAreaType = 0;
                object.contractMultiplier = 0;
                object.contractSizeFloat = 0;
                object.indexOptionType = 0;
            }
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.contractSize != null && message.hasOwnProperty("contractSize"))
                object.contractSize = message.contractSize;
            if (message.openInterest != null && message.hasOwnProperty("openInterest"))
                object.openInterest = message.openInterest;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
            if (message.vega != null && message.hasOwnProperty("vega"))
                object.vega = options.json && !isFinite(message.vega) ? String(message.vega) : message.vega;
            if (message.theta != null && message.hasOwnProperty("theta"))
                object.theta = options.json && !isFinite(message.theta) ? String(message.theta) : message.theta;
            if (message.rho != null && message.hasOwnProperty("rho"))
                object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                object.netOpenInterest = message.netOpenInterest;
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                object.expiryDateDistance = message.expiryDateDistance;
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                object.contractNominalValue = options.json && !isFinite(message.contractNominalValue) ? String(message.contractNominalValue) : message.contractNominalValue;
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                object.ownerLotMultiplier = options.json && !isFinite(message.ownerLotMultiplier) ? String(message.ownerLotMultiplier) : message.ownerLotMultiplier;
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                object.optionAreaType = message.optionAreaType;
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                object.contractMultiplier = options.json && !isFinite(message.contractMultiplier) ? String(message.contractMultiplier) : message.contractMultiplier;
            if (message.contractSizeFloat != null && message.hasOwnProperty("contractSizeFloat"))
                object.contractSizeFloat = options.json && !isFinite(message.contractSizeFloat) ? String(message.contractSizeFloat) : message.contractSizeFloat;
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                object.indexOptionType = message.indexOptionType;
            return object;
        };

        /**
         * Converts this OptionBasicQotExData to JSON.
         * @function toJSON
         * @memberof common.OptionBasicQotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionBasicQotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OptionBasicQotExData
         * @function getTypeUrl
         * @memberof common.OptionBasicQotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OptionBasicQotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.OptionBasicQotExData";
        };

        return OptionBasicQotExData;
    })();

    common.PacketID = (function() {

        /**
         * Properties of a PacketID.
         * @memberof common
         * @interface IPacketID
         * @property {number|Long} connID PacketID connID
         * @property {number} serialNo PacketID serialNo
         */

        /**
         * Constructs a new PacketID.
         * @memberof common
         * @classdesc Represents a PacketID.
         * @implements IPacketID
         * @constructor
         * @param {common.IPacketID=} [properties] Properties to set
         */
        function PacketID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PacketID connID.
         * @member {number|Long} connID
         * @memberof common.PacketID
         * @instance
         */
        PacketID.prototype.connID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PacketID serialNo.
         * @member {number} serialNo
         * @memberof common.PacketID
         * @instance
         */
        PacketID.prototype.serialNo = 0;

        /**
         * Creates a new PacketID instance using the specified properties.
         * @function create
         * @memberof common.PacketID
         * @static
         * @param {common.IPacketID=} [properties] Properties to set
         * @returns {common.PacketID} PacketID instance
         */
        PacketID.create = function create(properties) {
            return new PacketID(properties);
        };

        /**
         * Encodes the specified PacketID message. Does not implicitly {@link common.PacketID.verify|verify} messages.
         * @function encode
         * @memberof common.PacketID
         * @static
         * @param {common.IPacketID} message PacketID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.connID);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.serialNo);
            return writer;
        };

        /**
         * Encodes the specified PacketID message, length delimited. Does not implicitly {@link common.PacketID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.PacketID
         * @static
         * @param {common.IPacketID} message PacketID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PacketID message from the specified reader or buffer.
         * @function decode
         * @memberof common.PacketID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.PacketID} PacketID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.PacketID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.connID = reader.uint64();
                        break;
                    }
                case 2: {
                        message.serialNo = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("connID"))
                throw $util.ProtocolError("missing required 'connID'", { instance: message });
            if (!message.hasOwnProperty("serialNo"))
                throw $util.ProtocolError("missing required 'serialNo'", { instance: message });
            return message;
        };

        /**
         * Decodes a PacketID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.PacketID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.PacketID} PacketID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PacketID message.
         * @function verify
         * @memberof common.PacketID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PacketID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.connID) && !(message.connID && $util.isInteger(message.connID.low) && $util.isInteger(message.connID.high)))
                return "connID: integer|Long expected";
            if (!$util.isInteger(message.serialNo))
                return "serialNo: integer expected";
            return null;
        };

        /**
         * Creates a PacketID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.PacketID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.PacketID} PacketID
         */
        PacketID.fromObject = function fromObject(object) {
            if (object instanceof $root.common.PacketID)
                return object;
            let message = new $root.common.PacketID();
            if (object.connID != null)
                if ($util.Long)
                    (message.connID = $util.Long.fromValue(object.connID)).unsigned = true;
                else if (typeof object.connID === "string")
                    message.connID = parseInt(object.connID, 10);
                else if (typeof object.connID === "number")
                    message.connID = object.connID;
                else if (typeof object.connID === "object")
                    message.connID = new $util.LongBits(object.connID.low >>> 0, object.connID.high >>> 0).toNumber(true);
            if (object.serialNo != null)
                message.serialNo = object.serialNo >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PacketID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.PacketID
         * @static
         * @param {common.PacketID} message PacketID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PacketID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.connID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.connID = options.longs === String ? "0" : 0;
                object.serialNo = 0;
            }
            if (message.connID != null && message.hasOwnProperty("connID"))
                if (typeof message.connID === "number")
                    object.connID = options.longs === String ? String(message.connID) : message.connID;
                else
                    object.connID = options.longs === String ? $util.Long.prototype.toString.call(message.connID) : options.longs === Number ? new $util.LongBits(message.connID.low >>> 0, message.connID.high >>> 0).toNumber(true) : message.connID;
            if (message.serialNo != null && message.hasOwnProperty("serialNo"))
                object.serialNo = message.serialNo;
            return object;
        };

        /**
         * Converts this PacketID to JSON.
         * @function toJSON
         * @memberof common.PacketID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PacketID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PacketID
         * @function getTypeUrl
         * @memberof common.PacketID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PacketID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.PacketID";
        };

        return PacketID;
    })();

    /**
     * 交易环境
     * 
     * TrdEnv_Simulate = 0; //模拟环境
     * 
     * TrdEnv_Real = 1; //真实环境
     * @name common.TrdEnv
     * @enum {number}
     * @property {number} TrdEnv_Simulate=0 TrdEnv_Simulate value
     * @property {number} TrdEnv_Real=1 TrdEnv_Real value
     */
    common.TrdEnv = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdEnv_Simulate"] = 0;
        values[valuesById[1] = "TrdEnv_Real"] = 1;
        return values;
    })();

    /**
     * TrdSide enum.
     * @name common.TrdSide
     * @enum {number}
     * @property {number} TrdSide_Unknown=0 TrdSide_Unknown value
     * @property {number} TrdSide_Buy=1 TrdSide_Buy value
     * @property {number} TrdSide_Sell=2 TrdSide_Sell value
     * @property {number} TrdSide_SellShort=3 TrdSide_SellShort value
     * @property {number} TrdSide_BuyBack=4 TrdSide_BuyBack value
     */
    common.TrdSide = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdSide_Unknown"] = 0;
        values[valuesById[1] = "TrdSide_Buy"] = 1;
        values[valuesById[2] = "TrdSide_Sell"] = 2;
        values[valuesById[3] = "TrdSide_SellShort"] = 3;
        values[valuesById[4] = "TrdSide_BuyBack"] = 4;
        return values;
    })();

    /**
     * 订单类型
     * @name common.OrderType
     * @enum {number}
     * @property {number} OrderType_Unknown=0 OrderType_Unknown value
     * @property {number} OrderType_Normal=1 限价单
     * @property {number} OrderType_Market=2 市价单
     * @property {number} OrderType_AbsoluteLimit=5 绝对限价订单（仅港股），只有价格完全匹配才成交，否则下单失败。举例：下一笔价格为 5 元的绝对限价买单，卖方的价格必须也是5元才能成交，卖方即使低于 5 元也不能成交，下单失败。卖出同理
     * @property {number} OrderType_Auction=6 竞价订单（仅港股），仅港股早盘竞价和收盘竞价有效
     * @property {number} OrderType_AuctionLimit=7 竞价限价订单（仅港股），仅早盘竞价和收盘竞价有效，参与竞价，且要求满足指定价格才会成交
     * @property {number} OrderType_SpecialLimit=8 特别限价订单（仅港股），成交规则同增强限价订单，且部分成交后，交易所自动撤销订单
     * @property {number} OrderType_SpecialLimit_All=9 特别限价且要求全部成交订单（仅港股）。全部成交，否则自动撤单
     * @property {number} OrderType_Stop=10 止损市价单
     * @property {number} OrderType_StopLimit=11 止损限价单
     * @property {number} OrderType_MarketifTouched=12 触及市价单（止盈）
     * @property {number} OrderType_LimitifTouched=13 触及限价单（止盈）
     * @property {number} OrderType_TrailingStop=14 跟踪止损市价单
     * @property {number} OrderType_TrailingStopLimit=15 跟踪止损限价单
     * @property {number} OrderType_TWAP=16 时间加权市价算法单（仅美股）
     * @property {number} OrderType_TWAP_LIMIT=17 时间加权限价算法单 （港股和美股）
     * @property {number} OrderType_VWAP=18 成交量加权市价算法单（仅美股）
     * @property {number} OrderType_VWAP_LIMIT=19 成交量加权限价算法单（港股和美股）
     */
    common.OrderType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OrderType_Unknown"] = 0;
        values[valuesById[1] = "OrderType_Normal"] = 1;
        values[valuesById[2] = "OrderType_Market"] = 2;
        values[valuesById[5] = "OrderType_AbsoluteLimit"] = 5;
        values[valuesById[6] = "OrderType_Auction"] = 6;
        values[valuesById[7] = "OrderType_AuctionLimit"] = 7;
        values[valuesById[8] = "OrderType_SpecialLimit"] = 8;
        values[valuesById[9] = "OrderType_SpecialLimit_All"] = 9;
        values[valuesById[10] = "OrderType_Stop"] = 10;
        values[valuesById[11] = "OrderType_StopLimit"] = 11;
        values[valuesById[12] = "OrderType_MarketifTouched"] = 12;
        values[valuesById[13] = "OrderType_LimitifTouched"] = 13;
        values[valuesById[14] = "OrderType_TrailingStop"] = 14;
        values[valuesById[15] = "OrderType_TrailingStopLimit"] = 15;
        values[valuesById[16] = "OrderType_TWAP"] = 16;
        values[valuesById[17] = "OrderType_TWAP_LIMIT"] = 17;
        values[valuesById[18] = "OrderType_VWAP"] = 18;
        values[valuesById[19] = "OrderType_VWAP_LIMIT"] = 19;
        return values;
    })();

    /**
     * 交易市场
     * @name common.TrdMarket
     * @enum {number}
     * @property {number} TrdMarket_Unknown=0 TrdMarket_Unknown value
     * @property {number} TrdMarket_HK=1 TrdMarket_HK value
     * @property {number} TrdMarket_US=2 TrdMarket_US value
     * @property {number} TrdMarket_CN=3 TrdMarket_CN value
     * @property {number} TrdMarket_HKCC=4 TrdMarket_HKCC value
     * @property {number} TrdMarket_Futures=5 TrdMarket_Futures value
     * @property {number} TrdMarket_SG=6 TrdMarket_SG value
     * @property {number} TrdMarket_AU=8 TrdMarket_AU value
     * @property {number} TrdMarket_Futures_Simulate_HK=10 TrdMarket_Futures_Simulate_HK value
     * @property {number} TrdMarket_Futures_Simulate_US=11 TrdMarket_Futures_Simulate_US value
     * @property {number} TrdMarket_Futures_Simulate_SG=12 TrdMarket_Futures_Simulate_SG value
     * @property {number} TrdMarket_Futures_Simulate_JP=13 TrdMarket_Futures_Simulate_JP value
     * @property {number} TrdMarket_JP=15 TrdMarket_JP value
     * @property {number} TrdMarket_MY=111 TrdMarket_MY value
     * @property {number} TrdMarket_CA=112 TrdMarket_CA value
     * @property {number} TrdMarket_HK_Fund=113 TrdMarket_HK_Fund value
     * @property {number} TrdMarket_US_Fund=123 TrdMarket_US_Fund value
     */
    common.TrdMarket = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdMarket_Unknown"] = 0;
        values[valuesById[1] = "TrdMarket_HK"] = 1;
        values[valuesById[2] = "TrdMarket_US"] = 2;
        values[valuesById[3] = "TrdMarket_CN"] = 3;
        values[valuesById[4] = "TrdMarket_HKCC"] = 4;
        values[valuesById[5] = "TrdMarket_Futures"] = 5;
        values[valuesById[6] = "TrdMarket_SG"] = 6;
        values[valuesById[8] = "TrdMarket_AU"] = 8;
        values[valuesById[10] = "TrdMarket_Futures_Simulate_HK"] = 10;
        values[valuesById[11] = "TrdMarket_Futures_Simulate_US"] = 11;
        values[valuesById[12] = "TrdMarket_Futures_Simulate_SG"] = 12;
        values[valuesById[13] = "TrdMarket_Futures_Simulate_JP"] = 13;
        values[valuesById[15] = "TrdMarket_JP"] = 15;
        values[valuesById[111] = "TrdMarket_MY"] = 111;
        values[valuesById[112] = "TrdMarket_CA"] = 112;
        values[valuesById[113] = "TrdMarket_HK_Fund"] = 113;
        values[valuesById[123] = "TrdMarket_US_Fund"] = 123;
        return values;
    })();

    /**
     * 订单有效期
     * @name common.TimeInForce
     * @enum {number}
     * @property {number} TimeInForce_DAY=0 当日有效
     * @property {number} TimeInForce_GTC=1 撤单前有效，最多持续90自然日
     */
    common.TimeInForce = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TimeInForce_DAY"] = 0;
        values[valuesById[1] = "TimeInForce_GTC"] = 1;
        return values;
    })();

    /**
     * 订单跟踪类型
     * @name common.TrailType
     * @enum {number}
     * @property {number} TrailType_Unknown=0 TrailType_Unknown value
     * @property {number} TrailType_Ratio=1 TrailType_Ratio value
     * @property {number} TrailType_Amount=2 TrailType_Amount value
     */
    common.TrailType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrailType_Unknown"] = 0;
        values[valuesById[1] = "TrailType_Ratio"] = 1;
        values[valuesById[2] = "TrailType_Amount"] = 2;
        return values;
    })();

    /**
     * 交易证券市场
     * @name common.TrdSecMarket
     * @enum {number}
     * @property {number} TrdSecMarket_Unknown=0 TrdSecMarket_Unknown value
     * @property {number} TrdSecMarket_HK=1 TrdSecMarket_HK value
     * @property {number} TrdSecMarket_US=2 TrdSecMarket_US value
     * @property {number} TrdSecMarket_CN_SH=31 TrdSecMarket_CN_SH value
     * @property {number} TrdSecMarket_CN_SZ=32 TrdSecMarket_CN_SZ value
     * @property {number} TrdSecMarket_SG=41 TrdSecMarket_SG value
     * @property {number} TrdSecMarket_JP=51 TrdSecMarket_JP value
     * @property {number} TrdSecMarket_AU=61 TrdSecMarket_AU value
     * @property {number} TrdSecMarket_MY=71 TrdSecMarket_MY value
     * @property {number} TrdSecMarket_CA=81 TrdSecMarket_CA value
     * @property {number} TrdSecMarket_FX=91 TrdSecMarket_FX value
     */
    common.TrdSecMarket = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdSecMarket_Unknown"] = 0;
        values[valuesById[1] = "TrdSecMarket_HK"] = 1;
        values[valuesById[2] = "TrdSecMarket_US"] = 2;
        values[valuesById[31] = "TrdSecMarket_CN_SH"] = 31;
        values[valuesById[32] = "TrdSecMarket_CN_SZ"] = 32;
        values[valuesById[41] = "TrdSecMarket_SG"] = 41;
        values[valuesById[51] = "TrdSecMarket_JP"] = 51;
        values[valuesById[61] = "TrdSecMarket_AU"] = 61;
        values[valuesById[71] = "TrdSecMarket_MY"] = 71;
        values[valuesById[81] = "TrdSecMarket_CA"] = 81;
        values[valuesById[91] = "TrdSecMarket_FX"] = 91;
        return values;
    })();

    /**
     * TrdAccStatus enum.
     * @name common.TrdAccStatus
     * @enum {number}
     * @property {number} TrdAccStatus_Active=0 TrdAccStatus_Active value
     * @property {number} TrdAccStatus_Disabled=1 TrdAccStatus_Disabled value
     */
    common.TrdAccStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdAccStatus_Active"] = 0;
        values[valuesById[1] = "TrdAccStatus_Disabled"] = 1;
        return values;
    })();

    /**
     * TrdAccType enum.
     * @name common.TrdAccType
     * @enum {number}
     * @property {number} TrdAccType_Unknown=0 TrdAccType_Unknown value
     * @property {number} TrdAccType_Cash=1 TrdAccType_Cash value
     * @property {number} TrdAccType_Margin=2 TrdAccType_Margin value
     */
    common.TrdAccType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdAccType_Unknown"] = 0;
        values[valuesById[1] = "TrdAccType_Cash"] = 1;
        values[valuesById[2] = "TrdAccType_Margin"] = 2;
        return values;
    })();

    /**
     * SecurityFirm enum.
     * @name common.SecurityFirm
     * @enum {number}
     * @property {number} SecurityFirm_Unknown=0 SecurityFirm_Unknown value
     * @property {number} SecurityFirm_FutuSecurities=1 SecurityFirm_FutuSecurities value
     * @property {number} SecurityFirm_FutuInc=2 SecurityFirm_FutuInc value
     * @property {number} SecurityFirm_FutuSG=3 SecurityFirm_FutuSG value
     * @property {number} SecurityFirm_FutuAU=4 SecurityFirm_FutuAU value
     */
    common.SecurityFirm = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SecurityFirm_Unknown"] = 0;
        values[valuesById[1] = "SecurityFirm_FutuSecurities"] = 1;
        values[valuesById[2] = "SecurityFirm_FutuInc"] = 2;
        values[valuesById[3] = "SecurityFirm_FutuSG"] = 3;
        values[valuesById[4] = "SecurityFirm_FutuAU"] = 4;
        return values;
    })();

    common.Order = (function() {

        /**
         * Properties of an Order.
         * @memberof common
         * @interface IOrder
         * @property {common.TrdSide} trdSide Order trdSide
         * @property {common.OrderType} orderType Order orderType
         * @property {common.OrderStatus} orderStatus Order orderStatus
         * @property {number|Long} orderID Order orderID
         * @property {string} orderIDEx Order orderIDEx
         * @property {string} code Order code
         * @property {string} name Order name
         * @property {number} qty Order qty
         * @property {number|null} [price] Order price
         * @property {string} createTime Order createTime
         * @property {string} updateTime Order updateTime
         * @property {number|null} [fillQty] Order fillQty
         * @property {number|null} [fillAvgPrice] Order fillAvgPrice
         * @property {string|null} [lastErrMsg] Order lastErrMsg
         * @property {common.TrdSecMarket|null} [secMarket] Order secMarket
         * @property {number|null} [createTimestamp] Order createTimestamp
         * @property {number|null} [updateTimestamp] Order updateTimestamp
         * @property {string|null} [remark] Order remark
         * @property {number|null} [auxPrice] Order auxPrice
         * @property {common.TrailType|null} [trailType] Order trailType
         * @property {number|null} [trailValue] Order trailValue
         * @property {number|null} [trailSpread] Order trailSpread
         * @property {common.Currency|null} [currency] Order currency
         * @property {number|null} [trdMarket] Order trdMarket
         */

        /**
         * Constructs a new Order.
         * @memberof common
         * @classdesc Represents an Order.
         * @implements IOrder
         * @constructor
         * @param {common.IOrder=} [properties] Properties to set
         */
        function Order(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Order trdSide.
         * @member {common.TrdSide} trdSide
         * @memberof common.Order
         * @instance
         */
        Order.prototype.trdSide = 0;

        /**
         * Order orderType.
         * @member {common.OrderType} orderType
         * @memberof common.Order
         * @instance
         */
        Order.prototype.orderType = 0;

        /**
         * Order orderStatus.
         * @member {common.OrderStatus} orderStatus
         * @memberof common.Order
         * @instance
         */
        Order.prototype.orderStatus = -1;

        /**
         * Order orderID.
         * @member {number|Long} orderID
         * @memberof common.Order
         * @instance
         */
        Order.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Order orderIDEx.
         * @member {string} orderIDEx
         * @memberof common.Order
         * @instance
         */
        Order.prototype.orderIDEx = "";

        /**
         * Order code.
         * @member {string} code
         * @memberof common.Order
         * @instance
         */
        Order.prototype.code = "";

        /**
         * Order name.
         * @member {string} name
         * @memberof common.Order
         * @instance
         */
        Order.prototype.name = "";

        /**
         * Order qty.
         * @member {number} qty
         * @memberof common.Order
         * @instance
         */
        Order.prototype.qty = 0;

        /**
         * Order price.
         * @member {number} price
         * @memberof common.Order
         * @instance
         */
        Order.prototype.price = 0;

        /**
         * Order createTime.
         * @member {string} createTime
         * @memberof common.Order
         * @instance
         */
        Order.prototype.createTime = "";

        /**
         * Order updateTime.
         * @member {string} updateTime
         * @memberof common.Order
         * @instance
         */
        Order.prototype.updateTime = "";

        /**
         * Order fillQty.
         * @member {number} fillQty
         * @memberof common.Order
         * @instance
         */
        Order.prototype.fillQty = 0;

        /**
         * Order fillAvgPrice.
         * @member {number} fillAvgPrice
         * @memberof common.Order
         * @instance
         */
        Order.prototype.fillAvgPrice = 0;

        /**
         * Order lastErrMsg.
         * @member {string} lastErrMsg
         * @memberof common.Order
         * @instance
         */
        Order.prototype.lastErrMsg = "";

        /**
         * Order secMarket.
         * @member {common.TrdSecMarket} secMarket
         * @memberof common.Order
         * @instance
         */
        Order.prototype.secMarket = 0;

        /**
         * Order createTimestamp.
         * @member {number} createTimestamp
         * @memberof common.Order
         * @instance
         */
        Order.prototype.createTimestamp = 0;

        /**
         * Order updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof common.Order
         * @instance
         */
        Order.prototype.updateTimestamp = 0;

        /**
         * Order remark.
         * @member {string} remark
         * @memberof common.Order
         * @instance
         */
        Order.prototype.remark = "";

        /**
         * Order auxPrice.
         * @member {number} auxPrice
         * @memberof common.Order
         * @instance
         */
        Order.prototype.auxPrice = 0;

        /**
         * Order trailType.
         * @member {common.TrailType} trailType
         * @memberof common.Order
         * @instance
         */
        Order.prototype.trailType = 0;

        /**
         * Order trailValue.
         * @member {number} trailValue
         * @memberof common.Order
         * @instance
         */
        Order.prototype.trailValue = 0;

        /**
         * Order trailSpread.
         * @member {number} trailSpread
         * @memberof common.Order
         * @instance
         */
        Order.prototype.trailSpread = 0;

        /**
         * Order currency.
         * @member {common.Currency} currency
         * @memberof common.Order
         * @instance
         */
        Order.prototype.currency = 0;

        /**
         * Order trdMarket.
         * @member {number} trdMarket
         * @memberof common.Order
         * @instance
         */
        Order.prototype.trdMarket = 0;

        /**
         * Creates a new Order instance using the specified properties.
         * @function create
         * @memberof common.Order
         * @static
         * @param {common.IOrder=} [properties] Properties to set
         * @returns {common.Order} Order instance
         */
        Order.create = function create(properties) {
            return new Order(properties);
        };

        /**
         * Encodes the specified Order message. Does not implicitly {@link common.Order.verify|verify} messages.
         * @function encode
         * @memberof common.Order
         * @static
         * @param {common.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdSide);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orderType);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.orderStatus);
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.orderID);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.orderIDEx);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.code);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.createTime);
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.updateTime);
            if (message.fillQty != null && Object.hasOwnProperty.call(message, "fillQty"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.fillQty);
            if (message.fillAvgPrice != null && Object.hasOwnProperty.call(message, "fillAvgPrice"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.fillAvgPrice);
            if (message.lastErrMsg != null && Object.hasOwnProperty.call(message, "lastErrMsg"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.lastErrMsg);
            if (message.secMarket != null && Object.hasOwnProperty.call(message, "secMarket"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.secMarket);
            if (message.createTimestamp != null && Object.hasOwnProperty.call(message, "createTimestamp"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.createTimestamp);
            if (message.updateTimestamp != null && Object.hasOwnProperty.call(message, "updateTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.updateTimestamp);
            if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.remark);
            if (message.auxPrice != null && Object.hasOwnProperty.call(message, "auxPrice"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.auxPrice);
            if (message.trailType != null && Object.hasOwnProperty.call(message, "trailType"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.trailType);
            if (message.trailValue != null && Object.hasOwnProperty.call(message, "trailValue"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.trailValue);
            if (message.trailSpread != null && Object.hasOwnProperty.call(message, "trailSpread"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.trailSpread);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.currency);
            if (message.trdMarket != null && Object.hasOwnProperty.call(message, "trdMarket"))
                writer.uint32(/* id 26, wireType 0 =*/208).int32(message.trdMarket);
            return writer;
        };

        /**
         * Encodes the specified Order message, length delimited. Does not implicitly {@link common.Order.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.Order
         * @static
         * @param {common.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Order message from the specified reader or buffer.
         * @function decode
         * @memberof common.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Order();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.trdSide = reader.int32();
                        break;
                    }
                case 2: {
                        message.orderType = reader.int32();
                        break;
                    }
                case 3: {
                        message.orderStatus = reader.int32();
                        break;
                    }
                case 4: {
                        message.orderID = reader.uint64();
                        break;
                    }
                case 5: {
                        message.orderIDEx = reader.string();
                        break;
                    }
                case 6: {
                        message.code = reader.string();
                        break;
                    }
                case 7: {
                        message.name = reader.string();
                        break;
                    }
                case 8: {
                        message.qty = reader.double();
                        break;
                    }
                case 9: {
                        message.price = reader.double();
                        break;
                    }
                case 10: {
                        message.createTime = reader.string();
                        break;
                    }
                case 11: {
                        message.updateTime = reader.string();
                        break;
                    }
                case 12: {
                        message.fillQty = reader.double();
                        break;
                    }
                case 13: {
                        message.fillAvgPrice = reader.double();
                        break;
                    }
                case 14: {
                        message.lastErrMsg = reader.string();
                        break;
                    }
                case 15: {
                        message.secMarket = reader.int32();
                        break;
                    }
                case 16: {
                        message.createTimestamp = reader.double();
                        break;
                    }
                case 17: {
                        message.updateTimestamp = reader.double();
                        break;
                    }
                case 18: {
                        message.remark = reader.string();
                        break;
                    }
                case 21: {
                        message.auxPrice = reader.double();
                        break;
                    }
                case 22: {
                        message.trailType = reader.int32();
                        break;
                    }
                case 23: {
                        message.trailValue = reader.double();
                        break;
                    }
                case 24: {
                        message.trailSpread = reader.double();
                        break;
                    }
                case 25: {
                        message.currency = reader.int32();
                        break;
                    }
                case 26: {
                        message.trdMarket = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("orderType"))
                throw $util.ProtocolError("missing required 'orderType'", { instance: message });
            if (!message.hasOwnProperty("orderStatus"))
                throw $util.ProtocolError("missing required 'orderStatus'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("orderIDEx"))
                throw $util.ProtocolError("missing required 'orderIDEx'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an Order message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Order message.
         * @function verify
         * @memberof common.Order
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Order.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.trdSide) {
            default:
                return "trdSide: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            switch (message.orderType) {
            default:
                return "orderType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
                break;
            }
            switch (message.orderStatus) {
            default:
                return "orderStatus: enum value expected";
            case -1:
            case 1:
            case 2:
            case 5:
            case 10:
            case 11:
            case 14:
            case 15:
            case 21:
            case 22:
            case 23:
            case 24:
                break;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isString(message.orderIDEx))
                return "orderIDEx: string expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (!$util.isString(message.createTime))
                return "createTime: string expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                if (typeof message.fillQty !== "number")
                    return "fillQty: number expected";
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                if (typeof message.fillAvgPrice !== "number")
                    return "fillAvgPrice: number expected";
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                if (!$util.isString(message.lastErrMsg))
                    return "lastErrMsg: string expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                switch (message.secMarket) {
                default:
                    return "secMarket: enum value expected";
                case 0:
                case 1:
                case 2:
                case 31:
                case 32:
                case 41:
                case 51:
                case 61:
                case 71:
                case 81:
                case 91:
                    break;
                }
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                if (typeof message.createTimestamp !== "number")
                    return "createTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.remark != null && message.hasOwnProperty("remark"))
                if (!$util.isString(message.remark))
                    return "remark: string expected";
            if (message.auxPrice != null && message.hasOwnProperty("auxPrice"))
                if (typeof message.auxPrice !== "number")
                    return "auxPrice: number expected";
            if (message.trailType != null && message.hasOwnProperty("trailType"))
                switch (message.trailType) {
                default:
                    return "trailType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.trailValue != null && message.hasOwnProperty("trailValue"))
                if (typeof message.trailValue !== "number")
                    return "trailValue: number expected";
            if (message.trailSpread != null && message.hasOwnProperty("trailSpread"))
                if (typeof message.trailSpread !== "number")
                    return "trailSpread: number expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                switch (message.currency) {
                default:
                    return "currency: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                if (!$util.isInteger(message.trdMarket))
                    return "trdMarket: integer expected";
            return null;
        };

        /**
         * Creates an Order message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.Order
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.Order} Order
         */
        Order.fromObject = function fromObject(object) {
            if (object instanceof $root.common.Order)
                return object;
            let message = new $root.common.Order();
            switch (object.trdSide) {
            default:
                if (typeof object.trdSide === "number") {
                    message.trdSide = object.trdSide;
                    break;
                }
                break;
            case "TrdSide_Unknown":
            case 0:
                message.trdSide = 0;
                break;
            case "TrdSide_Buy":
            case 1:
                message.trdSide = 1;
                break;
            case "TrdSide_Sell":
            case 2:
                message.trdSide = 2;
                break;
            case "TrdSide_SellShort":
            case 3:
                message.trdSide = 3;
                break;
            case "TrdSide_BuyBack":
            case 4:
                message.trdSide = 4;
                break;
            }
            switch (object.orderType) {
            default:
                if (typeof object.orderType === "number") {
                    message.orderType = object.orderType;
                    break;
                }
                break;
            case "OrderType_Unknown":
            case 0:
                message.orderType = 0;
                break;
            case "OrderType_Normal":
            case 1:
                message.orderType = 1;
                break;
            case "OrderType_Market":
            case 2:
                message.orderType = 2;
                break;
            case "OrderType_AbsoluteLimit":
            case 5:
                message.orderType = 5;
                break;
            case "OrderType_Auction":
            case 6:
                message.orderType = 6;
                break;
            case "OrderType_AuctionLimit":
            case 7:
                message.orderType = 7;
                break;
            case "OrderType_SpecialLimit":
            case 8:
                message.orderType = 8;
                break;
            case "OrderType_SpecialLimit_All":
            case 9:
                message.orderType = 9;
                break;
            case "OrderType_Stop":
            case 10:
                message.orderType = 10;
                break;
            case "OrderType_StopLimit":
            case 11:
                message.orderType = 11;
                break;
            case "OrderType_MarketifTouched":
            case 12:
                message.orderType = 12;
                break;
            case "OrderType_LimitifTouched":
            case 13:
                message.orderType = 13;
                break;
            case "OrderType_TrailingStop":
            case 14:
                message.orderType = 14;
                break;
            case "OrderType_TrailingStopLimit":
            case 15:
                message.orderType = 15;
                break;
            case "OrderType_TWAP":
            case 16:
                message.orderType = 16;
                break;
            case "OrderType_TWAP_LIMIT":
            case 17:
                message.orderType = 17;
                break;
            case "OrderType_VWAP":
            case 18:
                message.orderType = 18;
                break;
            case "OrderType_VWAP_LIMIT":
            case 19:
                message.orderType = 19;
                break;
            }
            switch (object.orderStatus) {
            default:
                if (typeof object.orderStatus === "number") {
                    message.orderStatus = object.orderStatus;
                    break;
                }
                break;
            case "OrderStatus_Unknown":
            case -1:
                message.orderStatus = -1;
                break;
            case "OrderStatus_WaitingSubmit":
            case 1:
                message.orderStatus = 1;
                break;
            case "OrderStatus_Submitting":
            case 2:
                message.orderStatus = 2;
                break;
            case "OrderStatus_Submitted":
            case 5:
                message.orderStatus = 5;
                break;
            case "OrderStatus_Filled_Part":
            case 10:
                message.orderStatus = 10;
                break;
            case "OrderStatus_Filled_All":
            case 11:
                message.orderStatus = 11;
                break;
            case "OrderStatus_Cancelled_Part":
            case 14:
                message.orderStatus = 14;
                break;
            case "OrderStatus_Cancelled_All":
            case 15:
                message.orderStatus = 15;
                break;
            case "OrderStatus_Failed":
            case 21:
                message.orderStatus = 21;
                break;
            case "OrderStatus_Disabled":
            case 22:
                message.orderStatus = 22;
                break;
            case "OrderStatus_Deleted":
            case 23:
                message.orderStatus = 23;
                break;
            case "OrderStatus_FillCancelled":
            case 24:
                message.orderStatus = 24;
                break;
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.orderIDEx != null)
                message.orderIDEx = String(object.orderIDEx);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.createTime != null)
                message.createTime = String(object.createTime);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.fillQty != null)
                message.fillQty = Number(object.fillQty);
            if (object.fillAvgPrice != null)
                message.fillAvgPrice = Number(object.fillAvgPrice);
            if (object.lastErrMsg != null)
                message.lastErrMsg = String(object.lastErrMsg);
            switch (object.secMarket) {
            default:
                if (typeof object.secMarket === "number") {
                    message.secMarket = object.secMarket;
                    break;
                }
                break;
            case "TrdSecMarket_Unknown":
            case 0:
                message.secMarket = 0;
                break;
            case "TrdSecMarket_HK":
            case 1:
                message.secMarket = 1;
                break;
            case "TrdSecMarket_US":
            case 2:
                message.secMarket = 2;
                break;
            case "TrdSecMarket_CN_SH":
            case 31:
                message.secMarket = 31;
                break;
            case "TrdSecMarket_CN_SZ":
            case 32:
                message.secMarket = 32;
                break;
            case "TrdSecMarket_SG":
            case 41:
                message.secMarket = 41;
                break;
            case "TrdSecMarket_JP":
            case 51:
                message.secMarket = 51;
                break;
            case "TrdSecMarket_AU":
            case 61:
                message.secMarket = 61;
                break;
            case "TrdSecMarket_MY":
            case 71:
                message.secMarket = 71;
                break;
            case "TrdSecMarket_CA":
            case 81:
                message.secMarket = 81;
                break;
            case "TrdSecMarket_FX":
            case 91:
                message.secMarket = 91;
                break;
            }
            if (object.createTimestamp != null)
                message.createTimestamp = Number(object.createTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.remark != null)
                message.remark = String(object.remark);
            if (object.auxPrice != null)
                message.auxPrice = Number(object.auxPrice);
            switch (object.trailType) {
            default:
                if (typeof object.trailType === "number") {
                    message.trailType = object.trailType;
                    break;
                }
                break;
            case "TrailType_Unknown":
            case 0:
                message.trailType = 0;
                break;
            case "TrailType_Ratio":
            case 1:
                message.trailType = 1;
                break;
            case "TrailType_Amount":
            case 2:
                message.trailType = 2;
                break;
            }
            if (object.trailValue != null)
                message.trailValue = Number(object.trailValue);
            if (object.trailSpread != null)
                message.trailSpread = Number(object.trailSpread);
            switch (object.currency) {
            default:
                if (typeof object.currency === "number") {
                    message.currency = object.currency;
                    break;
                }
                break;
            case "Currency_Unknown":
            case 0:
                message.currency = 0;
                break;
            case "Currency_HKD":
            case 1:
                message.currency = 1;
                break;
            case "Currency_USD":
            case 2:
                message.currency = 2;
                break;
            case "Currency_CNH":
            case 3:
                message.currency = 3;
                break;
            case "Currency_JPY":
            case 4:
                message.currency = 4;
                break;
            case "Currency_SGD":
            case 5:
                message.currency = 5;
                break;
            case "Currency_AUD":
            case 6:
                message.currency = 6;
                break;
            case "Currency_CAD":
            case 7:
                message.currency = 7;
                break;
            case "Currency_MYR":
            case 8:
                message.currency = 8;
                break;
            }
            if (object.trdMarket != null)
                message.trdMarket = object.trdMarket | 0;
            return message;
        };

        /**
         * Creates a plain object from an Order message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.Order
         * @static
         * @param {common.Order} message Order
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Order.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.trdSide = options.enums === String ? "TrdSide_Unknown" : 0;
                object.orderType = options.enums === String ? "OrderType_Unknown" : 0;
                object.orderStatus = options.enums === String ? "OrderStatus_Unknown" : -1;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.orderIDEx = "";
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.price = 0;
                object.createTime = "";
                object.updateTime = "";
                object.fillQty = 0;
                object.fillAvgPrice = 0;
                object.lastErrMsg = "";
                object.secMarket = options.enums === String ? "TrdSecMarket_Unknown" : 0;
                object.createTimestamp = 0;
                object.updateTimestamp = 0;
                object.remark = "";
                object.auxPrice = 0;
                object.trailType = options.enums === String ? "TrailType_Unknown" : 0;
                object.trailValue = 0;
                object.trailSpread = 0;
                object.currency = options.enums === String ? "Currency_Unknown" : 0;
                object.trdMarket = 0;
            }
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = options.enums === String ? $root.common.TrdSide[message.trdSide] === undefined ? message.trdSide : $root.common.TrdSide[message.trdSide] : message.trdSide;
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = options.enums === String ? $root.common.OrderType[message.orderType] === undefined ? message.orderType : $root.common.OrderType[message.orderType] : message.orderType;
            if (message.orderStatus != null && message.hasOwnProperty("orderStatus"))
                object.orderStatus = options.enums === String ? $root.common.OrderStatus[message.orderStatus] === undefined ? message.orderStatus : $root.common.OrderStatus[message.orderStatus] : message.orderStatus;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                object.orderIDEx = message.orderIDEx;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                object.fillQty = options.json && !isFinite(message.fillQty) ? String(message.fillQty) : message.fillQty;
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                object.fillAvgPrice = options.json && !isFinite(message.fillAvgPrice) ? String(message.fillAvgPrice) : message.fillAvgPrice;
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                object.lastErrMsg = message.lastErrMsg;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = options.enums === String ? $root.common.TrdSecMarket[message.secMarket] === undefined ? message.secMarket : $root.common.TrdSecMarket[message.secMarket] : message.secMarket;
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                object.createTimestamp = options.json && !isFinite(message.createTimestamp) ? String(message.createTimestamp) : message.createTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.remark != null && message.hasOwnProperty("remark"))
                object.remark = message.remark;
            if (message.auxPrice != null && message.hasOwnProperty("auxPrice"))
                object.auxPrice = options.json && !isFinite(message.auxPrice) ? String(message.auxPrice) : message.auxPrice;
            if (message.trailType != null && message.hasOwnProperty("trailType"))
                object.trailType = options.enums === String ? $root.common.TrailType[message.trailType] === undefined ? message.trailType : $root.common.TrailType[message.trailType] : message.trailType;
            if (message.trailValue != null && message.hasOwnProperty("trailValue"))
                object.trailValue = options.json && !isFinite(message.trailValue) ? String(message.trailValue) : message.trailValue;
            if (message.trailSpread != null && message.hasOwnProperty("trailSpread"))
                object.trailSpread = options.json && !isFinite(message.trailSpread) ? String(message.trailSpread) : message.trailSpread;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = options.enums === String ? $root.common.Currency[message.currency] === undefined ? message.currency : $root.common.Currency[message.currency] : message.currency;
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                object.trdMarket = message.trdMarket;
            return object;
        };

        /**
         * Converts this Order to JSON.
         * @function toJSON
         * @memberof common.Order
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Order.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Order
         * @function getTypeUrl
         * @memberof common.Order
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Order.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.Order";
        };

        return Order;
    })();

    /**
     * OrderStatus enum.
     * @name common.OrderStatus
     * @enum {number}
     * @property {number} OrderStatus_Unknown=-1 OrderStatus_Unknown value
     * @property {number} OrderStatus_WaitingSubmit=1 OrderStatus_WaitingSubmit value
     * @property {number} OrderStatus_Submitting=2 OrderStatus_Submitting value
     * @property {number} OrderStatus_Submitted=5 OrderStatus_Submitted value
     * @property {number} OrderStatus_Filled_Part=10 OrderStatus_Filled_Part value
     * @property {number} OrderStatus_Filled_All=11 OrderStatus_Filled_All value
     * @property {number} OrderStatus_Cancelled_Part=14 OrderStatus_Cancelled_Part value
     * @property {number} OrderStatus_Cancelled_All=15 OrderStatus_Cancelled_All value
     * @property {number} OrderStatus_Failed=21 OrderStatus_Failed value
     * @property {number} OrderStatus_Disabled=22 OrderStatus_Disabled value
     * @property {number} OrderStatus_Deleted=23 OrderStatus_Deleted value
     * @property {number} OrderStatus_FillCancelled=24 OrderStatus_FillCancelled value
     */
    common.OrderStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "OrderStatus_Unknown"] = -1;
        values[valuesById[1] = "OrderStatus_WaitingSubmit"] = 1;
        values[valuesById[2] = "OrderStatus_Submitting"] = 2;
        values[valuesById[5] = "OrderStatus_Submitted"] = 5;
        values[valuesById[10] = "OrderStatus_Filled_Part"] = 10;
        values[valuesById[11] = "OrderStatus_Filled_All"] = 11;
        values[valuesById[14] = "OrderStatus_Cancelled_Part"] = 14;
        values[valuesById[15] = "OrderStatus_Cancelled_All"] = 15;
        values[valuesById[21] = "OrderStatus_Failed"] = 21;
        values[valuesById[22] = "OrderStatus_Disabled"] = 22;
        values[valuesById[23] = "OrderStatus_Deleted"] = 23;
        values[valuesById[24] = "OrderStatus_FillCancelled"] = 24;
        return values;
    })();

    common.OrderFill = (function() {

        /**
         * Properties of an OrderFill.
         * @memberof common
         * @interface IOrderFill
         * @property {common.TrdSide} trdSide OrderFill trdSide
         * @property {number|Long} fillID OrderFill fillID
         * @property {string} fillIDEx OrderFill fillIDEx
         * @property {number|Long|null} [orderID] OrderFill orderID
         * @property {string|null} [orderIDEx] OrderFill orderIDEx
         * @property {string} code OrderFill code
         * @property {string} name OrderFill name
         * @property {number} qty OrderFill qty
         * @property {number} price OrderFill price
         * @property {string} createTime OrderFill createTime
         * @property {number|null} [counterBrokerID] OrderFill counterBrokerID
         * @property {string|null} [counterBrokerName] OrderFill counterBrokerName
         * @property {common.TrdSecMarket|null} [secMarket] OrderFill secMarket
         * @property {number|null} [createTimestamp] OrderFill createTimestamp
         * @property {number|null} [updateTimestamp] OrderFill updateTimestamp
         * @property {common.OrderFillStatus|null} [status] OrderFill status
         * @property {common.TrdMarket|null} [trdMarket] OrderFill trdMarket
         */

        /**
         * Constructs a new OrderFill.
         * @memberof common
         * @classdesc Represents an OrderFill.
         * @implements IOrderFill
         * @constructor
         * @param {common.IOrderFill=} [properties] Properties to set
         */
        function OrderFill(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderFill trdSide.
         * @member {common.TrdSide} trdSide
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.trdSide = 0;

        /**
         * OrderFill fillID.
         * @member {number|Long} fillID
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.fillID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * OrderFill fillIDEx.
         * @member {string} fillIDEx
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.fillIDEx = "";

        /**
         * OrderFill orderID.
         * @member {number|Long} orderID
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * OrderFill orderIDEx.
         * @member {string} orderIDEx
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.orderIDEx = "";

        /**
         * OrderFill code.
         * @member {string} code
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.code = "";

        /**
         * OrderFill name.
         * @member {string} name
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.name = "";

        /**
         * OrderFill qty.
         * @member {number} qty
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.qty = 0;

        /**
         * OrderFill price.
         * @member {number} price
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.price = 0;

        /**
         * OrderFill createTime.
         * @member {string} createTime
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.createTime = "";

        /**
         * OrderFill counterBrokerID.
         * @member {number} counterBrokerID
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.counterBrokerID = 0;

        /**
         * OrderFill counterBrokerName.
         * @member {string} counterBrokerName
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.counterBrokerName = "";

        /**
         * OrderFill secMarket.
         * @member {common.TrdSecMarket} secMarket
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.secMarket = 0;

        /**
         * OrderFill createTimestamp.
         * @member {number} createTimestamp
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.createTimestamp = 0;

        /**
         * OrderFill updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.updateTimestamp = 0;

        /**
         * OrderFill status.
         * @member {common.OrderFillStatus} status
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.status = 0;

        /**
         * OrderFill trdMarket.
         * @member {common.TrdMarket} trdMarket
         * @memberof common.OrderFill
         * @instance
         */
        OrderFill.prototype.trdMarket = 0;

        /**
         * Creates a new OrderFill instance using the specified properties.
         * @function create
         * @memberof common.OrderFill
         * @static
         * @param {common.IOrderFill=} [properties] Properties to set
         * @returns {common.OrderFill} OrderFill instance
         */
        OrderFill.create = function create(properties) {
            return new OrderFill(properties);
        };

        /**
         * Encodes the specified OrderFill message. Does not implicitly {@link common.OrderFill.verify|verify} messages.
         * @function encode
         * @memberof common.OrderFill
         * @static
         * @param {common.IOrderFill} message OrderFill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdSide);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fillID);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.fillIDEx);
            if (message.orderID != null && Object.hasOwnProperty.call(message, "orderID"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.orderID);
            if (message.orderIDEx != null && Object.hasOwnProperty.call(message, "orderIDEx"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.orderIDEx);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.code);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.createTime);
            if (message.counterBrokerID != null && Object.hasOwnProperty.call(message, "counterBrokerID"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.counterBrokerID);
            if (message.counterBrokerName != null && Object.hasOwnProperty.call(message, "counterBrokerName"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.counterBrokerName);
            if (message.secMarket != null && Object.hasOwnProperty.call(message, "secMarket"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.secMarket);
            if (message.createTimestamp != null && Object.hasOwnProperty.call(message, "createTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.createTimestamp);
            if (message.updateTimestamp != null && Object.hasOwnProperty.call(message, "updateTimestamp"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.updateTimestamp);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.status);
            if (message.trdMarket != null && Object.hasOwnProperty.call(message, "trdMarket"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.trdMarket);
            return writer;
        };

        /**
         * Encodes the specified OrderFill message, length delimited. Does not implicitly {@link common.OrderFill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.OrderFill
         * @static
         * @param {common.IOrderFill} message OrderFill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderFill message from the specified reader or buffer.
         * @function decode
         * @memberof common.OrderFill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.OrderFill} OrderFill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrderFill();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.trdSide = reader.int32();
                        break;
                    }
                case 2: {
                        message.fillID = reader.uint64();
                        break;
                    }
                case 3: {
                        message.fillIDEx = reader.string();
                        break;
                    }
                case 4: {
                        message.orderID = reader.uint64();
                        break;
                    }
                case 5: {
                        message.orderIDEx = reader.string();
                        break;
                    }
                case 6: {
                        message.code = reader.string();
                        break;
                    }
                case 7: {
                        message.name = reader.string();
                        break;
                    }
                case 8: {
                        message.qty = reader.double();
                        break;
                    }
                case 9: {
                        message.price = reader.double();
                        break;
                    }
                case 10: {
                        message.createTime = reader.string();
                        break;
                    }
                case 11: {
                        message.counterBrokerID = reader.int32();
                        break;
                    }
                case 12: {
                        message.counterBrokerName = reader.string();
                        break;
                    }
                case 13: {
                        message.secMarket = reader.int32();
                        break;
                    }
                case 14: {
                        message.createTimestamp = reader.double();
                        break;
                    }
                case 15: {
                        message.updateTimestamp = reader.double();
                        break;
                    }
                case 16: {
                        message.status = reader.int32();
                        break;
                    }
                case 17: {
                        message.trdMarket = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("fillID"))
                throw $util.ProtocolError("missing required 'fillID'", { instance: message });
            if (!message.hasOwnProperty("fillIDEx"))
                throw $util.ProtocolError("missing required 'fillIDEx'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderFill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.OrderFill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.OrderFill} OrderFill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderFill message.
         * @function verify
         * @memberof common.OrderFill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderFill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.trdSide) {
            default:
                return "trdSide: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            if (!$util.isInteger(message.fillID) && !(message.fillID && $util.isInteger(message.fillID.low) && $util.isInteger(message.fillID.high)))
                return "fillID: integer|Long expected";
            if (!$util.isString(message.fillIDEx))
                return "fillIDEx: string expected";
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                if (!$util.isString(message.orderIDEx))
                    return "orderIDEx: string expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (!$util.isString(message.createTime))
                return "createTime: string expected";
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                if (!$util.isInteger(message.counterBrokerID))
                    return "counterBrokerID: integer expected";
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                if (!$util.isString(message.counterBrokerName))
                    return "counterBrokerName: string expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                switch (message.secMarket) {
                default:
                    return "secMarket: enum value expected";
                case 0:
                case 1:
                case 2:
                case 31:
                case 32:
                case 41:
                case 51:
                case 61:
                case 71:
                case 81:
                case 91:
                    break;
                }
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                if (typeof message.createTimestamp !== "number")
                    return "createTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                switch (message.trdMarket) {
                default:
                    return "trdMarket: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 8:
                case 10:
                case 11:
                case 12:
                case 13:
                case 15:
                case 111:
                case 112:
                case 113:
                case 123:
                    break;
                }
            return null;
        };

        /**
         * Creates an OrderFill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.OrderFill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.OrderFill} OrderFill
         */
        OrderFill.fromObject = function fromObject(object) {
            if (object instanceof $root.common.OrderFill)
                return object;
            let message = new $root.common.OrderFill();
            switch (object.trdSide) {
            default:
                if (typeof object.trdSide === "number") {
                    message.trdSide = object.trdSide;
                    break;
                }
                break;
            case "TrdSide_Unknown":
            case 0:
                message.trdSide = 0;
                break;
            case "TrdSide_Buy":
            case 1:
                message.trdSide = 1;
                break;
            case "TrdSide_Sell":
            case 2:
                message.trdSide = 2;
                break;
            case "TrdSide_SellShort":
            case 3:
                message.trdSide = 3;
                break;
            case "TrdSide_BuyBack":
            case 4:
                message.trdSide = 4;
                break;
            }
            if (object.fillID != null)
                if ($util.Long)
                    (message.fillID = $util.Long.fromValue(object.fillID)).unsigned = true;
                else if (typeof object.fillID === "string")
                    message.fillID = parseInt(object.fillID, 10);
                else if (typeof object.fillID === "number")
                    message.fillID = object.fillID;
                else if (typeof object.fillID === "object")
                    message.fillID = new $util.LongBits(object.fillID.low >>> 0, object.fillID.high >>> 0).toNumber(true);
            if (object.fillIDEx != null)
                message.fillIDEx = String(object.fillIDEx);
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.orderIDEx != null)
                message.orderIDEx = String(object.orderIDEx);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.createTime != null)
                message.createTime = String(object.createTime);
            if (object.counterBrokerID != null)
                message.counterBrokerID = object.counterBrokerID | 0;
            if (object.counterBrokerName != null)
                message.counterBrokerName = String(object.counterBrokerName);
            switch (object.secMarket) {
            default:
                if (typeof object.secMarket === "number") {
                    message.secMarket = object.secMarket;
                    break;
                }
                break;
            case "TrdSecMarket_Unknown":
            case 0:
                message.secMarket = 0;
                break;
            case "TrdSecMarket_HK":
            case 1:
                message.secMarket = 1;
                break;
            case "TrdSecMarket_US":
            case 2:
                message.secMarket = 2;
                break;
            case "TrdSecMarket_CN_SH":
            case 31:
                message.secMarket = 31;
                break;
            case "TrdSecMarket_CN_SZ":
            case 32:
                message.secMarket = 32;
                break;
            case "TrdSecMarket_SG":
            case 41:
                message.secMarket = 41;
                break;
            case "TrdSecMarket_JP":
            case 51:
                message.secMarket = 51;
                break;
            case "TrdSecMarket_AU":
            case 61:
                message.secMarket = 61;
                break;
            case "TrdSecMarket_MY":
            case 71:
                message.secMarket = 71;
                break;
            case "TrdSecMarket_CA":
            case 81:
                message.secMarket = 81;
                break;
            case "TrdSecMarket_FX":
            case 91:
                message.secMarket = 91;
                break;
            }
            if (object.createTimestamp != null)
                message.createTimestamp = Number(object.createTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "OrderFillStatus_OK":
            case 0:
                message.status = 0;
                break;
            case "OrderFillStatus_Cancelled":
            case 1:
                message.status = 1;
                break;
            case "OrderFillStatus_Changed":
            case 2:
                message.status = 2;
                break;
            }
            switch (object.trdMarket) {
            default:
                if (typeof object.trdMarket === "number") {
                    message.trdMarket = object.trdMarket;
                    break;
                }
                break;
            case "TrdMarket_Unknown":
            case 0:
                message.trdMarket = 0;
                break;
            case "TrdMarket_HK":
            case 1:
                message.trdMarket = 1;
                break;
            case "TrdMarket_US":
            case 2:
                message.trdMarket = 2;
                break;
            case "TrdMarket_CN":
            case 3:
                message.trdMarket = 3;
                break;
            case "TrdMarket_HKCC":
            case 4:
                message.trdMarket = 4;
                break;
            case "TrdMarket_Futures":
            case 5:
                message.trdMarket = 5;
                break;
            case "TrdMarket_SG":
            case 6:
                message.trdMarket = 6;
                break;
            case "TrdMarket_AU":
            case 8:
                message.trdMarket = 8;
                break;
            case "TrdMarket_Futures_Simulate_HK":
            case 10:
                message.trdMarket = 10;
                break;
            case "TrdMarket_Futures_Simulate_US":
            case 11:
                message.trdMarket = 11;
                break;
            case "TrdMarket_Futures_Simulate_SG":
            case 12:
                message.trdMarket = 12;
                break;
            case "TrdMarket_Futures_Simulate_JP":
            case 13:
                message.trdMarket = 13;
                break;
            case "TrdMarket_JP":
            case 15:
                message.trdMarket = 15;
                break;
            case "TrdMarket_MY":
            case 111:
                message.trdMarket = 111;
                break;
            case "TrdMarket_CA":
            case 112:
                message.trdMarket = 112;
                break;
            case "TrdMarket_HK_Fund":
            case 113:
                message.trdMarket = 113;
                break;
            case "TrdMarket_US_Fund":
            case 123:
                message.trdMarket = 123;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderFill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.OrderFill
         * @static
         * @param {common.OrderFill} message OrderFill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderFill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.trdSide = options.enums === String ? "TrdSide_Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.fillID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fillID = options.longs === String ? "0" : 0;
                object.fillIDEx = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.orderIDEx = "";
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.price = 0;
                object.createTime = "";
                object.counterBrokerID = 0;
                object.counterBrokerName = "";
                object.secMarket = options.enums === String ? "TrdSecMarket_Unknown" : 0;
                object.createTimestamp = 0;
                object.updateTimestamp = 0;
                object.status = options.enums === String ? "OrderFillStatus_OK" : 0;
                object.trdMarket = options.enums === String ? "TrdMarket_Unknown" : 0;
            }
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = options.enums === String ? $root.common.TrdSide[message.trdSide] === undefined ? message.trdSide : $root.common.TrdSide[message.trdSide] : message.trdSide;
            if (message.fillID != null && message.hasOwnProperty("fillID"))
                if (typeof message.fillID === "number")
                    object.fillID = options.longs === String ? String(message.fillID) : message.fillID;
                else
                    object.fillID = options.longs === String ? $util.Long.prototype.toString.call(message.fillID) : options.longs === Number ? new $util.LongBits(message.fillID.low >>> 0, message.fillID.high >>> 0).toNumber(true) : message.fillID;
            if (message.fillIDEx != null && message.hasOwnProperty("fillIDEx"))
                object.fillIDEx = message.fillIDEx;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                object.orderIDEx = message.orderIDEx;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                object.counterBrokerID = message.counterBrokerID;
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                object.counterBrokerName = message.counterBrokerName;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = options.enums === String ? $root.common.TrdSecMarket[message.secMarket] === undefined ? message.secMarket : $root.common.TrdSecMarket[message.secMarket] : message.secMarket;
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                object.createTimestamp = options.json && !isFinite(message.createTimestamp) ? String(message.createTimestamp) : message.createTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.common.OrderFillStatus[message.status] === undefined ? message.status : $root.common.OrderFillStatus[message.status] : message.status;
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                object.trdMarket = options.enums === String ? $root.common.TrdMarket[message.trdMarket] === undefined ? message.trdMarket : $root.common.TrdMarket[message.trdMarket] : message.trdMarket;
            return object;
        };

        /**
         * Converts this OrderFill to JSON.
         * @function toJSON
         * @memberof common.OrderFill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderFill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderFill
         * @function getTypeUrl
         * @memberof common.OrderFill
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderFill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.OrderFill";
        };

        return OrderFill;
    })();

    /**
     * OrderFillStatus enum.
     * @name common.OrderFillStatus
     * @enum {number}
     * @property {number} OrderFillStatus_OK=0 OrderFillStatus_OK value
     * @property {number} OrderFillStatus_Cancelled=1 OrderFillStatus_Cancelled value
     * @property {number} OrderFillStatus_Changed=2 OrderFillStatus_Changed value
     */
    common.OrderFillStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OrderFillStatus_OK"] = 0;
        values[valuesById[1] = "OrderFillStatus_Cancelled"] = 1;
        values[valuesById[2] = "OrderFillStatus_Changed"] = 2;
        return values;
    })();

    common.OrderFee = (function() {

        /**
         * Properties of an OrderFee.
         * @memberof common
         * @interface IOrderFee
         * @property {string} orderIDEx OrderFee orderIDEx
         * @property {number|null} [feeAmount] OrderFee feeAmount
         * @property {Array.<common.IOrderFeeItem>|null} [feeList] OrderFee feeList
         */

        /**
         * Constructs a new OrderFee.
         * @memberof common
         * @classdesc Represents an OrderFee.
         * @implements IOrderFee
         * @constructor
         * @param {common.IOrderFee=} [properties] Properties to set
         */
        function OrderFee(properties) {
            this.feeList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderFee orderIDEx.
         * @member {string} orderIDEx
         * @memberof common.OrderFee
         * @instance
         */
        OrderFee.prototype.orderIDEx = "";

        /**
         * OrderFee feeAmount.
         * @member {number} feeAmount
         * @memberof common.OrderFee
         * @instance
         */
        OrderFee.prototype.feeAmount = 0;

        /**
         * OrderFee feeList.
         * @member {Array.<common.IOrderFeeItem>} feeList
         * @memberof common.OrderFee
         * @instance
         */
        OrderFee.prototype.feeList = $util.emptyArray;

        /**
         * Creates a new OrderFee instance using the specified properties.
         * @function create
         * @memberof common.OrderFee
         * @static
         * @param {common.IOrderFee=} [properties] Properties to set
         * @returns {common.OrderFee} OrderFee instance
         */
        OrderFee.create = function create(properties) {
            return new OrderFee(properties);
        };

        /**
         * Encodes the specified OrderFee message. Does not implicitly {@link common.OrderFee.verify|verify} messages.
         * @function encode
         * @memberof common.OrderFee
         * @static
         * @param {common.IOrderFee} message OrderFee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFee.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderIDEx);
            if (message.feeAmount != null && Object.hasOwnProperty.call(message, "feeAmount"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.feeAmount);
            if (message.feeList != null && message.feeList.length)
                for (let i = 0; i < message.feeList.length; ++i)
                    $root.common.OrderFeeItem.encode(message.feeList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OrderFee message, length delimited. Does not implicitly {@link common.OrderFee.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.OrderFee
         * @static
         * @param {common.IOrderFee} message OrderFee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFee.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderFee message from the specified reader or buffer.
         * @function decode
         * @memberof common.OrderFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.OrderFee} OrderFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFee.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrderFee();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.orderIDEx = reader.string();
                        break;
                    }
                case 2: {
                        message.feeAmount = reader.double();
                        break;
                    }
                case 3: {
                        if (!(message.feeList && message.feeList.length))
                            message.feeList = [];
                        message.feeList.push($root.common.OrderFeeItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("orderIDEx"))
                throw $util.ProtocolError("missing required 'orderIDEx'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderFee message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.OrderFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.OrderFee} OrderFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFee.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderFee message.
         * @function verify
         * @memberof common.OrderFee
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderFee.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.orderIDEx))
                return "orderIDEx: string expected";
            if (message.feeAmount != null && message.hasOwnProperty("feeAmount"))
                if (typeof message.feeAmount !== "number")
                    return "feeAmount: number expected";
            if (message.feeList != null && message.hasOwnProperty("feeList")) {
                if (!Array.isArray(message.feeList))
                    return "feeList: array expected";
                for (let i = 0; i < message.feeList.length; ++i) {
                    let error = $root.common.OrderFeeItem.verify(message.feeList[i]);
                    if (error)
                        return "feeList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OrderFee message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.OrderFee
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.OrderFee} OrderFee
         */
        OrderFee.fromObject = function fromObject(object) {
            if (object instanceof $root.common.OrderFee)
                return object;
            let message = new $root.common.OrderFee();
            if (object.orderIDEx != null)
                message.orderIDEx = String(object.orderIDEx);
            if (object.feeAmount != null)
                message.feeAmount = Number(object.feeAmount);
            if (object.feeList) {
                if (!Array.isArray(object.feeList))
                    throw TypeError(".common.OrderFee.feeList: array expected");
                message.feeList = [];
                for (let i = 0; i < object.feeList.length; ++i) {
                    if (typeof object.feeList[i] !== "object")
                        throw TypeError(".common.OrderFee.feeList: object expected");
                    message.feeList[i] = $root.common.OrderFeeItem.fromObject(object.feeList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderFee message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.OrderFee
         * @static
         * @param {common.OrderFee} message OrderFee
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderFee.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.feeList = [];
            if (options.defaults) {
                object.orderIDEx = "";
                object.feeAmount = 0;
            }
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                object.orderIDEx = message.orderIDEx;
            if (message.feeAmount != null && message.hasOwnProperty("feeAmount"))
                object.feeAmount = options.json && !isFinite(message.feeAmount) ? String(message.feeAmount) : message.feeAmount;
            if (message.feeList && message.feeList.length) {
                object.feeList = [];
                for (let j = 0; j < message.feeList.length; ++j)
                    object.feeList[j] = $root.common.OrderFeeItem.toObject(message.feeList[j], options);
            }
            return object;
        };

        /**
         * Converts this OrderFee to JSON.
         * @function toJSON
         * @memberof common.OrderFee
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderFee.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderFee
         * @function getTypeUrl
         * @memberof common.OrderFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.OrderFee";
        };

        return OrderFee;
    })();

    common.OrderFeeItem = (function() {

        /**
         * Properties of an OrderFeeItem.
         * @memberof common
         * @interface IOrderFeeItem
         * @property {string|null} [title] OrderFeeItem title
         * @property {number|null} [value] OrderFeeItem value
         */

        /**
         * Constructs a new OrderFeeItem.
         * @memberof common
         * @classdesc Represents an OrderFeeItem.
         * @implements IOrderFeeItem
         * @constructor
         * @param {common.IOrderFeeItem=} [properties] Properties to set
         */
        function OrderFeeItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderFeeItem title.
         * @member {string} title
         * @memberof common.OrderFeeItem
         * @instance
         */
        OrderFeeItem.prototype.title = "";

        /**
         * OrderFeeItem value.
         * @member {number} value
         * @memberof common.OrderFeeItem
         * @instance
         */
        OrderFeeItem.prototype.value = 0;

        /**
         * Creates a new OrderFeeItem instance using the specified properties.
         * @function create
         * @memberof common.OrderFeeItem
         * @static
         * @param {common.IOrderFeeItem=} [properties] Properties to set
         * @returns {common.OrderFeeItem} OrderFeeItem instance
         */
        OrderFeeItem.create = function create(properties) {
            return new OrderFeeItem(properties);
        };

        /**
         * Encodes the specified OrderFeeItem message. Does not implicitly {@link common.OrderFeeItem.verify|verify} messages.
         * @function encode
         * @memberof common.OrderFeeItem
         * @static
         * @param {common.IOrderFeeItem} message OrderFeeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFeeItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
            return writer;
        };

        /**
         * Encodes the specified OrderFeeItem message, length delimited. Does not implicitly {@link common.OrderFeeItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.OrderFeeItem
         * @static
         * @param {common.IOrderFeeItem} message OrderFeeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFeeItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderFeeItem message from the specified reader or buffer.
         * @function decode
         * @memberof common.OrderFeeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.OrderFeeItem} OrderFeeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFeeItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrderFeeItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.title = reader.string();
                        break;
                    }
                case 2: {
                        message.value = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OrderFeeItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.OrderFeeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.OrderFeeItem} OrderFeeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFeeItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderFeeItem message.
         * @function verify
         * @memberof common.OrderFeeItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderFeeItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            return null;
        };

        /**
         * Creates an OrderFeeItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.OrderFeeItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.OrderFeeItem} OrderFeeItem
         */
        OrderFeeItem.fromObject = function fromObject(object) {
            if (object instanceof $root.common.OrderFeeItem)
                return object;
            let message = new $root.common.OrderFeeItem();
            if (object.title != null)
                message.title = String(object.title);
            if (object.value != null)
                message.value = Number(object.value);
            return message;
        };

        /**
         * Creates a plain object from an OrderFeeItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.OrderFeeItem
         * @static
         * @param {common.OrderFeeItem} message OrderFeeItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderFeeItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.title = "";
                object.value = 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            return object;
        };

        /**
         * Converts this OrderFeeItem to JSON.
         * @function toJSON
         * @memberof common.OrderFeeItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderFeeItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderFeeItem
         * @function getTypeUrl
         * @memberof common.OrderFeeItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderFeeItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.OrderFeeItem";
        };

        return OrderFeeItem;
    })();

    /**
     * Currency enum.
     * @name common.Currency
     * @enum {number}
     * @property {number} Currency_Unknown=0 Currency_Unknown value
     * @property {number} Currency_HKD=1 Currency_HKD value
     * @property {number} Currency_USD=2 Currency_USD value
     * @property {number} Currency_CNH=3 Currency_CNH value
     * @property {number} Currency_JPY=4 Currency_JPY value
     * @property {number} Currency_SGD=5 Currency_SGD value
     * @property {number} Currency_AUD=6 Currency_AUD value
     * @property {number} Currency_CAD=7 Currency_CAD value
     * @property {number} Currency_MYR=8 Currency_MYR value
     */
    common.Currency = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Currency_Unknown"] = 0;
        values[valuesById[1] = "Currency_HKD"] = 1;
        values[valuesById[2] = "Currency_USD"] = 2;
        values[valuesById[3] = "Currency_CNH"] = 3;
        values[valuesById[4] = "Currency_JPY"] = 4;
        values[valuesById[5] = "Currency_SGD"] = 5;
        values[valuesById[6] = "Currency_AUD"] = 6;
        values[valuesById[7] = "Currency_CAD"] = 7;
        values[valuesById[8] = "Currency_MYR"] = 8;
        return values;
    })();

    common.SnapshotBasicData = (function() {

        /**
         * Properties of a SnapshotBasicData.
         * @memberof common
         * @interface ISnapshotBasicData
         * @property {common.ISecurity} security SnapshotBasicData security
         * @property {string|null} [name] SnapshotBasicData name
         * @property {common.SecurityType} type SnapshotBasicData type
         * @property {boolean} isSuspend SnapshotBasicData isSuspend
         * @property {string} listTime SnapshotBasicData listTime
         * @property {number} lotSize SnapshotBasicData lotSize
         * @property {number} priceSpread SnapshotBasicData priceSpread
         * @property {string} updateTime SnapshotBasicData updateTime
         * @property {number} highPrice SnapshotBasicData highPrice
         * @property {number} openPrice SnapshotBasicData openPrice
         * @property {number} lowPrice SnapshotBasicData lowPrice
         * @property {number} lastClosePrice SnapshotBasicData lastClosePrice
         * @property {number} curPrice SnapshotBasicData curPrice
         * @property {number|Long} volume SnapshotBasicData volume
         * @property {number} turnover SnapshotBasicData turnover
         * @property {number} turnoverRate SnapshotBasicData turnoverRate
         * @property {number|null} [listTimestamp] SnapshotBasicData listTimestamp
         * @property {number|null} [updateTimestamp] SnapshotBasicData updateTimestamp
         * @property {number|null} [askPrice] SnapshotBasicData askPrice
         * @property {number|null} [bidPrice] SnapshotBasicData bidPrice
         * @property {number|Long|null} [askVol] SnapshotBasicData askVol
         * @property {number|Long|null} [bidVol] SnapshotBasicData bidVol
         * @property {boolean|null} [enableMargin] SnapshotBasicData enableMargin
         * @property {number|null} [mortgageRatio] SnapshotBasicData mortgageRatio
         * @property {number|null} [longMarginInitialRatio] SnapshotBasicData longMarginInitialRatio
         * @property {boolean|null} [enableShortSell] SnapshotBasicData enableShortSell
         * @property {number|null} [shortSellRate] SnapshotBasicData shortSellRate
         * @property {number|Long|null} [shortAvailableVolume] SnapshotBasicData shortAvailableVolume
         * @property {number|null} [shortMarginInitialRatio] SnapshotBasicData shortMarginInitialRatio
         * @property {number|null} [amplitude] SnapshotBasicData amplitude
         * @property {number|null} [avgPrice] SnapshotBasicData avgPrice
         * @property {number|null} [bidAskRatio] SnapshotBasicData bidAskRatio
         * @property {number|null} [volumeRatio] SnapshotBasicData volumeRatio
         * @property {number|null} [highest52WeeksPrice] SnapshotBasicData highest52WeeksPrice
         * @property {number|null} [lowest52WeeksPrice] SnapshotBasicData lowest52WeeksPrice
         * @property {number|null} [highestHistoryPrice] SnapshotBasicData highestHistoryPrice
         * @property {number|null} [lowestHistoryPrice] SnapshotBasicData lowestHistoryPrice
         * @property {common.IPreAfterMarketData|null} [preMarket] SnapshotBasicData preMarket
         * @property {common.IPreAfterMarketData|null} [afterMarket] SnapshotBasicData afterMarket
         * @property {number|null} [secStatus] SnapshotBasicData secStatus
         * @property {number|null} [closePrice5Minute] SnapshotBasicData closePrice5Minute
         */

        /**
         * Constructs a new SnapshotBasicData.
         * @memberof common
         * @classdesc 快照基本数据
         * @implements ISnapshotBasicData
         * @constructor
         * @param {common.ISnapshotBasicData=} [properties] Properties to set
         */
        function SnapshotBasicData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnapshotBasicData security.
         * @member {common.ISecurity} security
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.security = null;

        /**
         * SnapshotBasicData name.
         * @member {string} name
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.name = "";

        /**
         * SnapshotBasicData type.
         * @member {common.SecurityType} type
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.type = 0;

        /**
         * SnapshotBasicData isSuspend.
         * @member {boolean} isSuspend
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.isSuspend = false;

        /**
         * SnapshotBasicData listTime.
         * @member {string} listTime
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.listTime = "";

        /**
         * SnapshotBasicData lotSize.
         * @member {number} lotSize
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lotSize = 0;

        /**
         * SnapshotBasicData priceSpread.
         * @member {number} priceSpread
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.priceSpread = 0;

        /**
         * SnapshotBasicData updateTime.
         * @member {string} updateTime
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.updateTime = "";

        /**
         * SnapshotBasicData highPrice.
         * @member {number} highPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.highPrice = 0;

        /**
         * SnapshotBasicData openPrice.
         * @member {number} openPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.openPrice = 0;

        /**
         * SnapshotBasicData lowPrice.
         * @member {number} lowPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lowPrice = 0;

        /**
         * SnapshotBasicData lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lastClosePrice = 0;

        /**
         * SnapshotBasicData curPrice.
         * @member {number} curPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.curPrice = 0;

        /**
         * SnapshotBasicData volume.
         * @member {number|Long} volume
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData turnover.
         * @member {number} turnover
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.turnover = 0;

        /**
         * SnapshotBasicData turnoverRate.
         * @member {number} turnoverRate
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.turnoverRate = 0;

        /**
         * SnapshotBasicData listTimestamp.
         * @member {number} listTimestamp
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.listTimestamp = 0;

        /**
         * SnapshotBasicData updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.updateTimestamp = 0;

        /**
         * SnapshotBasicData askPrice.
         * @member {number} askPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.askPrice = 0;

        /**
         * SnapshotBasicData bidPrice.
         * @member {number} bidPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidPrice = 0;

        /**
         * SnapshotBasicData askVol.
         * @member {number|Long} askVol
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.askVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData bidVol.
         * @member {number|Long} bidVol
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData enableMargin.
         * @member {boolean} enableMargin
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.enableMargin = false;

        /**
         * SnapshotBasicData mortgageRatio.
         * @member {number} mortgageRatio
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.mortgageRatio = 0;

        /**
         * SnapshotBasicData longMarginInitialRatio.
         * @member {number} longMarginInitialRatio
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.longMarginInitialRatio = 0;

        /**
         * SnapshotBasicData enableShortSell.
         * @member {boolean} enableShortSell
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.enableShortSell = false;

        /**
         * SnapshotBasicData shortSellRate.
         * @member {number} shortSellRate
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortSellRate = 0;

        /**
         * SnapshotBasicData shortAvailableVolume.
         * @member {number|Long} shortAvailableVolume
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortAvailableVolume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData shortMarginInitialRatio.
         * @member {number} shortMarginInitialRatio
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortMarginInitialRatio = 0;

        /**
         * SnapshotBasicData amplitude.
         * @member {number} amplitude
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.amplitude = 0;

        /**
         * SnapshotBasicData avgPrice.
         * @member {number} avgPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.avgPrice = 0;

        /**
         * SnapshotBasicData bidAskRatio.
         * @member {number} bidAskRatio
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidAskRatio = 0;

        /**
         * SnapshotBasicData volumeRatio.
         * @member {number} volumeRatio
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.volumeRatio = 0;

        /**
         * SnapshotBasicData highest52WeeksPrice.
         * @member {number} highest52WeeksPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.highest52WeeksPrice = 0;

        /**
         * SnapshotBasicData lowest52WeeksPrice.
         * @member {number} lowest52WeeksPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lowest52WeeksPrice = 0;

        /**
         * SnapshotBasicData highestHistoryPrice.
         * @member {number} highestHistoryPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.highestHistoryPrice = 0;

        /**
         * SnapshotBasicData lowestHistoryPrice.
         * @member {number} lowestHistoryPrice
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lowestHistoryPrice = 0;

        /**
         * SnapshotBasicData preMarket.
         * @member {common.IPreAfterMarketData|null|undefined} preMarket
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.preMarket = null;

        /**
         * SnapshotBasicData afterMarket.
         * @member {common.IPreAfterMarketData|null|undefined} afterMarket
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.afterMarket = null;

        /**
         * SnapshotBasicData secStatus.
         * @member {number} secStatus
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.secStatus = 0;

        /**
         * SnapshotBasicData closePrice5Minute.
         * @member {number} closePrice5Minute
         * @memberof common.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.closePrice5Minute = 0;

        /**
         * Creates a new SnapshotBasicData instance using the specified properties.
         * @function create
         * @memberof common.SnapshotBasicData
         * @static
         * @param {common.ISnapshotBasicData=} [properties] Properties to set
         * @returns {common.SnapshotBasicData} SnapshotBasicData instance
         */
        SnapshotBasicData.create = function create(properties) {
            return new SnapshotBasicData(properties);
        };

        /**
         * Encodes the specified SnapshotBasicData message. Does not implicitly {@link common.SnapshotBasicData.verify|verify} messages.
         * @function encode
         * @memberof common.SnapshotBasicData
         * @static
         * @param {common.ISnapshotBasicData} message SnapshotBasicData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotBasicData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSuspend);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.listTime);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lotSize);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.priceSpread);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.updateTime);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.highPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.openPrice);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.lowPrice);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.lastClosePrice);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.curPrice);
            writer.uint32(/* id 13, wireType 0 =*/104).int64(message.volume);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.turnover);
            writer.uint32(/* id 15, wireType 1 =*/121).double(message.turnoverRate);
            if (message.listTimestamp != null && Object.hasOwnProperty.call(message, "listTimestamp"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.listTimestamp);
            if (message.updateTimestamp != null && Object.hasOwnProperty.call(message, "updateTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.updateTimestamp);
            if (message.askPrice != null && Object.hasOwnProperty.call(message, "askPrice"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.askPrice);
            if (message.bidPrice != null && Object.hasOwnProperty.call(message, "bidPrice"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.bidPrice);
            if (message.askVol != null && Object.hasOwnProperty.call(message, "askVol"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.askVol);
            if (message.bidVol != null && Object.hasOwnProperty.call(message, "bidVol"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.bidVol);
            if (message.enableMargin != null && Object.hasOwnProperty.call(message, "enableMargin"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.enableMargin);
            if (message.mortgageRatio != null && Object.hasOwnProperty.call(message, "mortgageRatio"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.mortgageRatio);
            if (message.longMarginInitialRatio != null && Object.hasOwnProperty.call(message, "longMarginInitialRatio"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.longMarginInitialRatio);
            if (message.enableShortSell != null && Object.hasOwnProperty.call(message, "enableShortSell"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.enableShortSell);
            if (message.shortSellRate != null && Object.hasOwnProperty.call(message, "shortSellRate"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.shortSellRate);
            if (message.shortAvailableVolume != null && Object.hasOwnProperty.call(message, "shortAvailableVolume"))
                writer.uint32(/* id 27, wireType 0 =*/216).int64(message.shortAvailableVolume);
            if (message.shortMarginInitialRatio != null && Object.hasOwnProperty.call(message, "shortMarginInitialRatio"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.shortMarginInitialRatio);
            if (message.amplitude != null && Object.hasOwnProperty.call(message, "amplitude"))
                writer.uint32(/* id 29, wireType 1 =*/233).double(message.amplitude);
            if (message.avgPrice != null && Object.hasOwnProperty.call(message, "avgPrice"))
                writer.uint32(/* id 30, wireType 1 =*/241).double(message.avgPrice);
            if (message.bidAskRatio != null && Object.hasOwnProperty.call(message, "bidAskRatio"))
                writer.uint32(/* id 31, wireType 1 =*/249).double(message.bidAskRatio);
            if (message.volumeRatio != null && Object.hasOwnProperty.call(message, "volumeRatio"))
                writer.uint32(/* id 32, wireType 1 =*/257).double(message.volumeRatio);
            if (message.highest52WeeksPrice != null && Object.hasOwnProperty.call(message, "highest52WeeksPrice"))
                writer.uint32(/* id 33, wireType 1 =*/265).double(message.highest52WeeksPrice);
            if (message.lowest52WeeksPrice != null && Object.hasOwnProperty.call(message, "lowest52WeeksPrice"))
                writer.uint32(/* id 34, wireType 1 =*/273).double(message.lowest52WeeksPrice);
            if (message.highestHistoryPrice != null && Object.hasOwnProperty.call(message, "highestHistoryPrice"))
                writer.uint32(/* id 35, wireType 1 =*/281).double(message.highestHistoryPrice);
            if (message.lowestHistoryPrice != null && Object.hasOwnProperty.call(message, "lowestHistoryPrice"))
                writer.uint32(/* id 36, wireType 1 =*/289).double(message.lowestHistoryPrice);
            if (message.preMarket != null && Object.hasOwnProperty.call(message, "preMarket"))
                $root.common.PreAfterMarketData.encode(message.preMarket, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.afterMarket != null && Object.hasOwnProperty.call(message, "afterMarket"))
                $root.common.PreAfterMarketData.encode(message.afterMarket, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.secStatus != null && Object.hasOwnProperty.call(message, "secStatus"))
                writer.uint32(/* id 39, wireType 0 =*/312).int32(message.secStatus);
            if (message.closePrice5Minute != null && Object.hasOwnProperty.call(message, "closePrice5Minute"))
                writer.uint32(/* id 40, wireType 1 =*/321).double(message.closePrice5Minute);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 41, wireType 2 =*/330).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified SnapshotBasicData message, length delimited. Does not implicitly {@link common.SnapshotBasicData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.SnapshotBasicData
         * @static
         * @param {common.ISnapshotBasicData} message SnapshotBasicData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotBasicData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnapshotBasicData message from the specified reader or buffer.
         * @function decode
         * @memberof common.SnapshotBasicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.SnapshotBasicData} SnapshotBasicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotBasicData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SnapshotBasicData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.security = $root.common.Security.decode(reader, reader.uint32());
                        break;
                    }
                case 41: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        message.isSuspend = reader.bool();
                        break;
                    }
                case 4: {
                        message.listTime = reader.string();
                        break;
                    }
                case 5: {
                        message.lotSize = reader.int32();
                        break;
                    }
                case 6: {
                        message.priceSpread = reader.double();
                        break;
                    }
                case 7: {
                        message.updateTime = reader.string();
                        break;
                    }
                case 8: {
                        message.highPrice = reader.double();
                        break;
                    }
                case 9: {
                        message.openPrice = reader.double();
                        break;
                    }
                case 10: {
                        message.lowPrice = reader.double();
                        break;
                    }
                case 11: {
                        message.lastClosePrice = reader.double();
                        break;
                    }
                case 12: {
                        message.curPrice = reader.double();
                        break;
                    }
                case 13: {
                        message.volume = reader.int64();
                        break;
                    }
                case 14: {
                        message.turnover = reader.double();
                        break;
                    }
                case 15: {
                        message.turnoverRate = reader.double();
                        break;
                    }
                case 16: {
                        message.listTimestamp = reader.double();
                        break;
                    }
                case 17: {
                        message.updateTimestamp = reader.double();
                        break;
                    }
                case 18: {
                        message.askPrice = reader.double();
                        break;
                    }
                case 19: {
                        message.bidPrice = reader.double();
                        break;
                    }
                case 20: {
                        message.askVol = reader.int64();
                        break;
                    }
                case 21: {
                        message.bidVol = reader.int64();
                        break;
                    }
                case 22: {
                        message.enableMargin = reader.bool();
                        break;
                    }
                case 23: {
                        message.mortgageRatio = reader.double();
                        break;
                    }
                case 24: {
                        message.longMarginInitialRatio = reader.double();
                        break;
                    }
                case 25: {
                        message.enableShortSell = reader.bool();
                        break;
                    }
                case 26: {
                        message.shortSellRate = reader.double();
                        break;
                    }
                case 27: {
                        message.shortAvailableVolume = reader.int64();
                        break;
                    }
                case 28: {
                        message.shortMarginInitialRatio = reader.double();
                        break;
                    }
                case 29: {
                        message.amplitude = reader.double();
                        break;
                    }
                case 30: {
                        message.avgPrice = reader.double();
                        break;
                    }
                case 31: {
                        message.bidAskRatio = reader.double();
                        break;
                    }
                case 32: {
                        message.volumeRatio = reader.double();
                        break;
                    }
                case 33: {
                        message.highest52WeeksPrice = reader.double();
                        break;
                    }
                case 34: {
                        message.lowest52WeeksPrice = reader.double();
                        break;
                    }
                case 35: {
                        message.highestHistoryPrice = reader.double();
                        break;
                    }
                case 36: {
                        message.lowestHistoryPrice = reader.double();
                        break;
                    }
                case 37: {
                        message.preMarket = $root.common.PreAfterMarketData.decode(reader, reader.uint32());
                        break;
                    }
                case 38: {
                        message.afterMarket = $root.common.PreAfterMarketData.decode(reader, reader.uint32());
                        break;
                    }
                case 39: {
                        message.secStatus = reader.int32();
                        break;
                    }
                case 40: {
                        message.closePrice5Minute = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("isSuspend"))
                throw $util.ProtocolError("missing required 'isSuspend'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("priceSpread"))
                throw $util.ProtocolError("missing required 'priceSpread'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("openPrice"))
                throw $util.ProtocolError("missing required 'openPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("turnoverRate"))
                throw $util.ProtocolError("missing required 'turnoverRate'", { instance: message });
            return message;
        };

        /**
         * Decodes a SnapshotBasicData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.SnapshotBasicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.SnapshotBasicData} SnapshotBasicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotBasicData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnapshotBasicData message.
         * @function verify
         * @memberof common.SnapshotBasicData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SnapshotBasicData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
                break;
            }
            if (typeof message.isSuspend !== "boolean")
                return "isSuspend: boolean expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (typeof message.priceSpread !== "number")
                return "priceSpread: number expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.openPrice !== "number")
                return "openPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.turnoverRate !== "number")
                return "turnoverRate: number expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                if (typeof message.askPrice !== "number")
                    return "askPrice: number expected";
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                if (typeof message.bidPrice !== "number")
                    return "bidPrice: number expected";
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (!$util.isInteger(message.askVol) && !(message.askVol && $util.isInteger(message.askVol.low) && $util.isInteger(message.askVol.high)))
                    return "askVol: integer|Long expected";
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (!$util.isInteger(message.bidVol) && !(message.bidVol && $util.isInteger(message.bidVol.low) && $util.isInteger(message.bidVol.high)))
                    return "bidVol: integer|Long expected";
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                if (typeof message.enableMargin !== "boolean")
                    return "enableMargin: boolean expected";
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                if (typeof message.mortgageRatio !== "number")
                    return "mortgageRatio: number expected";
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                if (typeof message.longMarginInitialRatio !== "number")
                    return "longMarginInitialRatio: number expected";
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                if (typeof message.enableShortSell !== "boolean")
                    return "enableShortSell: boolean expected";
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                if (typeof message.shortSellRate !== "number")
                    return "shortSellRate: number expected";
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                if (!$util.isInteger(message.shortAvailableVolume) && !(message.shortAvailableVolume && $util.isInteger(message.shortAvailableVolume.low) && $util.isInteger(message.shortAvailableVolume.high)))
                    return "shortAvailableVolume: integer|Long expected";
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                if (typeof message.shortMarginInitialRatio !== "number")
                    return "shortMarginInitialRatio: number expected";
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                if (typeof message.amplitude !== "number")
                    return "amplitude: number expected";
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                if (typeof message.avgPrice !== "number")
                    return "avgPrice: number expected";
            if (message.bidAskRatio != null && message.hasOwnProperty("bidAskRatio"))
                if (typeof message.bidAskRatio !== "number")
                    return "bidAskRatio: number expected";
            if (message.volumeRatio != null && message.hasOwnProperty("volumeRatio"))
                if (typeof message.volumeRatio !== "number")
                    return "volumeRatio: number expected";
            if (message.highest52WeeksPrice != null && message.hasOwnProperty("highest52WeeksPrice"))
                if (typeof message.highest52WeeksPrice !== "number")
                    return "highest52WeeksPrice: number expected";
            if (message.lowest52WeeksPrice != null && message.hasOwnProperty("lowest52WeeksPrice"))
                if (typeof message.lowest52WeeksPrice !== "number")
                    return "lowest52WeeksPrice: number expected";
            if (message.highestHistoryPrice != null && message.hasOwnProperty("highestHistoryPrice"))
                if (typeof message.highestHistoryPrice !== "number")
                    return "highestHistoryPrice: number expected";
            if (message.lowestHistoryPrice != null && message.hasOwnProperty("lowestHistoryPrice"))
                if (typeof message.lowestHistoryPrice !== "number")
                    return "lowestHistoryPrice: number expected";
            if (message.preMarket != null && message.hasOwnProperty("preMarket")) {
                let error = $root.common.PreAfterMarketData.verify(message.preMarket);
                if (error)
                    return "preMarket." + error;
            }
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket")) {
                let error = $root.common.PreAfterMarketData.verify(message.afterMarket);
                if (error)
                    return "afterMarket." + error;
            }
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                if (!$util.isInteger(message.secStatus))
                    return "secStatus: integer expected";
            if (message.closePrice5Minute != null && message.hasOwnProperty("closePrice5Minute"))
                if (typeof message.closePrice5Minute !== "number")
                    return "closePrice5Minute: number expected";
            return null;
        };

        /**
         * Creates a SnapshotBasicData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.SnapshotBasicData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.SnapshotBasicData} SnapshotBasicData
         */
        SnapshotBasicData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.SnapshotBasicData)
                return object;
            let message = new $root.common.SnapshotBasicData();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".common.SnapshotBasicData.security: object expected");
                message.security = $root.common.Security.fromObject(object.security);
            }
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "SecurityType_Unknown":
            case 0:
                message.type = 0;
                break;
            case "SecurityType_Bond":
            case 1:
                message.type = 1;
                break;
            case "SecurityType_Bwrt":
            case 2:
                message.type = 2;
                break;
            case "SecurityType_Eqty":
            case 3:
                message.type = 3;
                break;
            case "SecurityType_Trust":
            case 4:
                message.type = 4;
                break;
            case "SecurityType_Warrant":
            case 5:
                message.type = 5;
                break;
            case "SecurityType_Index":
            case 6:
                message.type = 6;
                break;
            case "SecurityType_Plate":
            case 7:
                message.type = 7;
                break;
            case "SecurityType_Drvt":
            case 8:
                message.type = 8;
                break;
            case "SecurityType_PlateSet":
            case 9:
                message.type = 9;
                break;
            case "SecurityType_Future":
            case 10:
                message.type = 10;
                break;
            }
            if (object.isSuspend != null)
                message.isSuspend = Boolean(object.isSuspend);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.priceSpread != null)
                message.priceSpread = Number(object.priceSpread);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.askPrice != null)
                message.askPrice = Number(object.askPrice);
            if (object.bidPrice != null)
                message.bidPrice = Number(object.bidPrice);
            if (object.askVol != null)
                if ($util.Long)
                    (message.askVol = $util.Long.fromValue(object.askVol)).unsigned = false;
                else if (typeof object.askVol === "string")
                    message.askVol = parseInt(object.askVol, 10);
                else if (typeof object.askVol === "number")
                    message.askVol = object.askVol;
                else if (typeof object.askVol === "object")
                    message.askVol = new $util.LongBits(object.askVol.low >>> 0, object.askVol.high >>> 0).toNumber();
            if (object.bidVol != null)
                if ($util.Long)
                    (message.bidVol = $util.Long.fromValue(object.bidVol)).unsigned = false;
                else if (typeof object.bidVol === "string")
                    message.bidVol = parseInt(object.bidVol, 10);
                else if (typeof object.bidVol === "number")
                    message.bidVol = object.bidVol;
                else if (typeof object.bidVol === "object")
                    message.bidVol = new $util.LongBits(object.bidVol.low >>> 0, object.bidVol.high >>> 0).toNumber();
            if (object.enableMargin != null)
                message.enableMargin = Boolean(object.enableMargin);
            if (object.mortgageRatio != null)
                message.mortgageRatio = Number(object.mortgageRatio);
            if (object.longMarginInitialRatio != null)
                message.longMarginInitialRatio = Number(object.longMarginInitialRatio);
            if (object.enableShortSell != null)
                message.enableShortSell = Boolean(object.enableShortSell);
            if (object.shortSellRate != null)
                message.shortSellRate = Number(object.shortSellRate);
            if (object.shortAvailableVolume != null)
                if ($util.Long)
                    (message.shortAvailableVolume = $util.Long.fromValue(object.shortAvailableVolume)).unsigned = false;
                else if (typeof object.shortAvailableVolume === "string")
                    message.shortAvailableVolume = parseInt(object.shortAvailableVolume, 10);
                else if (typeof object.shortAvailableVolume === "number")
                    message.shortAvailableVolume = object.shortAvailableVolume;
                else if (typeof object.shortAvailableVolume === "object")
                    message.shortAvailableVolume = new $util.LongBits(object.shortAvailableVolume.low >>> 0, object.shortAvailableVolume.high >>> 0).toNumber();
            if (object.shortMarginInitialRatio != null)
                message.shortMarginInitialRatio = Number(object.shortMarginInitialRatio);
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.avgPrice != null)
                message.avgPrice = Number(object.avgPrice);
            if (object.bidAskRatio != null)
                message.bidAskRatio = Number(object.bidAskRatio);
            if (object.volumeRatio != null)
                message.volumeRatio = Number(object.volumeRatio);
            if (object.highest52WeeksPrice != null)
                message.highest52WeeksPrice = Number(object.highest52WeeksPrice);
            if (object.lowest52WeeksPrice != null)
                message.lowest52WeeksPrice = Number(object.lowest52WeeksPrice);
            if (object.highestHistoryPrice != null)
                message.highestHistoryPrice = Number(object.highestHistoryPrice);
            if (object.lowestHistoryPrice != null)
                message.lowestHistoryPrice = Number(object.lowestHistoryPrice);
            if (object.preMarket != null) {
                if (typeof object.preMarket !== "object")
                    throw TypeError(".common.SnapshotBasicData.preMarket: object expected");
                message.preMarket = $root.common.PreAfterMarketData.fromObject(object.preMarket);
            }
            if (object.afterMarket != null) {
                if (typeof object.afterMarket !== "object")
                    throw TypeError(".common.SnapshotBasicData.afterMarket: object expected");
                message.afterMarket = $root.common.PreAfterMarketData.fromObject(object.afterMarket);
            }
            if (object.secStatus != null)
                message.secStatus = object.secStatus | 0;
            if (object.closePrice5Minute != null)
                message.closePrice5Minute = Number(object.closePrice5Minute);
            return message;
        };

        /**
         * Creates a plain object from a SnapshotBasicData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.SnapshotBasicData
         * @static
         * @param {common.SnapshotBasicData} message SnapshotBasicData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnapshotBasicData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.security = null;
                object.type = options.enums === String ? "SecurityType_Unknown" : 0;
                object.isSuspend = false;
                object.listTime = "";
                object.lotSize = 0;
                object.priceSpread = 0;
                object.updateTime = "";
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.lastClosePrice = 0;
                object.curPrice = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.listTimestamp = 0;
                object.updateTimestamp = 0;
                object.askPrice = 0;
                object.bidPrice = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.askVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.askVol = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.bidVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bidVol = options.longs === String ? "0" : 0;
                object.enableMargin = false;
                object.mortgageRatio = 0;
                object.longMarginInitialRatio = 0;
                object.enableShortSell = false;
                object.shortSellRate = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.shortAvailableVolume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shortAvailableVolume = options.longs === String ? "0" : 0;
                object.shortMarginInitialRatio = 0;
                object.amplitude = 0;
                object.avgPrice = 0;
                object.bidAskRatio = 0;
                object.volumeRatio = 0;
                object.highest52WeeksPrice = 0;
                object.lowest52WeeksPrice = 0;
                object.highestHistoryPrice = 0;
                object.lowestHistoryPrice = 0;
                object.preMarket = null;
                object.afterMarket = null;
                object.secStatus = 0;
                object.closePrice5Minute = 0;
                object.name = "";
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.common.Security.toObject(message.security, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.common.SecurityType[message.type] === undefined ? message.type : $root.common.SecurityType[message.type] : message.type;
            if (message.isSuspend != null && message.hasOwnProperty("isSuspend"))
                object.isSuspend = message.isSuspend;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.priceSpread != null && message.hasOwnProperty("priceSpread"))
                object.priceSpread = options.json && !isFinite(message.priceSpread) ? String(message.priceSpread) : message.priceSpread;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                object.askPrice = options.json && !isFinite(message.askPrice) ? String(message.askPrice) : message.askPrice;
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                object.bidPrice = options.json && !isFinite(message.bidPrice) ? String(message.bidPrice) : message.bidPrice;
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (typeof message.askVol === "number")
                    object.askVol = options.longs === String ? String(message.askVol) : message.askVol;
                else
                    object.askVol = options.longs === String ? $util.Long.prototype.toString.call(message.askVol) : options.longs === Number ? new $util.LongBits(message.askVol.low >>> 0, message.askVol.high >>> 0).toNumber() : message.askVol;
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (typeof message.bidVol === "number")
                    object.bidVol = options.longs === String ? String(message.bidVol) : message.bidVol;
                else
                    object.bidVol = options.longs === String ? $util.Long.prototype.toString.call(message.bidVol) : options.longs === Number ? new $util.LongBits(message.bidVol.low >>> 0, message.bidVol.high >>> 0).toNumber() : message.bidVol;
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                object.enableMargin = message.enableMargin;
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                object.mortgageRatio = options.json && !isFinite(message.mortgageRatio) ? String(message.mortgageRatio) : message.mortgageRatio;
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                object.longMarginInitialRatio = options.json && !isFinite(message.longMarginInitialRatio) ? String(message.longMarginInitialRatio) : message.longMarginInitialRatio;
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                object.enableShortSell = message.enableShortSell;
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                object.shortSellRate = options.json && !isFinite(message.shortSellRate) ? String(message.shortSellRate) : message.shortSellRate;
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                if (typeof message.shortAvailableVolume === "number")
                    object.shortAvailableVolume = options.longs === String ? String(message.shortAvailableVolume) : message.shortAvailableVolume;
                else
                    object.shortAvailableVolume = options.longs === String ? $util.Long.prototype.toString.call(message.shortAvailableVolume) : options.longs === Number ? new $util.LongBits(message.shortAvailableVolume.low >>> 0, message.shortAvailableVolume.high >>> 0).toNumber() : message.shortAvailableVolume;
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                object.shortMarginInitialRatio = options.json && !isFinite(message.shortMarginInitialRatio) ? String(message.shortMarginInitialRatio) : message.shortMarginInitialRatio;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                object.avgPrice = options.json && !isFinite(message.avgPrice) ? String(message.avgPrice) : message.avgPrice;
            if (message.bidAskRatio != null && message.hasOwnProperty("bidAskRatio"))
                object.bidAskRatio = options.json && !isFinite(message.bidAskRatio) ? String(message.bidAskRatio) : message.bidAskRatio;
            if (message.volumeRatio != null && message.hasOwnProperty("volumeRatio"))
                object.volumeRatio = options.json && !isFinite(message.volumeRatio) ? String(message.volumeRatio) : message.volumeRatio;
            if (message.highest52WeeksPrice != null && message.hasOwnProperty("highest52WeeksPrice"))
                object.highest52WeeksPrice = options.json && !isFinite(message.highest52WeeksPrice) ? String(message.highest52WeeksPrice) : message.highest52WeeksPrice;
            if (message.lowest52WeeksPrice != null && message.hasOwnProperty("lowest52WeeksPrice"))
                object.lowest52WeeksPrice = options.json && !isFinite(message.lowest52WeeksPrice) ? String(message.lowest52WeeksPrice) : message.lowest52WeeksPrice;
            if (message.highestHistoryPrice != null && message.hasOwnProperty("highestHistoryPrice"))
                object.highestHistoryPrice = options.json && !isFinite(message.highestHistoryPrice) ? String(message.highestHistoryPrice) : message.highestHistoryPrice;
            if (message.lowestHistoryPrice != null && message.hasOwnProperty("lowestHistoryPrice"))
                object.lowestHistoryPrice = options.json && !isFinite(message.lowestHistoryPrice) ? String(message.lowestHistoryPrice) : message.lowestHistoryPrice;
            if (message.preMarket != null && message.hasOwnProperty("preMarket"))
                object.preMarket = $root.common.PreAfterMarketData.toObject(message.preMarket, options);
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket"))
                object.afterMarket = $root.common.PreAfterMarketData.toObject(message.afterMarket, options);
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                object.secStatus = message.secStatus;
            if (message.closePrice5Minute != null && message.hasOwnProperty("closePrice5Minute"))
                object.closePrice5Minute = options.json && !isFinite(message.closePrice5Minute) ? String(message.closePrice5Minute) : message.closePrice5Minute;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this SnapshotBasicData to JSON.
         * @function toJSON
         * @memberof common.SnapshotBasicData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SnapshotBasicData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SnapshotBasicData
         * @function getTypeUrl
         * @memberof common.SnapshotBasicData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SnapshotBasicData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.SnapshotBasicData";
        };

        return SnapshotBasicData;
    })();

    common.EquitySnapshotExData = (function() {

        /**
         * Properties of an EquitySnapshotExData.
         * @memberof common
         * @interface IEquitySnapshotExData
         * @property {number|Long} issuedShares EquitySnapshotExData issuedShares
         * @property {number} issuedMarketVal EquitySnapshotExData issuedMarketVal
         * @property {number} netAsset EquitySnapshotExData netAsset
         * @property {number} netProfit EquitySnapshotExData netProfit
         * @property {number} earningsPershare EquitySnapshotExData earningsPershare
         * @property {number|Long} outstandingShares EquitySnapshotExData outstandingShares
         * @property {number} outstandingMarketVal EquitySnapshotExData outstandingMarketVal
         * @property {number} netAssetPershare EquitySnapshotExData netAssetPershare
         * @property {number} eyRate EquitySnapshotExData eyRate
         * @property {number} peRate EquitySnapshotExData peRate
         * @property {number} pbRate EquitySnapshotExData pbRate
         * @property {number} peTTMRate EquitySnapshotExData peTTMRate
         * @property {number|null} [dividendTTM] EquitySnapshotExData dividendTTM
         * @property {number|null} [dividendRatioTTM] EquitySnapshotExData dividendRatioTTM
         * @property {number|null} [dividendLFY] EquitySnapshotExData dividendLFY
         * @property {number|null} [dividendLFYRatio] EquitySnapshotExData dividendLFYRatio
         */

        /**
         * Constructs a new EquitySnapshotExData.
         * @memberof common
         * @classdesc 正股快照额外数据
         * @implements IEquitySnapshotExData
         * @constructor
         * @param {common.IEquitySnapshotExData=} [properties] Properties to set
         */
        function EquitySnapshotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquitySnapshotExData issuedShares.
         * @member {number|Long} issuedShares
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.issuedShares = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EquitySnapshotExData issuedMarketVal.
         * @member {number} issuedMarketVal
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.issuedMarketVal = 0;

        /**
         * EquitySnapshotExData netAsset.
         * @member {number} netAsset
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netAsset = 0;

        /**
         * EquitySnapshotExData netProfit.
         * @member {number} netProfit
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netProfit = 0;

        /**
         * EquitySnapshotExData earningsPershare.
         * @member {number} earningsPershare
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.earningsPershare = 0;

        /**
         * EquitySnapshotExData outstandingShares.
         * @member {number|Long} outstandingShares
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.outstandingShares = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EquitySnapshotExData outstandingMarketVal.
         * @member {number} outstandingMarketVal
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.outstandingMarketVal = 0;

        /**
         * EquitySnapshotExData netAssetPershare.
         * @member {number} netAssetPershare
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netAssetPershare = 0;

        /**
         * EquitySnapshotExData eyRate.
         * @member {number} eyRate
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.eyRate = 0;

        /**
         * EquitySnapshotExData peRate.
         * @member {number} peRate
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.peRate = 0;

        /**
         * EquitySnapshotExData pbRate.
         * @member {number} pbRate
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.pbRate = 0;

        /**
         * EquitySnapshotExData peTTMRate.
         * @member {number} peTTMRate
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.peTTMRate = 0;

        /**
         * EquitySnapshotExData dividendTTM.
         * @member {number} dividendTTM
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendTTM = 0;

        /**
         * EquitySnapshotExData dividendRatioTTM.
         * @member {number} dividendRatioTTM
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendRatioTTM = 0;

        /**
         * EquitySnapshotExData dividendLFY.
         * @member {number} dividendLFY
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendLFY = 0;

        /**
         * EquitySnapshotExData dividendLFYRatio.
         * @member {number} dividendLFYRatio
         * @memberof common.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendLFYRatio = 0;

        /**
         * Creates a new EquitySnapshotExData instance using the specified properties.
         * @function create
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {common.IEquitySnapshotExData=} [properties] Properties to set
         * @returns {common.EquitySnapshotExData} EquitySnapshotExData instance
         */
        EquitySnapshotExData.create = function create(properties) {
            return new EquitySnapshotExData(properties);
        };

        /**
         * Encodes the specified EquitySnapshotExData message. Does not implicitly {@link common.EquitySnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {common.IEquitySnapshotExData} message EquitySnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquitySnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.issuedShares);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.issuedMarketVal);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.netAsset);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.netProfit);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.earningsPershare);
            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.outstandingShares);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.outstandingMarketVal);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.netAssetPershare);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.eyRate);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.peRate);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.pbRate);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.peTTMRate);
            if (message.dividendTTM != null && Object.hasOwnProperty.call(message, "dividendTTM"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.dividendTTM);
            if (message.dividendRatioTTM != null && Object.hasOwnProperty.call(message, "dividendRatioTTM"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.dividendRatioTTM);
            if (message.dividendLFY != null && Object.hasOwnProperty.call(message, "dividendLFY"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.dividendLFY);
            if (message.dividendLFYRatio != null && Object.hasOwnProperty.call(message, "dividendLFYRatio"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.dividendLFYRatio);
            return writer;
        };

        /**
         * Encodes the specified EquitySnapshotExData message, length delimited. Does not implicitly {@link common.EquitySnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {common.IEquitySnapshotExData} message EquitySnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquitySnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquitySnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.EquitySnapshotExData} EquitySnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquitySnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.EquitySnapshotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.issuedShares = reader.int64();
                        break;
                    }
                case 2: {
                        message.issuedMarketVal = reader.double();
                        break;
                    }
                case 3: {
                        message.netAsset = reader.double();
                        break;
                    }
                case 4: {
                        message.netProfit = reader.double();
                        break;
                    }
                case 5: {
                        message.earningsPershare = reader.double();
                        break;
                    }
                case 6: {
                        message.outstandingShares = reader.int64();
                        break;
                    }
                case 7: {
                        message.outstandingMarketVal = reader.double();
                        break;
                    }
                case 8: {
                        message.netAssetPershare = reader.double();
                        break;
                    }
                case 9: {
                        message.eyRate = reader.double();
                        break;
                    }
                case 10: {
                        message.peRate = reader.double();
                        break;
                    }
                case 11: {
                        message.pbRate = reader.double();
                        break;
                    }
                case 12: {
                        message.peTTMRate = reader.double();
                        break;
                    }
                case 13: {
                        message.dividendTTM = reader.double();
                        break;
                    }
                case 14: {
                        message.dividendRatioTTM = reader.double();
                        break;
                    }
                case 15: {
                        message.dividendLFY = reader.double();
                        break;
                    }
                case 16: {
                        message.dividendLFYRatio = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("issuedShares"))
                throw $util.ProtocolError("missing required 'issuedShares'", { instance: message });
            if (!message.hasOwnProperty("issuedMarketVal"))
                throw $util.ProtocolError("missing required 'issuedMarketVal'", { instance: message });
            if (!message.hasOwnProperty("netAsset"))
                throw $util.ProtocolError("missing required 'netAsset'", { instance: message });
            if (!message.hasOwnProperty("netProfit"))
                throw $util.ProtocolError("missing required 'netProfit'", { instance: message });
            if (!message.hasOwnProperty("earningsPershare"))
                throw $util.ProtocolError("missing required 'earningsPershare'", { instance: message });
            if (!message.hasOwnProperty("outstandingShares"))
                throw $util.ProtocolError("missing required 'outstandingShares'", { instance: message });
            if (!message.hasOwnProperty("outstandingMarketVal"))
                throw $util.ProtocolError("missing required 'outstandingMarketVal'", { instance: message });
            if (!message.hasOwnProperty("netAssetPershare"))
                throw $util.ProtocolError("missing required 'netAssetPershare'", { instance: message });
            if (!message.hasOwnProperty("eyRate"))
                throw $util.ProtocolError("missing required 'eyRate'", { instance: message });
            if (!message.hasOwnProperty("peRate"))
                throw $util.ProtocolError("missing required 'peRate'", { instance: message });
            if (!message.hasOwnProperty("pbRate"))
                throw $util.ProtocolError("missing required 'pbRate'", { instance: message });
            if (!message.hasOwnProperty("peTTMRate"))
                throw $util.ProtocolError("missing required 'peTTMRate'", { instance: message });
            return message;
        };

        /**
         * Decodes an EquitySnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.EquitySnapshotExData} EquitySnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquitySnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquitySnapshotExData message.
         * @function verify
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquitySnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.issuedShares) && !(message.issuedShares && $util.isInteger(message.issuedShares.low) && $util.isInteger(message.issuedShares.high)))
                return "issuedShares: integer|Long expected";
            if (typeof message.issuedMarketVal !== "number")
                return "issuedMarketVal: number expected";
            if (typeof message.netAsset !== "number")
                return "netAsset: number expected";
            if (typeof message.netProfit !== "number")
                return "netProfit: number expected";
            if (typeof message.earningsPershare !== "number")
                return "earningsPershare: number expected";
            if (!$util.isInteger(message.outstandingShares) && !(message.outstandingShares && $util.isInteger(message.outstandingShares.low) && $util.isInteger(message.outstandingShares.high)))
                return "outstandingShares: integer|Long expected";
            if (typeof message.outstandingMarketVal !== "number")
                return "outstandingMarketVal: number expected";
            if (typeof message.netAssetPershare !== "number")
                return "netAssetPershare: number expected";
            if (typeof message.eyRate !== "number")
                return "eyRate: number expected";
            if (typeof message.peRate !== "number")
                return "peRate: number expected";
            if (typeof message.pbRate !== "number")
                return "pbRate: number expected";
            if (typeof message.peTTMRate !== "number")
                return "peTTMRate: number expected";
            if (message.dividendTTM != null && message.hasOwnProperty("dividendTTM"))
                if (typeof message.dividendTTM !== "number")
                    return "dividendTTM: number expected";
            if (message.dividendRatioTTM != null && message.hasOwnProperty("dividendRatioTTM"))
                if (typeof message.dividendRatioTTM !== "number")
                    return "dividendRatioTTM: number expected";
            if (message.dividendLFY != null && message.hasOwnProperty("dividendLFY"))
                if (typeof message.dividendLFY !== "number")
                    return "dividendLFY: number expected";
            if (message.dividendLFYRatio != null && message.hasOwnProperty("dividendLFYRatio"))
                if (typeof message.dividendLFYRatio !== "number")
                    return "dividendLFYRatio: number expected";
            return null;
        };

        /**
         * Creates an EquitySnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.EquitySnapshotExData} EquitySnapshotExData
         */
        EquitySnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.EquitySnapshotExData)
                return object;
            let message = new $root.common.EquitySnapshotExData();
            if (object.issuedShares != null)
                if ($util.Long)
                    (message.issuedShares = $util.Long.fromValue(object.issuedShares)).unsigned = false;
                else if (typeof object.issuedShares === "string")
                    message.issuedShares = parseInt(object.issuedShares, 10);
                else if (typeof object.issuedShares === "number")
                    message.issuedShares = object.issuedShares;
                else if (typeof object.issuedShares === "object")
                    message.issuedShares = new $util.LongBits(object.issuedShares.low >>> 0, object.issuedShares.high >>> 0).toNumber();
            if (object.issuedMarketVal != null)
                message.issuedMarketVal = Number(object.issuedMarketVal);
            if (object.netAsset != null)
                message.netAsset = Number(object.netAsset);
            if (object.netProfit != null)
                message.netProfit = Number(object.netProfit);
            if (object.earningsPershare != null)
                message.earningsPershare = Number(object.earningsPershare);
            if (object.outstandingShares != null)
                if ($util.Long)
                    (message.outstandingShares = $util.Long.fromValue(object.outstandingShares)).unsigned = false;
                else if (typeof object.outstandingShares === "string")
                    message.outstandingShares = parseInt(object.outstandingShares, 10);
                else if (typeof object.outstandingShares === "number")
                    message.outstandingShares = object.outstandingShares;
                else if (typeof object.outstandingShares === "object")
                    message.outstandingShares = new $util.LongBits(object.outstandingShares.low >>> 0, object.outstandingShares.high >>> 0).toNumber();
            if (object.outstandingMarketVal != null)
                message.outstandingMarketVal = Number(object.outstandingMarketVal);
            if (object.netAssetPershare != null)
                message.netAssetPershare = Number(object.netAssetPershare);
            if (object.eyRate != null)
                message.eyRate = Number(object.eyRate);
            if (object.peRate != null)
                message.peRate = Number(object.peRate);
            if (object.pbRate != null)
                message.pbRate = Number(object.pbRate);
            if (object.peTTMRate != null)
                message.peTTMRate = Number(object.peTTMRate);
            if (object.dividendTTM != null)
                message.dividendTTM = Number(object.dividendTTM);
            if (object.dividendRatioTTM != null)
                message.dividendRatioTTM = Number(object.dividendRatioTTM);
            if (object.dividendLFY != null)
                message.dividendLFY = Number(object.dividendLFY);
            if (object.dividendLFYRatio != null)
                message.dividendLFYRatio = Number(object.dividendLFYRatio);
            return message;
        };

        /**
         * Creates a plain object from an EquitySnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {common.EquitySnapshotExData} message EquitySnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquitySnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.issuedShares = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issuedShares = options.longs === String ? "0" : 0;
                object.issuedMarketVal = 0;
                object.netAsset = 0;
                object.netProfit = 0;
                object.earningsPershare = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.outstandingShares = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.outstandingShares = options.longs === String ? "0" : 0;
                object.outstandingMarketVal = 0;
                object.netAssetPershare = 0;
                object.eyRate = 0;
                object.peRate = 0;
                object.pbRate = 0;
                object.peTTMRate = 0;
                object.dividendTTM = 0;
                object.dividendRatioTTM = 0;
                object.dividendLFY = 0;
                object.dividendLFYRatio = 0;
            }
            if (message.issuedShares != null && message.hasOwnProperty("issuedShares"))
                if (typeof message.issuedShares === "number")
                    object.issuedShares = options.longs === String ? String(message.issuedShares) : message.issuedShares;
                else
                    object.issuedShares = options.longs === String ? $util.Long.prototype.toString.call(message.issuedShares) : options.longs === Number ? new $util.LongBits(message.issuedShares.low >>> 0, message.issuedShares.high >>> 0).toNumber() : message.issuedShares;
            if (message.issuedMarketVal != null && message.hasOwnProperty("issuedMarketVal"))
                object.issuedMarketVal = options.json && !isFinite(message.issuedMarketVal) ? String(message.issuedMarketVal) : message.issuedMarketVal;
            if (message.netAsset != null && message.hasOwnProperty("netAsset"))
                object.netAsset = options.json && !isFinite(message.netAsset) ? String(message.netAsset) : message.netAsset;
            if (message.netProfit != null && message.hasOwnProperty("netProfit"))
                object.netProfit = options.json && !isFinite(message.netProfit) ? String(message.netProfit) : message.netProfit;
            if (message.earningsPershare != null && message.hasOwnProperty("earningsPershare"))
                object.earningsPershare = options.json && !isFinite(message.earningsPershare) ? String(message.earningsPershare) : message.earningsPershare;
            if (message.outstandingShares != null && message.hasOwnProperty("outstandingShares"))
                if (typeof message.outstandingShares === "number")
                    object.outstandingShares = options.longs === String ? String(message.outstandingShares) : message.outstandingShares;
                else
                    object.outstandingShares = options.longs === String ? $util.Long.prototype.toString.call(message.outstandingShares) : options.longs === Number ? new $util.LongBits(message.outstandingShares.low >>> 0, message.outstandingShares.high >>> 0).toNumber() : message.outstandingShares;
            if (message.outstandingMarketVal != null && message.hasOwnProperty("outstandingMarketVal"))
                object.outstandingMarketVal = options.json && !isFinite(message.outstandingMarketVal) ? String(message.outstandingMarketVal) : message.outstandingMarketVal;
            if (message.netAssetPershare != null && message.hasOwnProperty("netAssetPershare"))
                object.netAssetPershare = options.json && !isFinite(message.netAssetPershare) ? String(message.netAssetPershare) : message.netAssetPershare;
            if (message.eyRate != null && message.hasOwnProperty("eyRate"))
                object.eyRate = options.json && !isFinite(message.eyRate) ? String(message.eyRate) : message.eyRate;
            if (message.peRate != null && message.hasOwnProperty("peRate"))
                object.peRate = options.json && !isFinite(message.peRate) ? String(message.peRate) : message.peRate;
            if (message.pbRate != null && message.hasOwnProperty("pbRate"))
                object.pbRate = options.json && !isFinite(message.pbRate) ? String(message.pbRate) : message.pbRate;
            if (message.peTTMRate != null && message.hasOwnProperty("peTTMRate"))
                object.peTTMRate = options.json && !isFinite(message.peTTMRate) ? String(message.peTTMRate) : message.peTTMRate;
            if (message.dividendTTM != null && message.hasOwnProperty("dividendTTM"))
                object.dividendTTM = options.json && !isFinite(message.dividendTTM) ? String(message.dividendTTM) : message.dividendTTM;
            if (message.dividendRatioTTM != null && message.hasOwnProperty("dividendRatioTTM"))
                object.dividendRatioTTM = options.json && !isFinite(message.dividendRatioTTM) ? String(message.dividendRatioTTM) : message.dividendRatioTTM;
            if (message.dividendLFY != null && message.hasOwnProperty("dividendLFY"))
                object.dividendLFY = options.json && !isFinite(message.dividendLFY) ? String(message.dividendLFY) : message.dividendLFY;
            if (message.dividendLFYRatio != null && message.hasOwnProperty("dividendLFYRatio"))
                object.dividendLFYRatio = options.json && !isFinite(message.dividendLFYRatio) ? String(message.dividendLFYRatio) : message.dividendLFYRatio;
            return object;
        };

        /**
         * Converts this EquitySnapshotExData to JSON.
         * @function toJSON
         * @memberof common.EquitySnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquitySnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EquitySnapshotExData
         * @function getTypeUrl
         * @memberof common.EquitySnapshotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EquitySnapshotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.EquitySnapshotExData";
        };

        return EquitySnapshotExData;
    })();

    common.OptionSnapshotExData = (function() {

        /**
         * Properties of an OptionSnapshotExData.
         * @memberof common
         * @interface IOptionSnapshotExData
         * @property {common.OptionType} type OptionSnapshotExData type
         * @property {common.ISecurity} owner OptionSnapshotExData owner
         * @property {string} strikeTime OptionSnapshotExData strikeTime
         * @property {number} strikePrice OptionSnapshotExData strikePrice
         * @property {number} contractSize OptionSnapshotExData contractSize
         * @property {number|null} [contractSizeFloat] OptionSnapshotExData contractSizeFloat
         * @property {number} openInterest OptionSnapshotExData openInterest
         * @property {number} impliedVolatility OptionSnapshotExData impliedVolatility
         * @property {number} premium OptionSnapshotExData premium
         * @property {number} delta OptionSnapshotExData delta
         * @property {number} gamma OptionSnapshotExData gamma
         * @property {number} vega OptionSnapshotExData vega
         * @property {number} theta OptionSnapshotExData theta
         * @property {number} rho OptionSnapshotExData rho
         * @property {number|null} [strikeTimestamp] OptionSnapshotExData strikeTimestamp
         * @property {common.IndexOptionType|null} [indexOptionType] OptionSnapshotExData indexOptionType
         * @property {number|null} [netOpenInterest] OptionSnapshotExData netOpenInterest
         * @property {number|null} [expiryDateDistance] OptionSnapshotExData expiryDateDistance
         * @property {number|null} [contractNominalValue] OptionSnapshotExData contractNominalValue
         * @property {number|null} [ownerLotMultiplier] OptionSnapshotExData ownerLotMultiplier
         * @property {common.OptionAreaType|null} [optionAreaType] OptionSnapshotExData optionAreaType
         * @property {number|null} [contractMultiplier] OptionSnapshotExData contractMultiplier
         */

        /**
         * Constructs a new OptionSnapshotExData.
         * @memberof common
         * @classdesc 期权类型额外数据
         * @implements IOptionSnapshotExData
         * @constructor
         * @param {common.IOptionSnapshotExData=} [properties] Properties to set
         */
        function OptionSnapshotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionSnapshotExData type.
         * @member {common.OptionType} type
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.type = 0;

        /**
         * OptionSnapshotExData owner.
         * @member {common.ISecurity} owner
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.owner = null;

        /**
         * OptionSnapshotExData strikeTime.
         * @member {string} strikeTime
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikeTime = "";

        /**
         * OptionSnapshotExData strikePrice.
         * @member {number} strikePrice
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikePrice = 0;

        /**
         * OptionSnapshotExData contractSize.
         * @member {number} contractSize
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractSize = 0;

        /**
         * OptionSnapshotExData contractSizeFloat.
         * @member {number} contractSizeFloat
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractSizeFloat = 0;

        /**
         * OptionSnapshotExData openInterest.
         * @member {number} openInterest
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.openInterest = 0;

        /**
         * OptionSnapshotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.impliedVolatility = 0;

        /**
         * OptionSnapshotExData premium.
         * @member {number} premium
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.premium = 0;

        /**
         * OptionSnapshotExData delta.
         * @member {number} delta
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.delta = 0;

        /**
         * OptionSnapshotExData gamma.
         * @member {number} gamma
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.gamma = 0;

        /**
         * OptionSnapshotExData vega.
         * @member {number} vega
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.vega = 0;

        /**
         * OptionSnapshotExData theta.
         * @member {number} theta
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.theta = 0;

        /**
         * OptionSnapshotExData rho.
         * @member {number} rho
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.rho = 0;

        /**
         * OptionSnapshotExData strikeTimestamp.
         * @member {number} strikeTimestamp
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikeTimestamp = 0;

        /**
         * OptionSnapshotExData indexOptionType.
         * @member {common.IndexOptionType} indexOptionType
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.indexOptionType = 0;

        /**
         * OptionSnapshotExData netOpenInterest.
         * @member {number} netOpenInterest
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.netOpenInterest = 0;

        /**
         * OptionSnapshotExData expiryDateDistance.
         * @member {number} expiryDateDistance
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.expiryDateDistance = 0;

        /**
         * OptionSnapshotExData contractNominalValue.
         * @member {number} contractNominalValue
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractNominalValue = 0;

        /**
         * OptionSnapshotExData ownerLotMultiplier.
         * @member {number} ownerLotMultiplier
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.ownerLotMultiplier = 0;

        /**
         * OptionSnapshotExData optionAreaType.
         * @member {common.OptionAreaType} optionAreaType
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.optionAreaType = 0;

        /**
         * OptionSnapshotExData contractMultiplier.
         * @member {number} contractMultiplier
         * @memberof common.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractMultiplier = 0;

        /**
         * Creates a new OptionSnapshotExData instance using the specified properties.
         * @function create
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {common.IOptionSnapshotExData=} [properties] Properties to set
         * @returns {common.OptionSnapshotExData} OptionSnapshotExData instance
         */
        OptionSnapshotExData.create = function create(properties) {
            return new OptionSnapshotExData(properties);
        };

        /**
         * Encodes the specified OptionSnapshotExData message. Does not implicitly {@link common.OptionSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {common.IOptionSnapshotExData} message OptionSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.strikeTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.strikePrice);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.contractSize);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.openInterest);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.impliedVolatility);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.premium);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.delta);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.gamma);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.vega);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.theta);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.rho);
            if (message.strikeTimestamp != null && Object.hasOwnProperty.call(message, "strikeTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.strikeTimestamp);
            if (message.indexOptionType != null && Object.hasOwnProperty.call(message, "indexOptionType"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.indexOptionType);
            if (message.netOpenInterest != null && Object.hasOwnProperty.call(message, "netOpenInterest"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.netOpenInterest);
            if (message.expiryDateDistance != null && Object.hasOwnProperty.call(message, "expiryDateDistance"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.expiryDateDistance);
            if (message.contractNominalValue != null && Object.hasOwnProperty.call(message, "contractNominalValue"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.contractNominalValue);
            if (message.ownerLotMultiplier != null && Object.hasOwnProperty.call(message, "ownerLotMultiplier"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.ownerLotMultiplier);
            if (message.optionAreaType != null && Object.hasOwnProperty.call(message, "optionAreaType"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.optionAreaType);
            if (message.contractMultiplier != null && Object.hasOwnProperty.call(message, "contractMultiplier"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.contractMultiplier);
            if (message.contractSizeFloat != null && Object.hasOwnProperty.call(message, "contractSizeFloat"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.contractSizeFloat);
            return writer;
        };

        /**
         * Encodes the specified OptionSnapshotExData message, length delimited. Does not implicitly {@link common.OptionSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {common.IOptionSnapshotExData} message OptionSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.OptionSnapshotExData} OptionSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OptionSnapshotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.owner = $root.common.Security.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.strikeTime = reader.string();
                        break;
                    }
                case 4: {
                        message.strikePrice = reader.double();
                        break;
                    }
                case 5: {
                        message.contractSize = reader.int32();
                        break;
                    }
                case 22: {
                        message.contractSizeFloat = reader.double();
                        break;
                    }
                case 6: {
                        message.openInterest = reader.int32();
                        break;
                    }
                case 7: {
                        message.impliedVolatility = reader.double();
                        break;
                    }
                case 8: {
                        message.premium = reader.double();
                        break;
                    }
                case 9: {
                        message.delta = reader.double();
                        break;
                    }
                case 10: {
                        message.gamma = reader.double();
                        break;
                    }
                case 11: {
                        message.vega = reader.double();
                        break;
                    }
                case 12: {
                        message.theta = reader.double();
                        break;
                    }
                case 13: {
                        message.rho = reader.double();
                        break;
                    }
                case 14: {
                        message.strikeTimestamp = reader.double();
                        break;
                    }
                case 15: {
                        message.indexOptionType = reader.int32();
                        break;
                    }
                case 16: {
                        message.netOpenInterest = reader.int32();
                        break;
                    }
                case 17: {
                        message.expiryDateDistance = reader.int32();
                        break;
                    }
                case 18: {
                        message.contractNominalValue = reader.double();
                        break;
                    }
                case 19: {
                        message.ownerLotMultiplier = reader.double();
                        break;
                    }
                case 20: {
                        message.optionAreaType = reader.int32();
                        break;
                    }
                case 21: {
                        message.contractMultiplier = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("strikeTime"))
                throw $util.ProtocolError("missing required 'strikeTime'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("contractSize"))
                throw $util.ProtocolError("missing required 'contractSize'", { instance: message });
            if (!message.hasOwnProperty("openInterest"))
                throw $util.ProtocolError("missing required 'openInterest'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("gamma"))
                throw $util.ProtocolError("missing required 'gamma'", { instance: message });
            if (!message.hasOwnProperty("vega"))
                throw $util.ProtocolError("missing required 'vega'", { instance: message });
            if (!message.hasOwnProperty("theta"))
                throw $util.ProtocolError("missing required 'theta'", { instance: message });
            if (!message.hasOwnProperty("rho"))
                throw $util.ProtocolError("missing required 'rho'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.OptionSnapshotExData} OptionSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionSnapshotExData message.
         * @function verify
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
            {
                let error = $root.common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isString(message.strikeTime))
                return "strikeTime: string expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isInteger(message.contractSize))
                return "contractSize: integer expected";
            if (message.contractSizeFloat != null && message.hasOwnProperty("contractSizeFloat"))
                if (typeof message.contractSizeFloat !== "number")
                    return "contractSizeFloat: number expected";
            if (!$util.isInteger(message.openInterest))
                return "openInterest: integer expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.gamma !== "number")
                return "gamma: number expected";
            if (typeof message.vega !== "number")
                return "vega: number expected";
            if (typeof message.theta !== "number")
                return "theta: number expected";
            if (typeof message.rho !== "number")
                return "rho: number expected";
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                if (typeof message.strikeTimestamp !== "number")
                    return "strikeTimestamp: number expected";
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                switch (message.indexOptionType) {
                default:
                    return "indexOptionType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                if (!$util.isInteger(message.netOpenInterest))
                    return "netOpenInterest: integer expected";
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                if (!$util.isInteger(message.expiryDateDistance))
                    return "expiryDateDistance: integer expected";
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                if (typeof message.contractNominalValue !== "number")
                    return "contractNominalValue: number expected";
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                if (typeof message.ownerLotMultiplier !== "number")
                    return "ownerLotMultiplier: number expected";
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                switch (message.optionAreaType) {
                default:
                    return "optionAreaType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                if (typeof message.contractMultiplier !== "number")
                    return "contractMultiplier: number expected";
            return null;
        };

        /**
         * Creates an OptionSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.OptionSnapshotExData} OptionSnapshotExData
         */
        OptionSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.OptionSnapshotExData)
                return object;
            let message = new $root.common.OptionSnapshotExData();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "OptionType_Unknown":
            case 0:
                message.type = 0;
                break;
            case "OptionType_Call":
            case 1:
                message.type = 1;
                break;
            case "OptionType_Put":
            case 2:
                message.type = 2;
                break;
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".common.OptionSnapshotExData.owner: object expected");
                message.owner = $root.common.Security.fromObject(object.owner);
            }
            if (object.strikeTime != null)
                message.strikeTime = String(object.strikeTime);
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.contractSize != null)
                message.contractSize = object.contractSize | 0;
            if (object.contractSizeFloat != null)
                message.contractSizeFloat = Number(object.contractSizeFloat);
            if (object.openInterest != null)
                message.openInterest = object.openInterest | 0;
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.gamma != null)
                message.gamma = Number(object.gamma);
            if (object.vega != null)
                message.vega = Number(object.vega);
            if (object.theta != null)
                message.theta = Number(object.theta);
            if (object.rho != null)
                message.rho = Number(object.rho);
            if (object.strikeTimestamp != null)
                message.strikeTimestamp = Number(object.strikeTimestamp);
            switch (object.indexOptionType) {
            default:
                if (typeof object.indexOptionType === "number") {
                    message.indexOptionType = object.indexOptionType;
                    break;
                }
                break;
            case "IndexOptionType_Unknown":
            case 0:
                message.indexOptionType = 0;
                break;
            case "IndexOptionType_Normal":
            case 1:
                message.indexOptionType = 1;
                break;
            case "IndexOptionType_Small":
            case 2:
                message.indexOptionType = 2;
                break;
            }
            if (object.netOpenInterest != null)
                message.netOpenInterest = object.netOpenInterest | 0;
            if (object.expiryDateDistance != null)
                message.expiryDateDistance = object.expiryDateDistance | 0;
            if (object.contractNominalValue != null)
                message.contractNominalValue = Number(object.contractNominalValue);
            if (object.ownerLotMultiplier != null)
                message.ownerLotMultiplier = Number(object.ownerLotMultiplier);
            switch (object.optionAreaType) {
            default:
                if (typeof object.optionAreaType === "number") {
                    message.optionAreaType = object.optionAreaType;
                    break;
                }
                break;
            case "OptionAreaType_Unknown":
            case 0:
                message.optionAreaType = 0;
                break;
            case "OptionAreaType_American":
            case 1:
                message.optionAreaType = 1;
                break;
            case "OptionAreaType_European":
            case 2:
                message.optionAreaType = 2;
                break;
            case "OptionAreaType_Bermuda":
            case 3:
                message.optionAreaType = 3;
                break;
            }
            if (object.contractMultiplier != null)
                message.contractMultiplier = Number(object.contractMultiplier);
            return message;
        };

        /**
         * Creates a plain object from an OptionSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {common.OptionSnapshotExData} message OptionSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "OptionType_Unknown" : 0;
                object.owner = null;
                object.strikeTime = "";
                object.strikePrice = 0;
                object.contractSize = 0;
                object.openInterest = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.delta = 0;
                object.gamma = 0;
                object.vega = 0;
                object.theta = 0;
                object.rho = 0;
                object.strikeTimestamp = 0;
                object.indexOptionType = options.enums === String ? "IndexOptionType_Unknown" : 0;
                object.netOpenInterest = 0;
                object.expiryDateDistance = 0;
                object.contractNominalValue = 0;
                object.ownerLotMultiplier = 0;
                object.optionAreaType = options.enums === String ? "OptionAreaType_Unknown" : 0;
                object.contractMultiplier = 0;
                object.contractSizeFloat = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.common.OptionType[message.type] === undefined ? message.type : $root.common.OptionType[message.type] : message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.common.Security.toObject(message.owner, options);
            if (message.strikeTime != null && message.hasOwnProperty("strikeTime"))
                object.strikeTime = message.strikeTime;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.contractSize != null && message.hasOwnProperty("contractSize"))
                object.contractSize = message.contractSize;
            if (message.openInterest != null && message.hasOwnProperty("openInterest"))
                object.openInterest = message.openInterest;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
            if (message.vega != null && message.hasOwnProperty("vega"))
                object.vega = options.json && !isFinite(message.vega) ? String(message.vega) : message.vega;
            if (message.theta != null && message.hasOwnProperty("theta"))
                object.theta = options.json && !isFinite(message.theta) ? String(message.theta) : message.theta;
            if (message.rho != null && message.hasOwnProperty("rho"))
                object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                object.strikeTimestamp = options.json && !isFinite(message.strikeTimestamp) ? String(message.strikeTimestamp) : message.strikeTimestamp;
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                object.indexOptionType = options.enums === String ? $root.common.IndexOptionType[message.indexOptionType] === undefined ? message.indexOptionType : $root.common.IndexOptionType[message.indexOptionType] : message.indexOptionType;
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                object.netOpenInterest = message.netOpenInterest;
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                object.expiryDateDistance = message.expiryDateDistance;
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                object.contractNominalValue = options.json && !isFinite(message.contractNominalValue) ? String(message.contractNominalValue) : message.contractNominalValue;
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                object.ownerLotMultiplier = options.json && !isFinite(message.ownerLotMultiplier) ? String(message.ownerLotMultiplier) : message.ownerLotMultiplier;
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                object.optionAreaType = options.enums === String ? $root.common.OptionAreaType[message.optionAreaType] === undefined ? message.optionAreaType : $root.common.OptionAreaType[message.optionAreaType] : message.optionAreaType;
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                object.contractMultiplier = options.json && !isFinite(message.contractMultiplier) ? String(message.contractMultiplier) : message.contractMultiplier;
            if (message.contractSizeFloat != null && message.hasOwnProperty("contractSizeFloat"))
                object.contractSizeFloat = options.json && !isFinite(message.contractSizeFloat) ? String(message.contractSizeFloat) : message.contractSizeFloat;
            return object;
        };

        /**
         * Converts this OptionSnapshotExData to JSON.
         * @function toJSON
         * @memberof common.OptionSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OptionSnapshotExData
         * @function getTypeUrl
         * @memberof common.OptionSnapshotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OptionSnapshotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.OptionSnapshotExData";
        };

        return OptionSnapshotExData;
    })();

    common.WarrantSnapshotExData = (function() {

        /**
         * Properties of a WarrantSnapshotExData.
         * @memberof common
         * @interface IWarrantSnapshotExData
         * @property {number} conversionRate WarrantSnapshotExData conversionRate
         * @property {common.WarrantType} warrantType WarrantSnapshotExData warrantType
         * @property {number} strikePrice WarrantSnapshotExData strikePrice
         * @property {string} maturityTime WarrantSnapshotExData maturityTime
         * @property {string} endTradeTime WarrantSnapshotExData endTradeTime
         * @property {common.ISecurity} owner WarrantSnapshotExData owner
         * @property {number} recoveryPrice WarrantSnapshotExData recoveryPrice
         * @property {number|Long} streetVolumn WarrantSnapshotExData streetVolumn
         * @property {number|Long} issueVolumn WarrantSnapshotExData issueVolumn
         * @property {number} streetRate WarrantSnapshotExData streetRate
         * @property {number} delta WarrantSnapshotExData delta
         * @property {number} impliedVolatility WarrantSnapshotExData impliedVolatility
         * @property {number} premium WarrantSnapshotExData premium
         * @property {number|null} [maturityTimestamp] WarrantSnapshotExData maturityTimestamp
         * @property {number|null} [endTradeTimestamp] WarrantSnapshotExData endTradeTimestamp
         * @property {number|null} [leverage] WarrantSnapshotExData leverage
         * @property {number|null} [ipop] WarrantSnapshotExData ipop
         * @property {number|null} [breakEvenPoint] WarrantSnapshotExData breakEvenPoint
         * @property {number|null} [conversionPrice] WarrantSnapshotExData conversionPrice
         * @property {number|null} [priceRecoveryRatio] WarrantSnapshotExData priceRecoveryRatio
         * @property {number|null} [score] WarrantSnapshotExData score
         * @property {number|null} [upperStrikePrice] WarrantSnapshotExData upperStrikePrice
         * @property {number|null} [lowerStrikePrice] WarrantSnapshotExData lowerStrikePrice
         * @property {common.PriceType|null} [inLinePriceStatus] WarrantSnapshotExData inLinePriceStatus
         * @property {string|null} [issuerCode] WarrantSnapshotExData issuerCode
         */

        /**
         * Constructs a new WarrantSnapshotExData.
         * @memberof common
         * @classdesc 窝轮类型额外数据
         * @implements IWarrantSnapshotExData
         * @constructor
         * @param {common.IWarrantSnapshotExData=} [properties] Properties to set
         */
        function WarrantSnapshotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantSnapshotExData conversionRate.
         * @member {number} conversionRate
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.conversionRate = 0;

        /**
         * WarrantSnapshotExData warrantType.
         * @member {common.WarrantType} warrantType
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.warrantType = 0;

        /**
         * WarrantSnapshotExData strikePrice.
         * @member {number} strikePrice
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.strikePrice = 0;

        /**
         * WarrantSnapshotExData maturityTime.
         * @member {string} maturityTime
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.maturityTime = "";

        /**
         * WarrantSnapshotExData endTradeTime.
         * @member {string} endTradeTime
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.endTradeTime = "";

        /**
         * WarrantSnapshotExData owner.
         * @member {common.ISecurity} owner
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.owner = null;

        /**
         * WarrantSnapshotExData recoveryPrice.
         * @member {number} recoveryPrice
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.recoveryPrice = 0;

        /**
         * WarrantSnapshotExData streetVolumn.
         * @member {number|Long} streetVolumn
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.streetVolumn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantSnapshotExData issueVolumn.
         * @member {number|Long} issueVolumn
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.issueVolumn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantSnapshotExData streetRate.
         * @member {number} streetRate
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.streetRate = 0;

        /**
         * WarrantSnapshotExData delta.
         * @member {number} delta
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.delta = 0;

        /**
         * WarrantSnapshotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.impliedVolatility = 0;

        /**
         * WarrantSnapshotExData premium.
         * @member {number} premium
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.premium = 0;

        /**
         * WarrantSnapshotExData maturityTimestamp.
         * @member {number} maturityTimestamp
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.maturityTimestamp = 0;

        /**
         * WarrantSnapshotExData endTradeTimestamp.
         * @member {number} endTradeTimestamp
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.endTradeTimestamp = 0;

        /**
         * WarrantSnapshotExData leverage.
         * @member {number} leverage
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.leverage = 0;

        /**
         * WarrantSnapshotExData ipop.
         * @member {number} ipop
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.ipop = 0;

        /**
         * WarrantSnapshotExData breakEvenPoint.
         * @member {number} breakEvenPoint
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.breakEvenPoint = 0;

        /**
         * WarrantSnapshotExData conversionPrice.
         * @member {number} conversionPrice
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.conversionPrice = 0;

        /**
         * WarrantSnapshotExData priceRecoveryRatio.
         * @member {number} priceRecoveryRatio
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.priceRecoveryRatio = 0;

        /**
         * WarrantSnapshotExData score.
         * @member {number} score
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.score = 0;

        /**
         * WarrantSnapshotExData upperStrikePrice.
         * @member {number} upperStrikePrice
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.upperStrikePrice = 0;

        /**
         * WarrantSnapshotExData lowerStrikePrice.
         * @member {number} lowerStrikePrice
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.lowerStrikePrice = 0;

        /**
         * WarrantSnapshotExData inLinePriceStatus.
         * @member {common.PriceType} inLinePriceStatus
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.inLinePriceStatus = 0;

        /**
         * WarrantSnapshotExData issuerCode.
         * @member {string} issuerCode
         * @memberof common.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.issuerCode = "";

        /**
         * Creates a new WarrantSnapshotExData instance using the specified properties.
         * @function create
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {common.IWarrantSnapshotExData=} [properties] Properties to set
         * @returns {common.WarrantSnapshotExData} WarrantSnapshotExData instance
         */
        WarrantSnapshotExData.create = function create(properties) {
            return new WarrantSnapshotExData(properties);
        };

        /**
         * Encodes the specified WarrantSnapshotExData message. Does not implicitly {@link common.WarrantSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {common.IWarrantSnapshotExData} message WarrantSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.conversionRate);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.warrantType);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.strikePrice);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.maturityTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTradeTime);
            $root.common.Security.encode(message.owner, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.recoveryPrice);
            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.streetVolumn);
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.issueVolumn);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.streetRate);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.delta);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.impliedVolatility);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.premium);
            if (message.maturityTimestamp != null && Object.hasOwnProperty.call(message, "maturityTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.maturityTimestamp);
            if (message.endTradeTimestamp != null && Object.hasOwnProperty.call(message, "endTradeTimestamp"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.endTradeTimestamp);
            if (message.leverage != null && Object.hasOwnProperty.call(message, "leverage"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.leverage);
            if (message.ipop != null && Object.hasOwnProperty.call(message, "ipop"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.ipop);
            if (message.breakEvenPoint != null && Object.hasOwnProperty.call(message, "breakEvenPoint"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.breakEvenPoint);
            if (message.conversionPrice != null && Object.hasOwnProperty.call(message, "conversionPrice"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.conversionPrice);
            if (message.priceRecoveryRatio != null && Object.hasOwnProperty.call(message, "priceRecoveryRatio"))
                writer.uint32(/* id 20, wireType 1 =*/161).double(message.priceRecoveryRatio);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.score);
            if (message.upperStrikePrice != null && Object.hasOwnProperty.call(message, "upperStrikePrice"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.upperStrikePrice);
            if (message.lowerStrikePrice != null && Object.hasOwnProperty.call(message, "lowerStrikePrice"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.lowerStrikePrice);
            if (message.inLinePriceStatus != null && Object.hasOwnProperty.call(message, "inLinePriceStatus"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.inLinePriceStatus);
            if (message.issuerCode != null && Object.hasOwnProperty.call(message, "issuerCode"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.issuerCode);
            return writer;
        };

        /**
         * Encodes the specified WarrantSnapshotExData message, length delimited. Does not implicitly {@link common.WarrantSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {common.IWarrantSnapshotExData} message WarrantSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.WarrantSnapshotExData} WarrantSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.WarrantSnapshotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.conversionRate = reader.double();
                        break;
                    }
                case 2: {
                        message.warrantType = reader.int32();
                        break;
                    }
                case 3: {
                        message.strikePrice = reader.double();
                        break;
                    }
                case 4: {
                        message.maturityTime = reader.string();
                        break;
                    }
                case 5: {
                        message.endTradeTime = reader.string();
                        break;
                    }
                case 6: {
                        message.owner = $root.common.Security.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.recoveryPrice = reader.double();
                        break;
                    }
                case 8: {
                        message.streetVolumn = reader.int64();
                        break;
                    }
                case 9: {
                        message.issueVolumn = reader.int64();
                        break;
                    }
                case 10: {
                        message.streetRate = reader.double();
                        break;
                    }
                case 11: {
                        message.delta = reader.double();
                        break;
                    }
                case 12: {
                        message.impliedVolatility = reader.double();
                        break;
                    }
                case 13: {
                        message.premium = reader.double();
                        break;
                    }
                case 14: {
                        message.maturityTimestamp = reader.double();
                        break;
                    }
                case 15: {
                        message.endTradeTimestamp = reader.double();
                        break;
                    }
                case 16: {
                        message.leverage = reader.double();
                        break;
                    }
                case 17: {
                        message.ipop = reader.double();
                        break;
                    }
                case 18: {
                        message.breakEvenPoint = reader.double();
                        break;
                    }
                case 19: {
                        message.conversionPrice = reader.double();
                        break;
                    }
                case 20: {
                        message.priceRecoveryRatio = reader.double();
                        break;
                    }
                case 21: {
                        message.score = reader.double();
                        break;
                    }
                case 22: {
                        message.upperStrikePrice = reader.double();
                        break;
                    }
                case 23: {
                        message.lowerStrikePrice = reader.double();
                        break;
                    }
                case 24: {
                        message.inLinePriceStatus = reader.int32();
                        break;
                    }
                case 25: {
                        message.issuerCode = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("conversionRate"))
                throw $util.ProtocolError("missing required 'conversionRate'", { instance: message });
            if (!message.hasOwnProperty("warrantType"))
                throw $util.ProtocolError("missing required 'warrantType'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("maturityTime"))
                throw $util.ProtocolError("missing required 'maturityTime'", { instance: message });
            if (!message.hasOwnProperty("endTradeTime"))
                throw $util.ProtocolError("missing required 'endTradeTime'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("recoveryPrice"))
                throw $util.ProtocolError("missing required 'recoveryPrice'", { instance: message });
            if (!message.hasOwnProperty("streetVolumn"))
                throw $util.ProtocolError("missing required 'streetVolumn'", { instance: message });
            if (!message.hasOwnProperty("issueVolumn"))
                throw $util.ProtocolError("missing required 'issueVolumn'", { instance: message });
            if (!message.hasOwnProperty("streetRate"))
                throw $util.ProtocolError("missing required 'streetRate'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.WarrantSnapshotExData} WarrantSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantSnapshotExData message.
         * @function verify
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.conversionRate !== "number")
                return "conversionRate: number expected";
            switch (message.warrantType) {
            default:
                return "warrantType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isString(message.maturityTime))
                return "maturityTime: string expected";
            if (!$util.isString(message.endTradeTime))
                return "endTradeTime: string expected";
            {
                let error = $root.common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (typeof message.recoveryPrice !== "number")
                return "recoveryPrice: number expected";
            if (!$util.isInteger(message.streetVolumn) && !(message.streetVolumn && $util.isInteger(message.streetVolumn.low) && $util.isInteger(message.streetVolumn.high)))
                return "streetVolumn: integer|Long expected";
            if (!$util.isInteger(message.issueVolumn) && !(message.issueVolumn && $util.isInteger(message.issueVolumn.low) && $util.isInteger(message.issueVolumn.high)))
                return "issueVolumn: integer|Long expected";
            if (typeof message.streetRate !== "number")
                return "streetRate: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                if (typeof message.maturityTimestamp !== "number")
                    return "maturityTimestamp: number expected";
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                if (typeof message.endTradeTimestamp !== "number")
                    return "endTradeTimestamp: number expected";
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                if (typeof message.leverage !== "number")
                    return "leverage: number expected";
            if (message.ipop != null && message.hasOwnProperty("ipop"))
                if (typeof message.ipop !== "number")
                    return "ipop: number expected";
            if (message.breakEvenPoint != null && message.hasOwnProperty("breakEvenPoint"))
                if (typeof message.breakEvenPoint !== "number")
                    return "breakEvenPoint: number expected";
            if (message.conversionPrice != null && message.hasOwnProperty("conversionPrice"))
                if (typeof message.conversionPrice !== "number")
                    return "conversionPrice: number expected";
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                if (typeof message.priceRecoveryRatio !== "number")
                    return "priceRecoveryRatio: number expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                if (typeof message.upperStrikePrice !== "number")
                    return "upperStrikePrice: number expected";
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                if (typeof message.lowerStrikePrice !== "number")
                    return "lowerStrikePrice: number expected";
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                switch (message.inLinePriceStatus) {
                default:
                    return "inLinePriceStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.issuerCode != null && message.hasOwnProperty("issuerCode"))
                if (!$util.isString(message.issuerCode))
                    return "issuerCode: string expected";
            return null;
        };

        /**
         * Creates a WarrantSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.WarrantSnapshotExData} WarrantSnapshotExData
         */
        WarrantSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.WarrantSnapshotExData)
                return object;
            let message = new $root.common.WarrantSnapshotExData();
            if (object.conversionRate != null)
                message.conversionRate = Number(object.conversionRate);
            switch (object.warrantType) {
            default:
                if (typeof object.warrantType === "number") {
                    message.warrantType = object.warrantType;
                    break;
                }
                break;
            case "WarrantType_Unknown":
            case 0:
                message.warrantType = 0;
                break;
            case "WarrantType_Buy":
            case 1:
                message.warrantType = 1;
                break;
            case "WarrantType_Sell":
            case 2:
                message.warrantType = 2;
                break;
            case "WarrantType_Bull":
            case 3:
                message.warrantType = 3;
                break;
            case "WarrantType_Bear":
            case 4:
                message.warrantType = 4;
                break;
            case "WarrantType_InLine":
            case 5:
                message.warrantType = 5;
                break;
            }
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.maturityTime != null)
                message.maturityTime = String(object.maturityTime);
            if (object.endTradeTime != null)
                message.endTradeTime = String(object.endTradeTime);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".common.WarrantSnapshotExData.owner: object expected");
                message.owner = $root.common.Security.fromObject(object.owner);
            }
            if (object.recoveryPrice != null)
                message.recoveryPrice = Number(object.recoveryPrice);
            if (object.streetVolumn != null)
                if ($util.Long)
                    (message.streetVolumn = $util.Long.fromValue(object.streetVolumn)).unsigned = false;
                else if (typeof object.streetVolumn === "string")
                    message.streetVolumn = parseInt(object.streetVolumn, 10);
                else if (typeof object.streetVolumn === "number")
                    message.streetVolumn = object.streetVolumn;
                else if (typeof object.streetVolumn === "object")
                    message.streetVolumn = new $util.LongBits(object.streetVolumn.low >>> 0, object.streetVolumn.high >>> 0).toNumber();
            if (object.issueVolumn != null)
                if ($util.Long)
                    (message.issueVolumn = $util.Long.fromValue(object.issueVolumn)).unsigned = false;
                else if (typeof object.issueVolumn === "string")
                    message.issueVolumn = parseInt(object.issueVolumn, 10);
                else if (typeof object.issueVolumn === "number")
                    message.issueVolumn = object.issueVolumn;
                else if (typeof object.issueVolumn === "object")
                    message.issueVolumn = new $util.LongBits(object.issueVolumn.low >>> 0, object.issueVolumn.high >>> 0).toNumber();
            if (object.streetRate != null)
                message.streetRate = Number(object.streetRate);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.maturityTimestamp != null)
                message.maturityTimestamp = Number(object.maturityTimestamp);
            if (object.endTradeTimestamp != null)
                message.endTradeTimestamp = Number(object.endTradeTimestamp);
            if (object.leverage != null)
                message.leverage = Number(object.leverage);
            if (object.ipop != null)
                message.ipop = Number(object.ipop);
            if (object.breakEvenPoint != null)
                message.breakEvenPoint = Number(object.breakEvenPoint);
            if (object.conversionPrice != null)
                message.conversionPrice = Number(object.conversionPrice);
            if (object.priceRecoveryRatio != null)
                message.priceRecoveryRatio = Number(object.priceRecoveryRatio);
            if (object.score != null)
                message.score = Number(object.score);
            if (object.upperStrikePrice != null)
                message.upperStrikePrice = Number(object.upperStrikePrice);
            if (object.lowerStrikePrice != null)
                message.lowerStrikePrice = Number(object.lowerStrikePrice);
            switch (object.inLinePriceStatus) {
            default:
                if (typeof object.inLinePriceStatus === "number") {
                    message.inLinePriceStatus = object.inLinePriceStatus;
                    break;
                }
                break;
            case "PriceType_Unknow":
            case 0:
                message.inLinePriceStatus = 0;
                break;
            case "PriceType_Outside":
            case 1:
                message.inLinePriceStatus = 1;
                break;
            case "PriceType_WithIn":
            case 2:
                message.inLinePriceStatus = 2;
                break;
            }
            if (object.issuerCode != null)
                message.issuerCode = String(object.issuerCode);
            return message;
        };

        /**
         * Creates a plain object from a WarrantSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {common.WarrantSnapshotExData} message WarrantSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.conversionRate = 0;
                object.warrantType = options.enums === String ? "WarrantType_Unknown" : 0;
                object.strikePrice = 0;
                object.maturityTime = "";
                object.endTradeTime = "";
                object.owner = null;
                object.recoveryPrice = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.streetVolumn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.streetVolumn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.issueVolumn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueVolumn = options.longs === String ? "0" : 0;
                object.streetRate = 0;
                object.delta = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.maturityTimestamp = 0;
                object.endTradeTimestamp = 0;
                object.leverage = 0;
                object.ipop = 0;
                object.breakEvenPoint = 0;
                object.conversionPrice = 0;
                object.priceRecoveryRatio = 0;
                object.score = 0;
                object.upperStrikePrice = 0;
                object.lowerStrikePrice = 0;
                object.inLinePriceStatus = options.enums === String ? "PriceType_Unknow" : 0;
                object.issuerCode = "";
            }
            if (message.conversionRate != null && message.hasOwnProperty("conversionRate"))
                object.conversionRate = options.json && !isFinite(message.conversionRate) ? String(message.conversionRate) : message.conversionRate;
            if (message.warrantType != null && message.hasOwnProperty("warrantType"))
                object.warrantType = options.enums === String ? $root.common.WarrantType[message.warrantType] === undefined ? message.warrantType : $root.common.WarrantType[message.warrantType] : message.warrantType;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.maturityTime != null && message.hasOwnProperty("maturityTime"))
                object.maturityTime = message.maturityTime;
            if (message.endTradeTime != null && message.hasOwnProperty("endTradeTime"))
                object.endTradeTime = message.endTradeTime;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.common.Security.toObject(message.owner, options);
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                object.recoveryPrice = options.json && !isFinite(message.recoveryPrice) ? String(message.recoveryPrice) : message.recoveryPrice;
            if (message.streetVolumn != null && message.hasOwnProperty("streetVolumn"))
                if (typeof message.streetVolumn === "number")
                    object.streetVolumn = options.longs === String ? String(message.streetVolumn) : message.streetVolumn;
                else
                    object.streetVolumn = options.longs === String ? $util.Long.prototype.toString.call(message.streetVolumn) : options.longs === Number ? new $util.LongBits(message.streetVolumn.low >>> 0, message.streetVolumn.high >>> 0).toNumber() : message.streetVolumn;
            if (message.issueVolumn != null && message.hasOwnProperty("issueVolumn"))
                if (typeof message.issueVolumn === "number")
                    object.issueVolumn = options.longs === String ? String(message.issueVolumn) : message.issueVolumn;
                else
                    object.issueVolumn = options.longs === String ? $util.Long.prototype.toString.call(message.issueVolumn) : options.longs === Number ? new $util.LongBits(message.issueVolumn.low >>> 0, message.issueVolumn.high >>> 0).toNumber() : message.issueVolumn;
            if (message.streetRate != null && message.hasOwnProperty("streetRate"))
                object.streetRate = options.json && !isFinite(message.streetRate) ? String(message.streetRate) : message.streetRate;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                object.maturityTimestamp = options.json && !isFinite(message.maturityTimestamp) ? String(message.maturityTimestamp) : message.maturityTimestamp;
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                object.endTradeTimestamp = options.json && !isFinite(message.endTradeTimestamp) ? String(message.endTradeTimestamp) : message.endTradeTimestamp;
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                object.leverage = options.json && !isFinite(message.leverage) ? String(message.leverage) : message.leverage;
            if (message.ipop != null && message.hasOwnProperty("ipop"))
                object.ipop = options.json && !isFinite(message.ipop) ? String(message.ipop) : message.ipop;
            if (message.breakEvenPoint != null && message.hasOwnProperty("breakEvenPoint"))
                object.breakEvenPoint = options.json && !isFinite(message.breakEvenPoint) ? String(message.breakEvenPoint) : message.breakEvenPoint;
            if (message.conversionPrice != null && message.hasOwnProperty("conversionPrice"))
                object.conversionPrice = options.json && !isFinite(message.conversionPrice) ? String(message.conversionPrice) : message.conversionPrice;
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                object.priceRecoveryRatio = options.json && !isFinite(message.priceRecoveryRatio) ? String(message.priceRecoveryRatio) : message.priceRecoveryRatio;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                object.upperStrikePrice = options.json && !isFinite(message.upperStrikePrice) ? String(message.upperStrikePrice) : message.upperStrikePrice;
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                object.lowerStrikePrice = options.json && !isFinite(message.lowerStrikePrice) ? String(message.lowerStrikePrice) : message.lowerStrikePrice;
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                object.inLinePriceStatus = options.enums === String ? $root.common.PriceType[message.inLinePriceStatus] === undefined ? message.inLinePriceStatus : $root.common.PriceType[message.inLinePriceStatus] : message.inLinePriceStatus;
            if (message.issuerCode != null && message.hasOwnProperty("issuerCode"))
                object.issuerCode = message.issuerCode;
            return object;
        };

        /**
         * Converts this WarrantSnapshotExData to JSON.
         * @function toJSON
         * @memberof common.WarrantSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WarrantSnapshotExData
         * @function getTypeUrl
         * @memberof common.WarrantSnapshotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WarrantSnapshotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.WarrantSnapshotExData";
        };

        return WarrantSnapshotExData;
    })();

    common.IndexSnapshotExData = (function() {

        /**
         * Properties of an IndexSnapshotExData.
         * @memberof common
         * @interface IIndexSnapshotExData
         * @property {number} raiseCount IndexSnapshotExData raiseCount
         * @property {number} fallCount IndexSnapshotExData fallCount
         * @property {number} equalCount IndexSnapshotExData equalCount
         */

        /**
         * Constructs a new IndexSnapshotExData.
         * @memberof common
         * @classdesc Represents an IndexSnapshotExData.
         * @implements IIndexSnapshotExData
         * @constructor
         * @param {common.IIndexSnapshotExData=} [properties] Properties to set
         */
        function IndexSnapshotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IndexSnapshotExData raiseCount.
         * @member {number} raiseCount
         * @memberof common.IndexSnapshotExData
         * @instance
         */
        IndexSnapshotExData.prototype.raiseCount = 0;

        /**
         * IndexSnapshotExData fallCount.
         * @member {number} fallCount
         * @memberof common.IndexSnapshotExData
         * @instance
         */
        IndexSnapshotExData.prototype.fallCount = 0;

        /**
         * IndexSnapshotExData equalCount.
         * @member {number} equalCount
         * @memberof common.IndexSnapshotExData
         * @instance
         */
        IndexSnapshotExData.prototype.equalCount = 0;

        /**
         * Creates a new IndexSnapshotExData instance using the specified properties.
         * @function create
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {common.IIndexSnapshotExData=} [properties] Properties to set
         * @returns {common.IndexSnapshotExData} IndexSnapshotExData instance
         */
        IndexSnapshotExData.create = function create(properties) {
            return new IndexSnapshotExData(properties);
        };

        /**
         * Encodes the specified IndexSnapshotExData message. Does not implicitly {@link common.IndexSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {common.IIndexSnapshotExData} message IndexSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.raiseCount);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fallCount);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.equalCount);
            return writer;
        };

        /**
         * Encodes the specified IndexSnapshotExData message, length delimited. Does not implicitly {@link common.IndexSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {common.IIndexSnapshotExData} message IndexSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IndexSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.IndexSnapshotExData} IndexSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.IndexSnapshotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.raiseCount = reader.int32();
                        break;
                    }
                case 2: {
                        message.fallCount = reader.int32();
                        break;
                    }
                case 3: {
                        message.equalCount = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("raiseCount"))
                throw $util.ProtocolError("missing required 'raiseCount'", { instance: message });
            if (!message.hasOwnProperty("fallCount"))
                throw $util.ProtocolError("missing required 'fallCount'", { instance: message });
            if (!message.hasOwnProperty("equalCount"))
                throw $util.ProtocolError("missing required 'equalCount'", { instance: message });
            return message;
        };

        /**
         * Decodes an IndexSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.IndexSnapshotExData} IndexSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IndexSnapshotExData message.
         * @function verify
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IndexSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.raiseCount))
                return "raiseCount: integer expected";
            if (!$util.isInteger(message.fallCount))
                return "fallCount: integer expected";
            if (!$util.isInteger(message.equalCount))
                return "equalCount: integer expected";
            return null;
        };

        /**
         * Creates an IndexSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.IndexSnapshotExData} IndexSnapshotExData
         */
        IndexSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.IndexSnapshotExData)
                return object;
            let message = new $root.common.IndexSnapshotExData();
            if (object.raiseCount != null)
                message.raiseCount = object.raiseCount | 0;
            if (object.fallCount != null)
                message.fallCount = object.fallCount | 0;
            if (object.equalCount != null)
                message.equalCount = object.equalCount | 0;
            return message;
        };

        /**
         * Creates a plain object from an IndexSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {common.IndexSnapshotExData} message IndexSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IndexSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.raiseCount = 0;
                object.fallCount = 0;
                object.equalCount = 0;
            }
            if (message.raiseCount != null && message.hasOwnProperty("raiseCount"))
                object.raiseCount = message.raiseCount;
            if (message.fallCount != null && message.hasOwnProperty("fallCount"))
                object.fallCount = message.fallCount;
            if (message.equalCount != null && message.hasOwnProperty("equalCount"))
                object.equalCount = message.equalCount;
            return object;
        };

        /**
         * Converts this IndexSnapshotExData to JSON.
         * @function toJSON
         * @memberof common.IndexSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IndexSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for IndexSnapshotExData
         * @function getTypeUrl
         * @memberof common.IndexSnapshotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        IndexSnapshotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.IndexSnapshotExData";
        };

        return IndexSnapshotExData;
    })();

    common.PlateSnapshotExData = (function() {

        /**
         * Properties of a PlateSnapshotExData.
         * @memberof common
         * @interface IPlateSnapshotExData
         * @property {number} raiseCount PlateSnapshotExData raiseCount
         * @property {number} fallCount PlateSnapshotExData fallCount
         * @property {number} equalCount PlateSnapshotExData equalCount
         */

        /**
         * Constructs a new PlateSnapshotExData.
         * @memberof common
         * @classdesc Represents a PlateSnapshotExData.
         * @implements IPlateSnapshotExData
         * @constructor
         * @param {common.IPlateSnapshotExData=} [properties] Properties to set
         */
        function PlateSnapshotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlateSnapshotExData raiseCount.
         * @member {number} raiseCount
         * @memberof common.PlateSnapshotExData
         * @instance
         */
        PlateSnapshotExData.prototype.raiseCount = 0;

        /**
         * PlateSnapshotExData fallCount.
         * @member {number} fallCount
         * @memberof common.PlateSnapshotExData
         * @instance
         */
        PlateSnapshotExData.prototype.fallCount = 0;

        /**
         * PlateSnapshotExData equalCount.
         * @member {number} equalCount
         * @memberof common.PlateSnapshotExData
         * @instance
         */
        PlateSnapshotExData.prototype.equalCount = 0;

        /**
         * Creates a new PlateSnapshotExData instance using the specified properties.
         * @function create
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {common.IPlateSnapshotExData=} [properties] Properties to set
         * @returns {common.PlateSnapshotExData} PlateSnapshotExData instance
         */
        PlateSnapshotExData.create = function create(properties) {
            return new PlateSnapshotExData(properties);
        };

        /**
         * Encodes the specified PlateSnapshotExData message. Does not implicitly {@link common.PlateSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {common.IPlateSnapshotExData} message PlateSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.raiseCount);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fallCount);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.equalCount);
            return writer;
        };

        /**
         * Encodes the specified PlateSnapshotExData message, length delimited. Does not implicitly {@link common.PlateSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {common.IPlateSnapshotExData} message PlateSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlateSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.PlateSnapshotExData} PlateSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.PlateSnapshotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.raiseCount = reader.int32();
                        break;
                    }
                case 2: {
                        message.fallCount = reader.int32();
                        break;
                    }
                case 3: {
                        message.equalCount = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("raiseCount"))
                throw $util.ProtocolError("missing required 'raiseCount'", { instance: message });
            if (!message.hasOwnProperty("fallCount"))
                throw $util.ProtocolError("missing required 'fallCount'", { instance: message });
            if (!message.hasOwnProperty("equalCount"))
                throw $util.ProtocolError("missing required 'equalCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a PlateSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.PlateSnapshotExData} PlateSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlateSnapshotExData message.
         * @function verify
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlateSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.raiseCount))
                return "raiseCount: integer expected";
            if (!$util.isInteger(message.fallCount))
                return "fallCount: integer expected";
            if (!$util.isInteger(message.equalCount))
                return "equalCount: integer expected";
            return null;
        };

        /**
         * Creates a PlateSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.PlateSnapshotExData} PlateSnapshotExData
         */
        PlateSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.PlateSnapshotExData)
                return object;
            let message = new $root.common.PlateSnapshotExData();
            if (object.raiseCount != null)
                message.raiseCount = object.raiseCount | 0;
            if (object.fallCount != null)
                message.fallCount = object.fallCount | 0;
            if (object.equalCount != null)
                message.equalCount = object.equalCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlateSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {common.PlateSnapshotExData} message PlateSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlateSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.raiseCount = 0;
                object.fallCount = 0;
                object.equalCount = 0;
            }
            if (message.raiseCount != null && message.hasOwnProperty("raiseCount"))
                object.raiseCount = message.raiseCount;
            if (message.fallCount != null && message.hasOwnProperty("fallCount"))
                object.fallCount = message.fallCount;
            if (message.equalCount != null && message.hasOwnProperty("equalCount"))
                object.equalCount = message.equalCount;
            return object;
        };

        /**
         * Converts this PlateSnapshotExData to JSON.
         * @function toJSON
         * @memberof common.PlateSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlateSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PlateSnapshotExData
         * @function getTypeUrl
         * @memberof common.PlateSnapshotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PlateSnapshotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.PlateSnapshotExData";
        };

        return PlateSnapshotExData;
    })();

    common.FutureSnapshotExData = (function() {

        /**
         * Properties of a FutureSnapshotExData.
         * @memberof common
         * @interface IFutureSnapshotExData
         * @property {number} lastSettlePrice FutureSnapshotExData lastSettlePrice
         * @property {number} position FutureSnapshotExData position
         * @property {number} positionChange FutureSnapshotExData positionChange
         * @property {string} lastTradeTime FutureSnapshotExData lastTradeTime
         * @property {number|null} [lastTradeTimestamp] FutureSnapshotExData lastTradeTimestamp
         * @property {boolean} isMainContract FutureSnapshotExData isMainContract
         */

        /**
         * Constructs a new FutureSnapshotExData.
         * @memberof common
         * @classdesc Represents a FutureSnapshotExData.
         * @implements IFutureSnapshotExData
         * @constructor
         * @param {common.IFutureSnapshotExData=} [properties] Properties to set
         */
        function FutureSnapshotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FutureSnapshotExData lastSettlePrice.
         * @member {number} lastSettlePrice
         * @memberof common.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.lastSettlePrice = 0;

        /**
         * FutureSnapshotExData position.
         * @member {number} position
         * @memberof common.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.position = 0;

        /**
         * FutureSnapshotExData positionChange.
         * @member {number} positionChange
         * @memberof common.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.positionChange = 0;

        /**
         * FutureSnapshotExData lastTradeTime.
         * @member {string} lastTradeTime
         * @memberof common.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.lastTradeTime = "";

        /**
         * FutureSnapshotExData lastTradeTimestamp.
         * @member {number} lastTradeTimestamp
         * @memberof common.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.lastTradeTimestamp = 0;

        /**
         * FutureSnapshotExData isMainContract.
         * @member {boolean} isMainContract
         * @memberof common.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.isMainContract = false;

        /**
         * Creates a new FutureSnapshotExData instance using the specified properties.
         * @function create
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {common.IFutureSnapshotExData=} [properties] Properties to set
         * @returns {common.FutureSnapshotExData} FutureSnapshotExData instance
         */
        FutureSnapshotExData.create = function create(properties) {
            return new FutureSnapshotExData(properties);
        };

        /**
         * Encodes the specified FutureSnapshotExData message. Does not implicitly {@link common.FutureSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {common.IFutureSnapshotExData} message FutureSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.lastSettlePrice);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.position);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.positionChange);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.lastTradeTime);
            if (message.lastTradeTimestamp != null && Object.hasOwnProperty.call(message, "lastTradeTimestamp"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lastTradeTimestamp);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isMainContract);
            return writer;
        };

        /**
         * Encodes the specified FutureSnapshotExData message, length delimited. Does not implicitly {@link common.FutureSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {common.IFutureSnapshotExData} message FutureSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FutureSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.FutureSnapshotExData} FutureSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.FutureSnapshotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lastSettlePrice = reader.double();
                        break;
                    }
                case 2: {
                        message.position = reader.int32();
                        break;
                    }
                case 3: {
                        message.positionChange = reader.int32();
                        break;
                    }
                case 4: {
                        message.lastTradeTime = reader.string();
                        break;
                    }
                case 5: {
                        message.lastTradeTimestamp = reader.double();
                        break;
                    }
                case 6: {
                        message.isMainContract = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastSettlePrice"))
                throw $util.ProtocolError("missing required 'lastSettlePrice'", { instance: message });
            if (!message.hasOwnProperty("position"))
                throw $util.ProtocolError("missing required 'position'", { instance: message });
            if (!message.hasOwnProperty("positionChange"))
                throw $util.ProtocolError("missing required 'positionChange'", { instance: message });
            if (!message.hasOwnProperty("lastTradeTime"))
                throw $util.ProtocolError("missing required 'lastTradeTime'", { instance: message });
            if (!message.hasOwnProperty("isMainContract"))
                throw $util.ProtocolError("missing required 'isMainContract'", { instance: message });
            return message;
        };

        /**
         * Decodes a FutureSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.FutureSnapshotExData} FutureSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FutureSnapshotExData message.
         * @function verify
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FutureSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.lastSettlePrice !== "number")
                return "lastSettlePrice: number expected";
            if (!$util.isInteger(message.position))
                return "position: integer expected";
            if (!$util.isInteger(message.positionChange))
                return "positionChange: integer expected";
            if (!$util.isString(message.lastTradeTime))
                return "lastTradeTime: string expected";
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                if (typeof message.lastTradeTimestamp !== "number")
                    return "lastTradeTimestamp: number expected";
            if (typeof message.isMainContract !== "boolean")
                return "isMainContract: boolean expected";
            return null;
        };

        /**
         * Creates a FutureSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.FutureSnapshotExData} FutureSnapshotExData
         */
        FutureSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.FutureSnapshotExData)
                return object;
            let message = new $root.common.FutureSnapshotExData();
            if (object.lastSettlePrice != null)
                message.lastSettlePrice = Number(object.lastSettlePrice);
            if (object.position != null)
                message.position = object.position | 0;
            if (object.positionChange != null)
                message.positionChange = object.positionChange | 0;
            if (object.lastTradeTime != null)
                message.lastTradeTime = String(object.lastTradeTime);
            if (object.lastTradeTimestamp != null)
                message.lastTradeTimestamp = Number(object.lastTradeTimestamp);
            if (object.isMainContract != null)
                message.isMainContract = Boolean(object.isMainContract);
            return message;
        };

        /**
         * Creates a plain object from a FutureSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {common.FutureSnapshotExData} message FutureSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FutureSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.lastSettlePrice = 0;
                object.position = 0;
                object.positionChange = 0;
                object.lastTradeTime = "";
                object.lastTradeTimestamp = 0;
                object.isMainContract = false;
            }
            if (message.lastSettlePrice != null && message.hasOwnProperty("lastSettlePrice"))
                object.lastSettlePrice = options.json && !isFinite(message.lastSettlePrice) ? String(message.lastSettlePrice) : message.lastSettlePrice;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.positionChange != null && message.hasOwnProperty("positionChange"))
                object.positionChange = message.positionChange;
            if (message.lastTradeTime != null && message.hasOwnProperty("lastTradeTime"))
                object.lastTradeTime = message.lastTradeTime;
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                object.lastTradeTimestamp = options.json && !isFinite(message.lastTradeTimestamp) ? String(message.lastTradeTimestamp) : message.lastTradeTimestamp;
            if (message.isMainContract != null && message.hasOwnProperty("isMainContract"))
                object.isMainContract = message.isMainContract;
            return object;
        };

        /**
         * Converts this FutureSnapshotExData to JSON.
         * @function toJSON
         * @memberof common.FutureSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FutureSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FutureSnapshotExData
         * @function getTypeUrl
         * @memberof common.FutureSnapshotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FutureSnapshotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.FutureSnapshotExData";
        };

        return FutureSnapshotExData;
    })();

    common.TrustSnapshotExData = (function() {

        /**
         * Properties of a TrustSnapshotExData.
         * @memberof common
         * @interface ITrustSnapshotExData
         * @property {number} dividendYield TrustSnapshotExData dividendYield
         * @property {number} aum TrustSnapshotExData aum
         * @property {number|Long} outstandingUnits TrustSnapshotExData outstandingUnits
         * @property {number} netAssetValue TrustSnapshotExData netAssetValue
         * @property {number} premium TrustSnapshotExData premium
         * @property {common.AssetClass} assetClass TrustSnapshotExData assetClass
         */

        /**
         * Constructs a new TrustSnapshotExData.
         * @memberof common
         * @classdesc Represents a TrustSnapshotExData.
         * @implements ITrustSnapshotExData
         * @constructor
         * @param {common.ITrustSnapshotExData=} [properties] Properties to set
         */
        function TrustSnapshotExData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrustSnapshotExData dividendYield.
         * @member {number} dividendYield
         * @memberof common.TrustSnapshotExData
         * @instance
         */
        TrustSnapshotExData.prototype.dividendYield = 0;

        /**
         * TrustSnapshotExData aum.
         * @member {number} aum
         * @memberof common.TrustSnapshotExData
         * @instance
         */
        TrustSnapshotExData.prototype.aum = 0;

        /**
         * TrustSnapshotExData outstandingUnits.
         * @member {number|Long} outstandingUnits
         * @memberof common.TrustSnapshotExData
         * @instance
         */
        TrustSnapshotExData.prototype.outstandingUnits = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TrustSnapshotExData netAssetValue.
         * @member {number} netAssetValue
         * @memberof common.TrustSnapshotExData
         * @instance
         */
        TrustSnapshotExData.prototype.netAssetValue = 0;

        /**
         * TrustSnapshotExData premium.
         * @member {number} premium
         * @memberof common.TrustSnapshotExData
         * @instance
         */
        TrustSnapshotExData.prototype.premium = 0;

        /**
         * TrustSnapshotExData assetClass.
         * @member {common.AssetClass} assetClass
         * @memberof common.TrustSnapshotExData
         * @instance
         */
        TrustSnapshotExData.prototype.assetClass = 0;

        /**
         * Creates a new TrustSnapshotExData instance using the specified properties.
         * @function create
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {common.ITrustSnapshotExData=} [properties] Properties to set
         * @returns {common.TrustSnapshotExData} TrustSnapshotExData instance
         */
        TrustSnapshotExData.create = function create(properties) {
            return new TrustSnapshotExData(properties);
        };

        /**
         * Encodes the specified TrustSnapshotExData message. Does not implicitly {@link common.TrustSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {common.ITrustSnapshotExData} message TrustSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrustSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.dividendYield);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.aum);
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.outstandingUnits);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.netAssetValue);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.premium);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.assetClass);
            return writer;
        };

        /**
         * Encodes the specified TrustSnapshotExData message, length delimited. Does not implicitly {@link common.TrustSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {common.ITrustSnapshotExData} message TrustSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrustSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrustSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.TrustSnapshotExData} TrustSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrustSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.TrustSnapshotExData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dividendYield = reader.double();
                        break;
                    }
                case 2: {
                        message.aum = reader.double();
                        break;
                    }
                case 3: {
                        message.outstandingUnits = reader.int64();
                        break;
                    }
                case 4: {
                        message.netAssetValue = reader.double();
                        break;
                    }
                case 5: {
                        message.premium = reader.double();
                        break;
                    }
                case 6: {
                        message.assetClass = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("dividendYield"))
                throw $util.ProtocolError("missing required 'dividendYield'", { instance: message });
            if (!message.hasOwnProperty("aum"))
                throw $util.ProtocolError("missing required 'aum'", { instance: message });
            if (!message.hasOwnProperty("outstandingUnits"))
                throw $util.ProtocolError("missing required 'outstandingUnits'", { instance: message });
            if (!message.hasOwnProperty("netAssetValue"))
                throw $util.ProtocolError("missing required 'netAssetValue'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("assetClass"))
                throw $util.ProtocolError("missing required 'assetClass'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrustSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.TrustSnapshotExData} TrustSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrustSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrustSnapshotExData message.
         * @function verify
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrustSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.dividendYield !== "number")
                return "dividendYield: number expected";
            if (typeof message.aum !== "number")
                return "aum: number expected";
            if (!$util.isInteger(message.outstandingUnits) && !(message.outstandingUnits && $util.isInteger(message.outstandingUnits.low) && $util.isInteger(message.outstandingUnits.high)))
                return "outstandingUnits: integer|Long expected";
            if (typeof message.netAssetValue !== "number")
                return "netAssetValue: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            switch (message.assetClass) {
            default:
                return "assetClass: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                break;
            }
            return null;
        };

        /**
         * Creates a TrustSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.TrustSnapshotExData} TrustSnapshotExData
         */
        TrustSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.common.TrustSnapshotExData)
                return object;
            let message = new $root.common.TrustSnapshotExData();
            if (object.dividendYield != null)
                message.dividendYield = Number(object.dividendYield);
            if (object.aum != null)
                message.aum = Number(object.aum);
            if (object.outstandingUnits != null)
                if ($util.Long)
                    (message.outstandingUnits = $util.Long.fromValue(object.outstandingUnits)).unsigned = false;
                else if (typeof object.outstandingUnits === "string")
                    message.outstandingUnits = parseInt(object.outstandingUnits, 10);
                else if (typeof object.outstandingUnits === "number")
                    message.outstandingUnits = object.outstandingUnits;
                else if (typeof object.outstandingUnits === "object")
                    message.outstandingUnits = new $util.LongBits(object.outstandingUnits.low >>> 0, object.outstandingUnits.high >>> 0).toNumber();
            if (object.netAssetValue != null)
                message.netAssetValue = Number(object.netAssetValue);
            if (object.premium != null)
                message.premium = Number(object.premium);
            switch (object.assetClass) {
            default:
                if (typeof object.assetClass === "number") {
                    message.assetClass = object.assetClass;
                    break;
                }
                break;
            case "AssetClass_Unknow":
            case 0:
                message.assetClass = 0;
                break;
            case "AssetClass_Stock":
            case 1:
                message.assetClass = 1;
                break;
            case "AssetClass_Bond":
            case 2:
                message.assetClass = 2;
                break;
            case "AssetClass_Commodity":
            case 3:
                message.assetClass = 3;
                break;
            case "AssetClass_CurrencyMarket":
            case 4:
                message.assetClass = 4;
                break;
            case "AssetClass_Future":
            case 5:
                message.assetClass = 5;
                break;
            case "AssetClass_Swap":
            case 6:
                message.assetClass = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TrustSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {common.TrustSnapshotExData} message TrustSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrustSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.dividendYield = 0;
                object.aum = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.outstandingUnits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.outstandingUnits = options.longs === String ? "0" : 0;
                object.netAssetValue = 0;
                object.premium = 0;
                object.assetClass = options.enums === String ? "AssetClass_Unknow" : 0;
            }
            if (message.dividendYield != null && message.hasOwnProperty("dividendYield"))
                object.dividendYield = options.json && !isFinite(message.dividendYield) ? String(message.dividendYield) : message.dividendYield;
            if (message.aum != null && message.hasOwnProperty("aum"))
                object.aum = options.json && !isFinite(message.aum) ? String(message.aum) : message.aum;
            if (message.outstandingUnits != null && message.hasOwnProperty("outstandingUnits"))
                if (typeof message.outstandingUnits === "number")
                    object.outstandingUnits = options.longs === String ? String(message.outstandingUnits) : message.outstandingUnits;
                else
                    object.outstandingUnits = options.longs === String ? $util.Long.prototype.toString.call(message.outstandingUnits) : options.longs === Number ? new $util.LongBits(message.outstandingUnits.low >>> 0, message.outstandingUnits.high >>> 0).toNumber() : message.outstandingUnits;
            if (message.netAssetValue != null && message.hasOwnProperty("netAssetValue"))
                object.netAssetValue = options.json && !isFinite(message.netAssetValue) ? String(message.netAssetValue) : message.netAssetValue;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.assetClass != null && message.hasOwnProperty("assetClass"))
                object.assetClass = options.enums === String ? $root.common.AssetClass[message.assetClass] === undefined ? message.assetClass : $root.common.AssetClass[message.assetClass] : message.assetClass;
            return object;
        };

        /**
         * Converts this TrustSnapshotExData to JSON.
         * @function toJSON
         * @memberof common.TrustSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrustSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrustSnapshotExData
         * @function getTypeUrl
         * @memberof common.TrustSnapshotExData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrustSnapshotExData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.TrustSnapshotExData";
        };

        return TrustSnapshotExData;
    })();

    /**
     * AssetClass enum.
     * @name common.AssetClass
     * @enum {number}
     * @property {number} AssetClass_Unknow=0 AssetClass_Unknow value
     * @property {number} AssetClass_Stock=1 AssetClass_Stock value
     * @property {number} AssetClass_Bond=2 AssetClass_Bond value
     * @property {number} AssetClass_Commodity=3 AssetClass_Commodity value
     * @property {number} AssetClass_CurrencyMarket=4 AssetClass_CurrencyMarket value
     * @property {number} AssetClass_Future=5 AssetClass_Future value
     * @property {number} AssetClass_Swap=6 AssetClass_Swap value
     */
    common.AssetClass = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AssetClass_Unknow"] = 0;
        values[valuesById[1] = "AssetClass_Stock"] = 1;
        values[valuesById[2] = "AssetClass_Bond"] = 2;
        values[valuesById[3] = "AssetClass_Commodity"] = 3;
        values[valuesById[4] = "AssetClass_CurrencyMarket"] = 4;
        values[valuesById[5] = "AssetClass_Future"] = 5;
        values[valuesById[6] = "AssetClass_Swap"] = 6;
        return values;
    })();

    /**
     * SecurityType enum.
     * @name common.SecurityType
     * @enum {number}
     * @property {number} SecurityType_Unknown=0 SecurityType_Unknown value
     * @property {number} SecurityType_Bond=1 SecurityType_Bond value
     * @property {number} SecurityType_Bwrt=2 SecurityType_Bwrt value
     * @property {number} SecurityType_Eqty=3 SecurityType_Eqty value
     * @property {number} SecurityType_Trust=4 SecurityType_Trust value
     * @property {number} SecurityType_Warrant=5 SecurityType_Warrant value
     * @property {number} SecurityType_Index=6 SecurityType_Index value
     * @property {number} SecurityType_Plate=7 SecurityType_Plate value
     * @property {number} SecurityType_Drvt=8 SecurityType_Drvt value
     * @property {number} SecurityType_PlateSet=9 SecurityType_PlateSet value
     * @property {number} SecurityType_Future=10 SecurityType_Future value
     */
    common.SecurityType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SecurityType_Unknown"] = 0;
        values[valuesById[1] = "SecurityType_Bond"] = 1;
        values[valuesById[2] = "SecurityType_Bwrt"] = 2;
        values[valuesById[3] = "SecurityType_Eqty"] = 3;
        values[valuesById[4] = "SecurityType_Trust"] = 4;
        values[valuesById[5] = "SecurityType_Warrant"] = 5;
        values[valuesById[6] = "SecurityType_Index"] = 6;
        values[valuesById[7] = "SecurityType_Plate"] = 7;
        values[valuesById[8] = "SecurityType_Drvt"] = 8;
        values[valuesById[9] = "SecurityType_PlateSet"] = 9;
        values[valuesById[10] = "SecurityType_Future"] = 10;
        return values;
    })();

    /**
     * OptionType enum.
     * @name common.OptionType
     * @enum {number}
     * @property {number} OptionType_Unknown=0 OptionType_Unknown value
     * @property {number} OptionType_Call=1 OptionType_Call value
     * @property {number} OptionType_Put=2 OptionType_Put value
     */
    common.OptionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OptionType_Unknown"] = 0;
        values[valuesById[1] = "OptionType_Call"] = 1;
        values[valuesById[2] = "OptionType_Put"] = 2;
        return values;
    })();

    /**
     * IndexOptionType enum.
     * @name common.IndexOptionType
     * @enum {number}
     * @property {number} IndexOptionType_Unknown=0 IndexOptionType_Unknown value
     * @property {number} IndexOptionType_Normal=1 IndexOptionType_Normal value
     * @property {number} IndexOptionType_Small=2 IndexOptionType_Small value
     */
    common.IndexOptionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IndexOptionType_Unknown"] = 0;
        values[valuesById[1] = "IndexOptionType_Normal"] = 1;
        values[valuesById[2] = "IndexOptionType_Small"] = 2;
        return values;
    })();

    /**
     * OptionAreaType enum.
     * @name common.OptionAreaType
     * @enum {number}
     * @property {number} OptionAreaType_Unknown=0 OptionAreaType_Unknown value
     * @property {number} OptionAreaType_American=1 OptionAreaType_American value
     * @property {number} OptionAreaType_European=2 OptionAreaType_European value
     * @property {number} OptionAreaType_Bermuda=3 OptionAreaType_Bermuda value
     */
    common.OptionAreaType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OptionAreaType_Unknown"] = 0;
        values[valuesById[1] = "OptionAreaType_American"] = 1;
        values[valuesById[2] = "OptionAreaType_European"] = 2;
        values[valuesById[3] = "OptionAreaType_Bermuda"] = 3;
        return values;
    })();

    /**
     * PlateSetType enum.
     * @name common.PlateSetType
     * @enum {number}
     * @property {number} PlateSetType_All=0 PlateSetType_All value
     * @property {number} PlateSetType_Industry=1 PlateSetType_Industry value
     * @property {number} PlateSetType_Region=2 PlateSetType_Region value
     * @property {number} PlateSetType_Concept=3 PlateSetType_Concept value
     * @property {number} PlateSetType_Other=4 PlateSetType_Other value
     */
    common.PlateSetType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PlateSetType_All"] = 0;
        values[valuesById[1] = "PlateSetType_Industry"] = 1;
        values[valuesById[2] = "PlateSetType_Region"] = 2;
        values[valuesById[3] = "PlateSetType_Concept"] = 3;
        values[valuesById[4] = "PlateSetType_Other"] = 4;
        return values;
    })();

    /**
     * WarrantType enum.
     * @name common.WarrantType
     * @enum {number}
     * @property {number} WarrantType_Unknown=0 WarrantType_Unknown value
     * @property {number} WarrantType_Buy=1 WarrantType_Buy value
     * @property {number} WarrantType_Sell=2 WarrantType_Sell value
     * @property {number} WarrantType_Bull=3 WarrantType_Bull value
     * @property {number} WarrantType_Bear=4 WarrantType_Bear value
     * @property {number} WarrantType_InLine=5 WarrantType_InLine value
     */
    common.WarrantType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WarrantType_Unknown"] = 0;
        values[valuesById[1] = "WarrantType_Buy"] = 1;
        values[valuesById[2] = "WarrantType_Sell"] = 2;
        values[valuesById[3] = "WarrantType_Bull"] = 3;
        values[valuesById[4] = "WarrantType_Bear"] = 4;
        values[valuesById[5] = "WarrantType_InLine"] = 5;
        return values;
    })();

    /**
     * PriceType enum.
     * @name common.PriceType
     * @enum {number}
     * @property {number} PriceType_Unknow=0 PriceType_Unknow value
     * @property {number} PriceType_Outside=1 PriceType_Outside value
     * @property {number} PriceType_WithIn=2 PriceType_WithIn value
     */
    common.PriceType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PriceType_Unknow"] = 0;
        values[valuesById[1] = "PriceType_Outside"] = 1;
        values[valuesById[2] = "PriceType_WithIn"] = 2;
        return values;
    })();

    /**
     * WarrantStatus enum.
     * @name common.WarrantStatus
     * @enum {number}
     * @property {number} WarrantStatus_Unknow=0 WarrantStatus_Unknow value
     * @property {number} WarrantStatus_Normal=1 WarrantStatus_Normal value
     * @property {number} WarrantStatus_Suspend=2 WarrantStatus_Suspend value
     * @property {number} WarrantStatus_StopTrade=3 WarrantStatus_StopTrade value
     * @property {number} WarrantStatus_PendingListing=4 WarrantStatus_PendingListing value
     */
    common.WarrantStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WarrantStatus_Unknow"] = 0;
        values[valuesById[1] = "WarrantStatus_Normal"] = 1;
        values[valuesById[2] = "WarrantStatus_Suspend"] = 2;
        values[valuesById[3] = "WarrantStatus_StopTrade"] = 3;
        values[valuesById[4] = "WarrantStatus_PendingListing"] = 4;
        return values;
    })();

    common.TrdFilterConditions = (function() {

        /**
         * Properties of a TrdFilterConditions.
         * @memberof common
         * @interface ITrdFilterConditions
         * @property {Array.<string>|null} [codeList] TrdFilterConditions codeList
         * @property {Array.<number|Long>|null} [idList] TrdFilterConditions idList
         * @property {string|null} [beginTime] TrdFilterConditions beginTime
         * @property {string|null} [endTime] TrdFilterConditions endTime
         * @property {Array.<string>|null} [orderIDExList] TrdFilterConditions orderIDExList
         * @property {number|null} [filterMarket] TrdFilterConditions filterMarket
         */

        /**
         * Constructs a new TrdFilterConditions.
         * @memberof common
         * @classdesc 持仓过滤条件
         * @implements ITrdFilterConditions
         * @constructor
         * @param {common.ITrdFilterConditions=} [properties] Properties to set
         */
        function TrdFilterConditions(properties) {
            this.codeList = [];
            this.idList = [];
            this.orderIDExList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdFilterConditions codeList.
         * @member {Array.<string>} codeList
         * @memberof common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.codeList = $util.emptyArray;

        /**
         * TrdFilterConditions idList.
         * @member {Array.<number|Long>} idList
         * @memberof common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.idList = $util.emptyArray;

        /**
         * TrdFilterConditions beginTime.
         * @member {string} beginTime
         * @memberof common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.beginTime = "";

        /**
         * TrdFilterConditions endTime.
         * @member {string} endTime
         * @memberof common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.endTime = "";

        /**
         * TrdFilterConditions orderIDExList.
         * @member {Array.<string>} orderIDExList
         * @memberof common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.orderIDExList = $util.emptyArray;

        /**
         * TrdFilterConditions filterMarket.
         * @member {number} filterMarket
         * @memberof common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.filterMarket = 0;

        /**
         * Creates a new TrdFilterConditions instance using the specified properties.
         * @function create
         * @memberof common.TrdFilterConditions
         * @static
         * @param {common.ITrdFilterConditions=} [properties] Properties to set
         * @returns {common.TrdFilterConditions} TrdFilterConditions instance
         */
        TrdFilterConditions.create = function create(properties) {
            return new TrdFilterConditions(properties);
        };

        /**
         * Encodes the specified TrdFilterConditions message. Does not implicitly {@link common.TrdFilterConditions.verify|verify} messages.
         * @function encode
         * @memberof common.TrdFilterConditions
         * @static
         * @param {common.ITrdFilterConditions} message TrdFilterConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdFilterConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.codeList != null && message.codeList.length)
                for (let i = 0; i < message.codeList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.codeList[i]);
            if (message.idList != null && message.idList.length)
                for (let i = 0; i < message.idList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.idList[i]);
            if (message.beginTime != null && Object.hasOwnProperty.call(message, "beginTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.beginTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            if (message.orderIDExList != null && message.orderIDExList.length)
                for (let i = 0; i < message.orderIDExList.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.orderIDExList[i]);
            if (message.filterMarket != null && Object.hasOwnProperty.call(message, "filterMarket"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.filterMarket);
            return writer;
        };

        /**
         * Encodes the specified TrdFilterConditions message, length delimited. Does not implicitly {@link common.TrdFilterConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.TrdFilterConditions
         * @static
         * @param {common.ITrdFilterConditions} message TrdFilterConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdFilterConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdFilterConditions message from the specified reader or buffer.
         * @function decode
         * @memberof common.TrdFilterConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.TrdFilterConditions} TrdFilterConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdFilterConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.TrdFilterConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.codeList && message.codeList.length))
                            message.codeList = [];
                        message.codeList.push(reader.string());
                        break;
                    }
                case 2: {
                        if (!(message.idList && message.idList.length))
                            message.idList = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.idList.push(reader.uint64());
                        } else
                            message.idList.push(reader.uint64());
                        break;
                    }
                case 3: {
                        message.beginTime = reader.string();
                        break;
                    }
                case 4: {
                        message.endTime = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.orderIDExList && message.orderIDExList.length))
                            message.orderIDExList = [];
                        message.orderIDExList.push(reader.string());
                        break;
                    }
                case 6: {
                        message.filterMarket = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrdFilterConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.TrdFilterConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.TrdFilterConditions} TrdFilterConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdFilterConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdFilterConditions message.
         * @function verify
         * @memberof common.TrdFilterConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdFilterConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.codeList != null && message.hasOwnProperty("codeList")) {
                if (!Array.isArray(message.codeList))
                    return "codeList: array expected";
                for (let i = 0; i < message.codeList.length; ++i)
                    if (!$util.isString(message.codeList[i]))
                        return "codeList: string[] expected";
            }
            if (message.idList != null && message.hasOwnProperty("idList")) {
                if (!Array.isArray(message.idList))
                    return "idList: array expected";
                for (let i = 0; i < message.idList.length; ++i)
                    if (!$util.isInteger(message.idList[i]) && !(message.idList[i] && $util.isInteger(message.idList[i].low) && $util.isInteger(message.idList[i].high)))
                        return "idList: integer|Long[] expected";
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isString(message.beginTime))
                    return "beginTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            if (message.orderIDExList != null && message.hasOwnProperty("orderIDExList")) {
                if (!Array.isArray(message.orderIDExList))
                    return "orderIDExList: array expected";
                for (let i = 0; i < message.orderIDExList.length; ++i)
                    if (!$util.isString(message.orderIDExList[i]))
                        return "orderIDExList: string[] expected";
            }
            if (message.filterMarket != null && message.hasOwnProperty("filterMarket"))
                if (!$util.isInteger(message.filterMarket))
                    return "filterMarket: integer expected";
            return null;
        };

        /**
         * Creates a TrdFilterConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.TrdFilterConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.TrdFilterConditions} TrdFilterConditions
         */
        TrdFilterConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.common.TrdFilterConditions)
                return object;
            let message = new $root.common.TrdFilterConditions();
            if (object.codeList) {
                if (!Array.isArray(object.codeList))
                    throw TypeError(".common.TrdFilterConditions.codeList: array expected");
                message.codeList = [];
                for (let i = 0; i < object.codeList.length; ++i)
                    message.codeList[i] = String(object.codeList[i]);
            }
            if (object.idList) {
                if (!Array.isArray(object.idList))
                    throw TypeError(".common.TrdFilterConditions.idList: array expected");
                message.idList = [];
                for (let i = 0; i < object.idList.length; ++i)
                    if ($util.Long)
                        (message.idList[i] = $util.Long.fromValue(object.idList[i])).unsigned = true;
                    else if (typeof object.idList[i] === "string")
                        message.idList[i] = parseInt(object.idList[i], 10);
                    else if (typeof object.idList[i] === "number")
                        message.idList[i] = object.idList[i];
                    else if (typeof object.idList[i] === "object")
                        message.idList[i] = new $util.LongBits(object.idList[i].low >>> 0, object.idList[i].high >>> 0).toNumber(true);
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            if (object.orderIDExList) {
                if (!Array.isArray(object.orderIDExList))
                    throw TypeError(".common.TrdFilterConditions.orderIDExList: array expected");
                message.orderIDExList = [];
                for (let i = 0; i < object.orderIDExList.length; ++i)
                    message.orderIDExList[i] = String(object.orderIDExList[i]);
            }
            if (object.filterMarket != null)
                message.filterMarket = object.filterMarket | 0;
            return message;
        };

        /**
         * Creates a plain object from a TrdFilterConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.TrdFilterConditions
         * @static
         * @param {common.TrdFilterConditions} message TrdFilterConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdFilterConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.codeList = [];
                object.idList = [];
                object.orderIDExList = [];
            }
            if (options.defaults) {
                object.beginTime = "";
                object.endTime = "";
                object.filterMarket = 0;
            }
            if (message.codeList && message.codeList.length) {
                object.codeList = [];
                for (let j = 0; j < message.codeList.length; ++j)
                    object.codeList[j] = message.codeList[j];
            }
            if (message.idList && message.idList.length) {
                object.idList = [];
                for (let j = 0; j < message.idList.length; ++j)
                    if (typeof message.idList[j] === "number")
                        object.idList[j] = options.longs === String ? String(message.idList[j]) : message.idList[j];
                    else
                        object.idList[j] = options.longs === String ? $util.Long.prototype.toString.call(message.idList[j]) : options.longs === Number ? new $util.LongBits(message.idList[j].low >>> 0, message.idList[j].high >>> 0).toNumber(true) : message.idList[j];
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.orderIDExList && message.orderIDExList.length) {
                object.orderIDExList = [];
                for (let j = 0; j < message.orderIDExList.length; ++j)
                    object.orderIDExList[j] = message.orderIDExList[j];
            }
            if (message.filterMarket != null && message.hasOwnProperty("filterMarket"))
                object.filterMarket = message.filterMarket;
            return object;
        };

        /**
         * Converts this TrdFilterConditions to JSON.
         * @function toJSON
         * @memberof common.TrdFilterConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdFilterConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrdFilterConditions
         * @function getTypeUrl
         * @memberof common.TrdFilterConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrdFilterConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.TrdFilterConditions";
        };

        return TrdFilterConditions;
    })();

    common.MaxTrdQtys = (function() {

        /**
         * Properties of a MaxTrdQtys.
         * @memberof common
         * @interface IMaxTrdQtys
         * @property {number} maxCashBuy MaxTrdQtys maxCashBuy
         * @property {number|null} [maxCashAndMarginBuy] MaxTrdQtys maxCashAndMarginBuy
         * @property {number} maxPositionSell MaxTrdQtys maxPositionSell
         * @property {number|null} [maxSellShort] MaxTrdQtys maxSellShort
         * @property {number|null} [maxBuyBack] MaxTrdQtys maxBuyBack
         * @property {number|null} [longRequiredIM] MaxTrdQtys longRequiredIM
         * @property {number|null} [shortRequiredIM] MaxTrdQtys shortRequiredIM
         */

        /**
         * Constructs a new MaxTrdQtys.
         * @memberof common
         * @classdesc 最大可交易数量
         * @implements IMaxTrdQtys
         * @constructor
         * @param {common.IMaxTrdQtys=} [properties] Properties to set
         */
        function MaxTrdQtys(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaxTrdQtys maxCashBuy.
         * @member {number} maxCashBuy
         * @memberof common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxCashBuy = 0;

        /**
         * MaxTrdQtys maxCashAndMarginBuy.
         * @member {number} maxCashAndMarginBuy
         * @memberof common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxCashAndMarginBuy = 0;

        /**
         * MaxTrdQtys maxPositionSell.
         * @member {number} maxPositionSell
         * @memberof common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxPositionSell = 0;

        /**
         * MaxTrdQtys maxSellShort.
         * @member {number} maxSellShort
         * @memberof common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxSellShort = 0;

        /**
         * MaxTrdQtys maxBuyBack.
         * @member {number} maxBuyBack
         * @memberof common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxBuyBack = 0;

        /**
         * MaxTrdQtys longRequiredIM.
         * @member {number} longRequiredIM
         * @memberof common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.longRequiredIM = 0;

        /**
         * MaxTrdQtys shortRequiredIM.
         * @member {number} shortRequiredIM
         * @memberof common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.shortRequiredIM = 0;

        /**
         * Creates a new MaxTrdQtys instance using the specified properties.
         * @function create
         * @memberof common.MaxTrdQtys
         * @static
         * @param {common.IMaxTrdQtys=} [properties] Properties to set
         * @returns {common.MaxTrdQtys} MaxTrdQtys instance
         */
        MaxTrdQtys.create = function create(properties) {
            return new MaxTrdQtys(properties);
        };

        /**
         * Encodes the specified MaxTrdQtys message. Does not implicitly {@link common.MaxTrdQtys.verify|verify} messages.
         * @function encode
         * @memberof common.MaxTrdQtys
         * @static
         * @param {common.IMaxTrdQtys} message MaxTrdQtys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaxTrdQtys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.maxCashBuy);
            if (message.maxCashAndMarginBuy != null && Object.hasOwnProperty.call(message, "maxCashAndMarginBuy"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.maxCashAndMarginBuy);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.maxPositionSell);
            if (message.maxSellShort != null && Object.hasOwnProperty.call(message, "maxSellShort"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.maxSellShort);
            if (message.maxBuyBack != null && Object.hasOwnProperty.call(message, "maxBuyBack"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.maxBuyBack);
            if (message.longRequiredIM != null && Object.hasOwnProperty.call(message, "longRequiredIM"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.longRequiredIM);
            if (message.shortRequiredIM != null && Object.hasOwnProperty.call(message, "shortRequiredIM"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.shortRequiredIM);
            return writer;
        };

        /**
         * Encodes the specified MaxTrdQtys message, length delimited. Does not implicitly {@link common.MaxTrdQtys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.MaxTrdQtys
         * @static
         * @param {common.IMaxTrdQtys} message MaxTrdQtys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaxTrdQtys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaxTrdQtys message from the specified reader or buffer.
         * @function decode
         * @memberof common.MaxTrdQtys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.MaxTrdQtys} MaxTrdQtys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaxTrdQtys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MaxTrdQtys();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.maxCashBuy = reader.double();
                        break;
                    }
                case 2: {
                        message.maxCashAndMarginBuy = reader.double();
                        break;
                    }
                case 3: {
                        message.maxPositionSell = reader.double();
                        break;
                    }
                case 4: {
                        message.maxSellShort = reader.double();
                        break;
                    }
                case 5: {
                        message.maxBuyBack = reader.double();
                        break;
                    }
                case 6: {
                        message.longRequiredIM = reader.double();
                        break;
                    }
                case 7: {
                        message.shortRequiredIM = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("maxCashBuy"))
                throw $util.ProtocolError("missing required 'maxCashBuy'", { instance: message });
            if (!message.hasOwnProperty("maxPositionSell"))
                throw $util.ProtocolError("missing required 'maxPositionSell'", { instance: message });
            return message;
        };

        /**
         * Decodes a MaxTrdQtys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.MaxTrdQtys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.MaxTrdQtys} MaxTrdQtys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaxTrdQtys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaxTrdQtys message.
         * @function verify
         * @memberof common.MaxTrdQtys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaxTrdQtys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.maxCashBuy !== "number")
                return "maxCashBuy: number expected";
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                if (typeof message.maxCashAndMarginBuy !== "number")
                    return "maxCashAndMarginBuy: number expected";
            if (typeof message.maxPositionSell !== "number")
                return "maxPositionSell: number expected";
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                if (typeof message.maxSellShort !== "number")
                    return "maxSellShort: number expected";
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                if (typeof message.maxBuyBack !== "number")
                    return "maxBuyBack: number expected";
            if (message.longRequiredIM != null && message.hasOwnProperty("longRequiredIM"))
                if (typeof message.longRequiredIM !== "number")
                    return "longRequiredIM: number expected";
            if (message.shortRequiredIM != null && message.hasOwnProperty("shortRequiredIM"))
                if (typeof message.shortRequiredIM !== "number")
                    return "shortRequiredIM: number expected";
            return null;
        };

        /**
         * Creates a MaxTrdQtys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.MaxTrdQtys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.MaxTrdQtys} MaxTrdQtys
         */
        MaxTrdQtys.fromObject = function fromObject(object) {
            if (object instanceof $root.common.MaxTrdQtys)
                return object;
            let message = new $root.common.MaxTrdQtys();
            if (object.maxCashBuy != null)
                message.maxCashBuy = Number(object.maxCashBuy);
            if (object.maxCashAndMarginBuy != null)
                message.maxCashAndMarginBuy = Number(object.maxCashAndMarginBuy);
            if (object.maxPositionSell != null)
                message.maxPositionSell = Number(object.maxPositionSell);
            if (object.maxSellShort != null)
                message.maxSellShort = Number(object.maxSellShort);
            if (object.maxBuyBack != null)
                message.maxBuyBack = Number(object.maxBuyBack);
            if (object.longRequiredIM != null)
                message.longRequiredIM = Number(object.longRequiredIM);
            if (object.shortRequiredIM != null)
                message.shortRequiredIM = Number(object.shortRequiredIM);
            return message;
        };

        /**
         * Creates a plain object from a MaxTrdQtys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.MaxTrdQtys
         * @static
         * @param {common.MaxTrdQtys} message MaxTrdQtys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaxTrdQtys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.maxCashBuy = 0;
                object.maxCashAndMarginBuy = 0;
                object.maxPositionSell = 0;
                object.maxSellShort = 0;
                object.maxBuyBack = 0;
                object.longRequiredIM = 0;
                object.shortRequiredIM = 0;
            }
            if (message.maxCashBuy != null && message.hasOwnProperty("maxCashBuy"))
                object.maxCashBuy = options.json && !isFinite(message.maxCashBuy) ? String(message.maxCashBuy) : message.maxCashBuy;
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                object.maxCashAndMarginBuy = options.json && !isFinite(message.maxCashAndMarginBuy) ? String(message.maxCashAndMarginBuy) : message.maxCashAndMarginBuy;
            if (message.maxPositionSell != null && message.hasOwnProperty("maxPositionSell"))
                object.maxPositionSell = options.json && !isFinite(message.maxPositionSell) ? String(message.maxPositionSell) : message.maxPositionSell;
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                object.maxSellShort = options.json && !isFinite(message.maxSellShort) ? String(message.maxSellShort) : message.maxSellShort;
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                object.maxBuyBack = options.json && !isFinite(message.maxBuyBack) ? String(message.maxBuyBack) : message.maxBuyBack;
            if (message.longRequiredIM != null && message.hasOwnProperty("longRequiredIM"))
                object.longRequiredIM = options.json && !isFinite(message.longRequiredIM) ? String(message.longRequiredIM) : message.longRequiredIM;
            if (message.shortRequiredIM != null && message.hasOwnProperty("shortRequiredIM"))
                object.shortRequiredIM = options.json && !isFinite(message.shortRequiredIM) ? String(message.shortRequiredIM) : message.shortRequiredIM;
            return object;
        };

        /**
         * Converts this MaxTrdQtys to JSON.
         * @function toJSON
         * @memberof common.MaxTrdQtys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaxTrdQtys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MaxTrdQtys
         * @function getTypeUrl
         * @memberof common.MaxTrdQtys
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MaxTrdQtys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.MaxTrdQtys";
        };

        return MaxTrdQtys;
    })();

    common.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof common
         * @interface IPosition
         * @property {number|Long} positionID Position positionID
         * @property {common.PositionSide} positionSide Position positionSide
         * @property {string} code Position code
         * @property {string} name Position name
         * @property {number} qty Position qty
         * @property {number} canSellQty Position canSellQty
         * @property {number} price Position price
         * @property {number|null} [costPrice] Position costPrice
         * @property {number} val Position val
         * @property {number} plVal Position plVal
         * @property {number|null} [plRatio] Position plRatio
         * @property {common.TrdSecMarket|null} [secMarket] Position secMarket
         * @property {number|null} [tdPlVal] Position tdPlVal
         * @property {number|null} [tdTrdVal] Position tdTrdVal
         * @property {number|null} [tdBuyVal] Position tdBuyVal
         * @property {number|null} [tdBuyQty] Position tdBuyQty
         * @property {number|null} [tdSellVal] Position tdSellVal
         * @property {number|null} [tdSellQty] Position tdSellQty
         * @property {number|null} [unrealizedPL] Position unrealizedPL
         * @property {number|null} [realizedPL] Position realizedPL
         * @property {common.Currency|null} [currency] Position currency
         * @property {common.TrdMarket|null} [trdMarket] Position trdMarket
         */

        /**
         * Constructs a new Position.
         * @memberof common
         * @classdesc 持仓
         * @implements IPosition
         * @constructor
         * @param {common.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position positionID.
         * @member {number|Long} positionID
         * @memberof common.Position
         * @instance
         */
        Position.prototype.positionID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Position positionSide.
         * @member {common.PositionSide} positionSide
         * @memberof common.Position
         * @instance
         */
        Position.prototype.positionSide = 0;

        /**
         * Position code.
         * @member {string} code
         * @memberof common.Position
         * @instance
         */
        Position.prototype.code = "";

        /**
         * Position name.
         * @member {string} name
         * @memberof common.Position
         * @instance
         */
        Position.prototype.name = "";

        /**
         * Position qty.
         * @member {number} qty
         * @memberof common.Position
         * @instance
         */
        Position.prototype.qty = 0;

        /**
         * Position canSellQty.
         * @member {number} canSellQty
         * @memberof common.Position
         * @instance
         */
        Position.prototype.canSellQty = 0;

        /**
         * Position price.
         * @member {number} price
         * @memberof common.Position
         * @instance
         */
        Position.prototype.price = 0;

        /**
         * Position costPrice.
         * @member {number} costPrice
         * @memberof common.Position
         * @instance
         */
        Position.prototype.costPrice = 0;

        /**
         * Position val.
         * @member {number} val
         * @memberof common.Position
         * @instance
         */
        Position.prototype.val = 0;

        /**
         * Position plVal.
         * @member {number} plVal
         * @memberof common.Position
         * @instance
         */
        Position.prototype.plVal = 0;

        /**
         * Position plRatio.
         * @member {number} plRatio
         * @memberof common.Position
         * @instance
         */
        Position.prototype.plRatio = 0;

        /**
         * Position secMarket.
         * @member {common.TrdSecMarket} secMarket
         * @memberof common.Position
         * @instance
         */
        Position.prototype.secMarket = 0;

        /**
         * Position tdPlVal.
         * @member {number} tdPlVal
         * @memberof common.Position
         * @instance
         */
        Position.prototype.tdPlVal = 0;

        /**
         * Position tdTrdVal.
         * @member {number} tdTrdVal
         * @memberof common.Position
         * @instance
         */
        Position.prototype.tdTrdVal = 0;

        /**
         * Position tdBuyVal.
         * @member {number} tdBuyVal
         * @memberof common.Position
         * @instance
         */
        Position.prototype.tdBuyVal = 0;

        /**
         * Position tdBuyQty.
         * @member {number} tdBuyQty
         * @memberof common.Position
         * @instance
         */
        Position.prototype.tdBuyQty = 0;

        /**
         * Position tdSellVal.
         * @member {number} tdSellVal
         * @memberof common.Position
         * @instance
         */
        Position.prototype.tdSellVal = 0;

        /**
         * Position tdSellQty.
         * @member {number} tdSellQty
         * @memberof common.Position
         * @instance
         */
        Position.prototype.tdSellQty = 0;

        /**
         * Position unrealizedPL.
         * @member {number} unrealizedPL
         * @memberof common.Position
         * @instance
         */
        Position.prototype.unrealizedPL = 0;

        /**
         * Position realizedPL.
         * @member {number} realizedPL
         * @memberof common.Position
         * @instance
         */
        Position.prototype.realizedPL = 0;

        /**
         * Position currency.
         * @member {common.Currency} currency
         * @memberof common.Position
         * @instance
         */
        Position.prototype.currency = 0;

        /**
         * Position trdMarket.
         * @member {common.TrdMarket} trdMarket
         * @memberof common.Position
         * @instance
         */
        Position.prototype.trdMarket = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof common.Position
         * @static
         * @param {common.IPosition=} [properties] Properties to set
         * @returns {common.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link common.Position.verify|verify} messages.
         * @function encode
         * @memberof common.Position
         * @static
         * @param {common.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.positionID);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.positionSide);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.qty);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.canSellQty);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.price);
            if (message.costPrice != null && Object.hasOwnProperty.call(message, "costPrice"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.costPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.val);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.plVal);
            if (message.plRatio != null && Object.hasOwnProperty.call(message, "plRatio"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.plRatio);
            if (message.secMarket != null && Object.hasOwnProperty.call(message, "secMarket"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.secMarket);
            if (message.tdPlVal != null && Object.hasOwnProperty.call(message, "tdPlVal"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.tdPlVal);
            if (message.tdTrdVal != null && Object.hasOwnProperty.call(message, "tdTrdVal"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.tdTrdVal);
            if (message.tdBuyVal != null && Object.hasOwnProperty.call(message, "tdBuyVal"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.tdBuyVal);
            if (message.tdBuyQty != null && Object.hasOwnProperty.call(message, "tdBuyQty"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.tdBuyQty);
            if (message.tdSellVal != null && Object.hasOwnProperty.call(message, "tdSellVal"))
                writer.uint32(/* id 25, wireType 1 =*/201).double(message.tdSellVal);
            if (message.tdSellQty != null && Object.hasOwnProperty.call(message, "tdSellQty"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.tdSellQty);
            if (message.unrealizedPL != null && Object.hasOwnProperty.call(message, "unrealizedPL"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.unrealizedPL);
            if (message.realizedPL != null && Object.hasOwnProperty.call(message, "realizedPL"))
                writer.uint32(/* id 29, wireType 1 =*/233).double(message.realizedPL);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 30, wireType 0 =*/240).int32(message.currency);
            if (message.trdMarket != null && Object.hasOwnProperty.call(message, "trdMarket"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.trdMarket);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link common.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof common.Position
         * @static
         * @param {common.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof common.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {common.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Position();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.positionID = reader.uint64();
                        break;
                    }
                case 2: {
                        message.positionSide = reader.int32();
                        break;
                    }
                case 3: {
                        message.code = reader.string();
                        break;
                    }
                case 4: {
                        message.name = reader.string();
                        break;
                    }
                case 5: {
                        message.qty = reader.double();
                        break;
                    }
                case 6: {
                        message.canSellQty = reader.double();
                        break;
                    }
                case 7: {
                        message.price = reader.double();
                        break;
                    }
                case 8: {
                        message.costPrice = reader.double();
                        break;
                    }
                case 9: {
                        message.val = reader.double();
                        break;
                    }
                case 10: {
                        message.plVal = reader.double();
                        break;
                    }
                case 11: {
                        message.plRatio = reader.double();
                        break;
                    }
                case 12: {
                        message.secMarket = reader.int32();
                        break;
                    }
                case 21: {
                        message.tdPlVal = reader.double();
                        break;
                    }
                case 22: {
                        message.tdTrdVal = reader.double();
                        break;
                    }
                case 23: {
                        message.tdBuyVal = reader.double();
                        break;
                    }
                case 24: {
                        message.tdBuyQty = reader.double();
                        break;
                    }
                case 25: {
                        message.tdSellVal = reader.double();
                        break;
                    }
                case 26: {
                        message.tdSellQty = reader.double();
                        break;
                    }
                case 28: {
                        message.unrealizedPL = reader.double();
                        break;
                    }
                case 29: {
                        message.realizedPL = reader.double();
                        break;
                    }
                case 30: {
                        message.currency = reader.int32();
                        break;
                    }
                case 31: {
                        message.trdMarket = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("positionID"))
                throw $util.ProtocolError("missing required 'positionID'", { instance: message });
            if (!message.hasOwnProperty("positionSide"))
                throw $util.ProtocolError("missing required 'positionSide'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("canSellQty"))
                throw $util.ProtocolError("missing required 'canSellQty'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("val"))
                throw $util.ProtocolError("missing required 'val'", { instance: message });
            if (!message.hasOwnProperty("plVal"))
                throw $util.ProtocolError("missing required 'plVal'", { instance: message });
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof common.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {common.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof common.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.positionID) && !(message.positionID && $util.isInteger(message.positionID.low) && $util.isInteger(message.positionID.high)))
                return "positionID: integer|Long expected";
            switch (message.positionSide) {
            default:
                return "positionSide: enum value expected";
            case 0:
            case -1:
            case 1:
                break;
            }
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (typeof message.canSellQty !== "number")
                return "canSellQty: number expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                if (typeof message.costPrice !== "number")
                    return "costPrice: number expected";
            if (typeof message.val !== "number")
                return "val: number expected";
            if (typeof message.plVal !== "number")
                return "plVal: number expected";
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                if (typeof message.plRatio !== "number")
                    return "plRatio: number expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                switch (message.secMarket) {
                default:
                    return "secMarket: enum value expected";
                case 0:
                case 1:
                case 2:
                case 31:
                case 32:
                case 41:
                case 51:
                case 61:
                case 71:
                case 81:
                case 91:
                    break;
                }
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                if (typeof message.tdPlVal !== "number")
                    return "tdPlVal: number expected";
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                if (typeof message.tdTrdVal !== "number")
                    return "tdTrdVal: number expected";
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                if (typeof message.tdBuyVal !== "number")
                    return "tdBuyVal: number expected";
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                if (typeof message.tdBuyQty !== "number")
                    return "tdBuyQty: number expected";
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                if (typeof message.tdSellVal !== "number")
                    return "tdSellVal: number expected";
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                if (typeof message.tdSellQty !== "number")
                    return "tdSellQty: number expected";
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                if (typeof message.unrealizedPL !== "number")
                    return "unrealizedPL: number expected";
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                if (typeof message.realizedPL !== "number")
                    return "realizedPL: number expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                switch (message.currency) {
                default:
                    return "currency: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                switch (message.trdMarket) {
                default:
                    return "trdMarket: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 8:
                case 10:
                case 11:
                case 12:
                case 13:
                case 15:
                case 111:
                case 112:
                case 113:
                case 123:
                    break;
                }
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof common.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {common.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.common.Position)
                return object;
            let message = new $root.common.Position();
            if (object.positionID != null)
                if ($util.Long)
                    (message.positionID = $util.Long.fromValue(object.positionID)).unsigned = true;
                else if (typeof object.positionID === "string")
                    message.positionID = parseInt(object.positionID, 10);
                else if (typeof object.positionID === "number")
                    message.positionID = object.positionID;
                else if (typeof object.positionID === "object")
                    message.positionID = new $util.LongBits(object.positionID.low >>> 0, object.positionID.high >>> 0).toNumber(true);
            switch (object.positionSide) {
            default:
                if (typeof object.positionSide === "number") {
                    message.positionSide = object.positionSide;
                    break;
                }
                break;
            case "PositionSide_Long":
            case 0:
                message.positionSide = 0;
                break;
            case "PositionSide_Unknown":
            case -1:
                message.positionSide = -1;
                break;
            case "PositionSide_Short":
            case 1:
                message.positionSide = 1;
                break;
            }
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.canSellQty != null)
                message.canSellQty = Number(object.canSellQty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.costPrice != null)
                message.costPrice = Number(object.costPrice);
            if (object.val != null)
                message.val = Number(object.val);
            if (object.plVal != null)
                message.plVal = Number(object.plVal);
            if (object.plRatio != null)
                message.plRatio = Number(object.plRatio);
            switch (object.secMarket) {
            default:
                if (typeof object.secMarket === "number") {
                    message.secMarket = object.secMarket;
                    break;
                }
                break;
            case "TrdSecMarket_Unknown":
            case 0:
                message.secMarket = 0;
                break;
            case "TrdSecMarket_HK":
            case 1:
                message.secMarket = 1;
                break;
            case "TrdSecMarket_US":
            case 2:
                message.secMarket = 2;
                break;
            case "TrdSecMarket_CN_SH":
            case 31:
                message.secMarket = 31;
                break;
            case "TrdSecMarket_CN_SZ":
            case 32:
                message.secMarket = 32;
                break;
            case "TrdSecMarket_SG":
            case 41:
                message.secMarket = 41;
                break;
            case "TrdSecMarket_JP":
            case 51:
                message.secMarket = 51;
                break;
            case "TrdSecMarket_AU":
            case 61:
                message.secMarket = 61;
                break;
            case "TrdSecMarket_MY":
            case 71:
                message.secMarket = 71;
                break;
            case "TrdSecMarket_CA":
            case 81:
                message.secMarket = 81;
                break;
            case "TrdSecMarket_FX":
            case 91:
                message.secMarket = 91;
                break;
            }
            if (object.tdPlVal != null)
                message.tdPlVal = Number(object.tdPlVal);
            if (object.tdTrdVal != null)
                message.tdTrdVal = Number(object.tdTrdVal);
            if (object.tdBuyVal != null)
                message.tdBuyVal = Number(object.tdBuyVal);
            if (object.tdBuyQty != null)
                message.tdBuyQty = Number(object.tdBuyQty);
            if (object.tdSellVal != null)
                message.tdSellVal = Number(object.tdSellVal);
            if (object.tdSellQty != null)
                message.tdSellQty = Number(object.tdSellQty);
            if (object.unrealizedPL != null)
                message.unrealizedPL = Number(object.unrealizedPL);
            if (object.realizedPL != null)
                message.realizedPL = Number(object.realizedPL);
            switch (object.currency) {
            default:
                if (typeof object.currency === "number") {
                    message.currency = object.currency;
                    break;
                }
                break;
            case "Currency_Unknown":
            case 0:
                message.currency = 0;
                break;
            case "Currency_HKD":
            case 1:
                message.currency = 1;
                break;
            case "Currency_USD":
            case 2:
                message.currency = 2;
                break;
            case "Currency_CNH":
            case 3:
                message.currency = 3;
                break;
            case "Currency_JPY":
            case 4:
                message.currency = 4;
                break;
            case "Currency_SGD":
            case 5:
                message.currency = 5;
                break;
            case "Currency_AUD":
            case 6:
                message.currency = 6;
                break;
            case "Currency_CAD":
            case 7:
                message.currency = 7;
                break;
            case "Currency_MYR":
            case 8:
                message.currency = 8;
                break;
            }
            switch (object.trdMarket) {
            default:
                if (typeof object.trdMarket === "number") {
                    message.trdMarket = object.trdMarket;
                    break;
                }
                break;
            case "TrdMarket_Unknown":
            case 0:
                message.trdMarket = 0;
                break;
            case "TrdMarket_HK":
            case 1:
                message.trdMarket = 1;
                break;
            case "TrdMarket_US":
            case 2:
                message.trdMarket = 2;
                break;
            case "TrdMarket_CN":
            case 3:
                message.trdMarket = 3;
                break;
            case "TrdMarket_HKCC":
            case 4:
                message.trdMarket = 4;
                break;
            case "TrdMarket_Futures":
            case 5:
                message.trdMarket = 5;
                break;
            case "TrdMarket_SG":
            case 6:
                message.trdMarket = 6;
                break;
            case "TrdMarket_AU":
            case 8:
                message.trdMarket = 8;
                break;
            case "TrdMarket_Futures_Simulate_HK":
            case 10:
                message.trdMarket = 10;
                break;
            case "TrdMarket_Futures_Simulate_US":
            case 11:
                message.trdMarket = 11;
                break;
            case "TrdMarket_Futures_Simulate_SG":
            case 12:
                message.trdMarket = 12;
                break;
            case "TrdMarket_Futures_Simulate_JP":
            case 13:
                message.trdMarket = 13;
                break;
            case "TrdMarket_JP":
            case 15:
                message.trdMarket = 15;
                break;
            case "TrdMarket_MY":
            case 111:
                message.trdMarket = 111;
                break;
            case "TrdMarket_CA":
            case 112:
                message.trdMarket = 112;
                break;
            case "TrdMarket_HK_Fund":
            case 113:
                message.trdMarket = 113;
                break;
            case "TrdMarket_US_Fund":
            case 123:
                message.trdMarket = 123;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof common.Position
         * @static
         * @param {common.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.positionID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.positionID = options.longs === String ? "0" : 0;
                object.positionSide = options.enums === String ? "PositionSide_Long" : 0;
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.canSellQty = 0;
                object.price = 0;
                object.costPrice = 0;
                object.val = 0;
                object.plVal = 0;
                object.plRatio = 0;
                object.secMarket = options.enums === String ? "TrdSecMarket_Unknown" : 0;
                object.tdPlVal = 0;
                object.tdTrdVal = 0;
                object.tdBuyVal = 0;
                object.tdBuyQty = 0;
                object.tdSellVal = 0;
                object.tdSellQty = 0;
                object.unrealizedPL = 0;
                object.realizedPL = 0;
                object.currency = options.enums === String ? "Currency_Unknown" : 0;
                object.trdMarket = options.enums === String ? "TrdMarket_Unknown" : 0;
            }
            if (message.positionID != null && message.hasOwnProperty("positionID"))
                if (typeof message.positionID === "number")
                    object.positionID = options.longs === String ? String(message.positionID) : message.positionID;
                else
                    object.positionID = options.longs === String ? $util.Long.prototype.toString.call(message.positionID) : options.longs === Number ? new $util.LongBits(message.positionID.low >>> 0, message.positionID.high >>> 0).toNumber(true) : message.positionID;
            if (message.positionSide != null && message.hasOwnProperty("positionSide"))
                object.positionSide = options.enums === String ? $root.common.PositionSide[message.positionSide] === undefined ? message.positionSide : $root.common.PositionSide[message.positionSide] : message.positionSide;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.canSellQty != null && message.hasOwnProperty("canSellQty"))
                object.canSellQty = options.json && !isFinite(message.canSellQty) ? String(message.canSellQty) : message.canSellQty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                object.costPrice = options.json && !isFinite(message.costPrice) ? String(message.costPrice) : message.costPrice;
            if (message.val != null && message.hasOwnProperty("val"))
                object.val = options.json && !isFinite(message.val) ? String(message.val) : message.val;
            if (message.plVal != null && message.hasOwnProperty("plVal"))
                object.plVal = options.json && !isFinite(message.plVal) ? String(message.plVal) : message.plVal;
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                object.plRatio = options.json && !isFinite(message.plRatio) ? String(message.plRatio) : message.plRatio;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = options.enums === String ? $root.common.TrdSecMarket[message.secMarket] === undefined ? message.secMarket : $root.common.TrdSecMarket[message.secMarket] : message.secMarket;
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                object.tdPlVal = options.json && !isFinite(message.tdPlVal) ? String(message.tdPlVal) : message.tdPlVal;
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                object.tdTrdVal = options.json && !isFinite(message.tdTrdVal) ? String(message.tdTrdVal) : message.tdTrdVal;
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                object.tdBuyVal = options.json && !isFinite(message.tdBuyVal) ? String(message.tdBuyVal) : message.tdBuyVal;
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                object.tdBuyQty = options.json && !isFinite(message.tdBuyQty) ? String(message.tdBuyQty) : message.tdBuyQty;
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                object.tdSellVal = options.json && !isFinite(message.tdSellVal) ? String(message.tdSellVal) : message.tdSellVal;
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                object.tdSellQty = options.json && !isFinite(message.tdSellQty) ? String(message.tdSellQty) : message.tdSellQty;
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                object.unrealizedPL = options.json && !isFinite(message.unrealizedPL) ? String(message.unrealizedPL) : message.unrealizedPL;
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                object.realizedPL = options.json && !isFinite(message.realizedPL) ? String(message.realizedPL) : message.realizedPL;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = options.enums === String ? $root.common.Currency[message.currency] === undefined ? message.currency : $root.common.Currency[message.currency] : message.currency;
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                object.trdMarket = options.enums === String ? $root.common.TrdMarket[message.trdMarket] === undefined ? message.trdMarket : $root.common.TrdMarket[message.trdMarket] : message.trdMarket;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof common.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof common.Position
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/common.Position";
        };

        return Position;
    })();

    /**
     * PositionSide enum.
     * @name common.PositionSide
     * @enum {number}
     * @property {number} PositionSide_Long=0 PositionSide_Long value
     * @property {number} PositionSide_Unknown=-1 PositionSide_Unknown value
     * @property {number} PositionSide_Short=1 PositionSide_Short value
     */
    common.PositionSide = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PositionSide_Long"] = 0;
        values[valuesById[-1] = "PositionSide_Unknown"] = -1;
        values[valuesById[1] = "PositionSide_Short"] = 1;
        return values;
    })();

    return common;
})();

export const notify = $root.notify = (() => {

    /**
     * Namespace notify.
     * @exports notify
     * @namespace
     */
    const notify = {};

    notify.Event = (function() {

        /**
         * Properties of an Event.
         * @memberof notify
         * @interface IEvent
         * @property {number} retType Event retType
         * @property {string|null} [retMsg] Event retMsg
         * @property {number|null} [errCode] Event errCode
         * @property {notify.Event.IS2C|null} [s2c] Event s2c
         */

        /**
         * Constructs a new Event.
         * @memberof notify
         * @classdesc 事件通知
         * @implements IEvent
         * @constructor
         * @param {notify.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event retType.
         * @member {number} retType
         * @memberof notify.Event
         * @instance
         */
        Event.prototype.retType = 0;

        /**
         * Event retMsg.
         * @member {string} retMsg
         * @memberof notify.Event
         * @instance
         */
        Event.prototype.retMsg = "";

        /**
         * Event errCode.
         * @member {number} errCode
         * @memberof notify.Event
         * @instance
         */
        Event.prototype.errCode = 0;

        /**
         * Event s2c.
         * @member {notify.Event.IS2C|null|undefined} s2c
         * @memberof notify.Event
         * @instance
         */
        Event.prototype.s2c = null;

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof notify.Event
         * @static
         * @param {notify.IEvent=} [properties] Properties to set
         * @returns {notify.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link notify.Event.verify|verify} messages.
         * @function encode
         * @memberof notify.Event
         * @static
         * @param {notify.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.notify.Event.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link notify.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof notify.Event
         * @static
         * @param {notify.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof notify.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {notify.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.Event();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.notify.Event.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof notify.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {notify.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof notify.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.notify.Event.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof notify.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {notify.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.notify.Event)
                return object;
            let message = new $root.notify.Event();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".notify.Event.s2c: object expected");
                message.s2c = $root.notify.Event.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof notify.Event
         * @static
         * @param {notify.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.notify.Event.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof notify.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Event
         * @function getTypeUrl
         * @memberof notify.Event
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Event.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/notify.Event";
        };

        Event.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof notify.Event
             * @interface IS2C
             * @property {common.NotifyType} type S2C type
             * @property {common.IGtwEvent|null} [event] S2C event
             * @property {common.IProgramStatus|null} [programStatus] S2C programStatus
             * @property {common.IConnectStatus|null} [connectStatus] S2C connectStatus
             * @property {common.IQotRight|null} [qotRight] S2C qotRight
             * @property {common.IAPILevel|null} [apiLevel] S2C apiLevel
             * @property {common.IAPIQuota|null} [apiQuota] S2C apiQuota
             */

            /**
             * Constructs a new S2C.
             * @memberof notify.Event
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {notify.Event.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C type.
             * @member {common.NotifyType} type
             * @memberof notify.Event.S2C
             * @instance
             */
            S2C.prototype.type = 0;

            /**
             * S2C event.
             * @member {common.IGtwEvent|null|undefined} event
             * @memberof notify.Event.S2C
             * @instance
             */
            S2C.prototype.event = null;

            /**
             * S2C programStatus.
             * @member {common.IProgramStatus|null|undefined} programStatus
             * @memberof notify.Event.S2C
             * @instance
             */
            S2C.prototype.programStatus = null;

            /**
             * S2C connectStatus.
             * @member {common.IConnectStatus|null|undefined} connectStatus
             * @memberof notify.Event.S2C
             * @instance
             */
            S2C.prototype.connectStatus = null;

            /**
             * S2C qotRight.
             * @member {common.IQotRight|null|undefined} qotRight
             * @memberof notify.Event.S2C
             * @instance
             */
            S2C.prototype.qotRight = null;

            /**
             * S2C apiLevel.
             * @member {common.IAPILevel|null|undefined} apiLevel
             * @memberof notify.Event.S2C
             * @instance
             */
            S2C.prototype.apiLevel = null;

            /**
             * S2C apiQuota.
             * @member {common.IAPIQuota|null|undefined} apiQuota
             * @memberof notify.Event.S2C
             * @instance
             */
            S2C.prototype.apiQuota = null;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof notify.Event.S2C
             * @static
             * @param {notify.Event.IS2C=} [properties] Properties to set
             * @returns {notify.Event.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link notify.Event.S2C.verify|verify} messages.
             * @function encode
             * @memberof notify.Event.S2C
             * @static
             * @param {notify.Event.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.common.GtwEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.programStatus != null && Object.hasOwnProperty.call(message, "programStatus"))
                    $root.common.ProgramStatus.encode(message.programStatus, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.connectStatus != null && Object.hasOwnProperty.call(message, "connectStatus"))
                    $root.common.ConnectStatus.encode(message.connectStatus, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.qotRight != null && Object.hasOwnProperty.call(message, "qotRight"))
                    $root.common.QotRight.encode(message.qotRight, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.apiLevel != null && Object.hasOwnProperty.call(message, "apiLevel"))
                    $root.common.APILevel.encode(message.apiLevel, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.apiQuota != null && Object.hasOwnProperty.call(message, "apiQuota"))
                    $root.common.APIQuota.encode(message.apiQuota, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link notify.Event.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof notify.Event.S2C
             * @static
             * @param {notify.Event.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof notify.Event.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {notify.Event.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.Event.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.event = $root.common.GtwEvent.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.programStatus = $root.common.ProgramStatus.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.connectStatus = $root.common.ConnectStatus.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.qotRight = $root.common.QotRight.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.apiLevel = $root.common.APILevel.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.apiQuota = $root.common.APIQuota.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof notify.Event.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {notify.Event.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof notify.Event.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
                if (message.event != null && message.hasOwnProperty("event")) {
                    let error = $root.common.GtwEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                if (message.programStatus != null && message.hasOwnProperty("programStatus")) {
                    let error = $root.common.ProgramStatus.verify(message.programStatus);
                    if (error)
                        return "programStatus." + error;
                }
                if (message.connectStatus != null && message.hasOwnProperty("connectStatus")) {
                    let error = $root.common.ConnectStatus.verify(message.connectStatus);
                    if (error)
                        return "connectStatus." + error;
                }
                if (message.qotRight != null && message.hasOwnProperty("qotRight")) {
                    let error = $root.common.QotRight.verify(message.qotRight);
                    if (error)
                        return "qotRight." + error;
                }
                if (message.apiLevel != null && message.hasOwnProperty("apiLevel")) {
                    let error = $root.common.APILevel.verify(message.apiLevel);
                    if (error)
                        return "apiLevel." + error;
                }
                if (message.apiQuota != null && message.hasOwnProperty("apiQuota")) {
                    let error = $root.common.APIQuota.verify(message.apiQuota);
                    if (error)
                        return "apiQuota." + error;
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof notify.Event.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {notify.Event.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.notify.Event.S2C)
                    return object;
                let message = new $root.notify.Event.S2C();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "NotifyType_None":
                case 0:
                    message.type = 0;
                    break;
                case "NotifyType_GtwEvent":
                case 1:
                    message.type = 1;
                    break;
                case "NotifyType_ProgramStatus":
                case 2:
                    message.type = 2;
                    break;
                case "NotifyType_ConnStatus":
                case 3:
                    message.type = 3;
                    break;
                case "NotifyType_QotRight":
                case 4:
                    message.type = 4;
                    break;
                case "NotifyType_APILevel":
                case 5:
                    message.type = 5;
                    break;
                case "NotifyType_APIQuota":
                case 6:
                    message.type = 6;
                    break;
                case "NotifyType_UsedQuota":
                case 7:
                    message.type = 7;
                    break;
                }
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".notify.Event.S2C.event: object expected");
                    message.event = $root.common.GtwEvent.fromObject(object.event);
                }
                if (object.programStatus != null) {
                    if (typeof object.programStatus !== "object")
                        throw TypeError(".notify.Event.S2C.programStatus: object expected");
                    message.programStatus = $root.common.ProgramStatus.fromObject(object.programStatus);
                }
                if (object.connectStatus != null) {
                    if (typeof object.connectStatus !== "object")
                        throw TypeError(".notify.Event.S2C.connectStatus: object expected");
                    message.connectStatus = $root.common.ConnectStatus.fromObject(object.connectStatus);
                }
                if (object.qotRight != null) {
                    if (typeof object.qotRight !== "object")
                        throw TypeError(".notify.Event.S2C.qotRight: object expected");
                    message.qotRight = $root.common.QotRight.fromObject(object.qotRight);
                }
                if (object.apiLevel != null) {
                    if (typeof object.apiLevel !== "object")
                        throw TypeError(".notify.Event.S2C.apiLevel: object expected");
                    message.apiLevel = $root.common.APILevel.fromObject(object.apiLevel);
                }
                if (object.apiQuota != null) {
                    if (typeof object.apiQuota !== "object")
                        throw TypeError(".notify.Event.S2C.apiQuota: object expected");
                    message.apiQuota = $root.common.APIQuota.fromObject(object.apiQuota);
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof notify.Event.S2C
             * @static
             * @param {notify.Event.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "NotifyType_None" : 0;
                    object.event = null;
                    object.programStatus = null;
                    object.connectStatus = null;
                    object.qotRight = null;
                    object.apiLevel = null;
                    object.apiQuota = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.common.NotifyType[message.type] === undefined ? message.type : $root.common.NotifyType[message.type] : message.type;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.common.GtwEvent.toObject(message.event, options);
                if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                    object.programStatus = $root.common.ProgramStatus.toObject(message.programStatus, options);
                if (message.connectStatus != null && message.hasOwnProperty("connectStatus"))
                    object.connectStatus = $root.common.ConnectStatus.toObject(message.connectStatus, options);
                if (message.qotRight != null && message.hasOwnProperty("qotRight"))
                    object.qotRight = $root.common.QotRight.toObject(message.qotRight, options);
                if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                    object.apiLevel = $root.common.APILevel.toObject(message.apiLevel, options);
                if (message.apiQuota != null && message.hasOwnProperty("apiQuota"))
                    object.apiQuota = $root.common.APIQuota.toObject(message.apiQuota, options);
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof notify.Event.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof notify.Event.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/notify.Event.S2C";
            };

            return S2C;
        })();

        return Event;
    })();

    notify.Deal = (function() {

        /**
         * Properties of a Deal.
         * @memberof notify
         * @interface IDeal
         * @property {number} retType Deal retType
         * @property {string|null} [retMsg] Deal retMsg
         * @property {number|null} [errCode] Deal errCode
         * @property {notify.Deal.IS2C|null} [s2c] Deal s2c
         */

        /**
         * Constructs a new Deal.
         * @memberof notify
         * @classdesc 成交推送
         * @implements IDeal
         * @constructor
         * @param {notify.IDeal=} [properties] Properties to set
         */
        function Deal(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Deal retType.
         * @member {number} retType
         * @memberof notify.Deal
         * @instance
         */
        Deal.prototype.retType = -400;

        /**
         * Deal retMsg.
         * @member {string} retMsg
         * @memberof notify.Deal
         * @instance
         */
        Deal.prototype.retMsg = "";

        /**
         * Deal errCode.
         * @member {number} errCode
         * @memberof notify.Deal
         * @instance
         */
        Deal.prototype.errCode = 0;

        /**
         * Deal s2c.
         * @member {notify.Deal.IS2C|null|undefined} s2c
         * @memberof notify.Deal
         * @instance
         */
        Deal.prototype.s2c = null;

        /**
         * Creates a new Deal instance using the specified properties.
         * @function create
         * @memberof notify.Deal
         * @static
         * @param {notify.IDeal=} [properties] Properties to set
         * @returns {notify.Deal} Deal instance
         */
        Deal.create = function create(properties) {
            return new Deal(properties);
        };

        /**
         * Encodes the specified Deal message. Does not implicitly {@link notify.Deal.verify|verify} messages.
         * @function encode
         * @memberof notify.Deal
         * @static
         * @param {notify.IDeal} message Deal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Deal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.notify.Deal.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Deal message, length delimited. Does not implicitly {@link notify.Deal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof notify.Deal
         * @static
         * @param {notify.IDeal} message Deal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Deal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Deal message from the specified reader or buffer.
         * @function decode
         * @memberof notify.Deal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {notify.Deal} Deal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Deal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.Deal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.notify.Deal.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Deal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof notify.Deal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {notify.Deal} Deal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Deal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Deal message.
         * @function verify
         * @memberof notify.Deal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Deal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.notify.Deal.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Deal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof notify.Deal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {notify.Deal} Deal
         */
        Deal.fromObject = function fromObject(object) {
            if (object instanceof $root.notify.Deal)
                return object;
            let message = new $root.notify.Deal();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".notify.Deal.s2c: object expected");
                message.s2c = $root.notify.Deal.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Deal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof notify.Deal
         * @static
         * @param {notify.Deal} message Deal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Deal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.notify.Deal.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Deal to JSON.
         * @function toJSON
         * @memberof notify.Deal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Deal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Deal
         * @function getTypeUrl
         * @memberof notify.Deal
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Deal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/notify.Deal";
        };

        Deal.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof notify.Deal
             * @interface IS2C
             * @property {common.ITrdHeader} header S2C header
             * @property {common.IOrderFill} order S2C order
             */

            /**
             * Constructs a new S2C.
             * @memberof notify.Deal
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {notify.Deal.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C header.
             * @member {common.ITrdHeader} header
             * @memberof notify.Deal.S2C
             * @instance
             */
            S2C.prototype.header = null;

            /**
             * S2C order.
             * @member {common.IOrderFill} order
             * @memberof notify.Deal.S2C
             * @instance
             */
            S2C.prototype.order = null;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof notify.Deal.S2C
             * @static
             * @param {notify.Deal.IS2C=} [properties] Properties to set
             * @returns {notify.Deal.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link notify.Deal.S2C.verify|verify} messages.
             * @function encode
             * @memberof notify.Deal.S2C
             * @static
             * @param {notify.Deal.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                $root.common.OrderFill.encode(message.order, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link notify.Deal.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof notify.Deal.S2C
             * @static
             * @param {notify.Deal.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof notify.Deal.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {notify.Deal.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.Deal.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.order = $root.common.OrderFill.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                if (!message.hasOwnProperty("order"))
                    throw $util.ProtocolError("missing required 'order'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof notify.Deal.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {notify.Deal.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof notify.Deal.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                {
                    let error = $root.common.OrderFill.verify(message.order);
                    if (error)
                        return "order." + error;
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof notify.Deal.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {notify.Deal.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.notify.Deal.S2C)
                    return object;
                let message = new $root.notify.Deal.S2C();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".notify.Deal.S2C.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.order != null) {
                    if (typeof object.order !== "object")
                        throw TypeError(".notify.Deal.S2C.order: object expected");
                    message.order = $root.common.OrderFill.fromObject(object.order);
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof notify.Deal.S2C
             * @static
             * @param {notify.Deal.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.header = null;
                    object.order = null;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = $root.common.OrderFill.toObject(message.order, options);
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof notify.Deal.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof notify.Deal.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/notify.Deal.S2C";
            };

            return S2C;
        })();

        return Deal;
    })();

    notify.Order = (function() {

        /**
         * Properties of an Order.
         * @memberof notify
         * @interface IOrder
         * @property {number} retType Order retType
         * @property {string|null} [retMsg] Order retMsg
         * @property {number|null} [errCode] Order errCode
         * @property {notify.Order.IS2C|null} [s2c] Order s2c
         */

        /**
         * Constructs a new Order.
         * @memberof notify
         * @classdesc 订单推送
         * @implements IOrder
         * @constructor
         * @param {notify.IOrder=} [properties] Properties to set
         */
        function Order(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Order retType.
         * @member {number} retType
         * @memberof notify.Order
         * @instance
         */
        Order.prototype.retType = -400;

        /**
         * Order retMsg.
         * @member {string} retMsg
         * @memberof notify.Order
         * @instance
         */
        Order.prototype.retMsg = "";

        /**
         * Order errCode.
         * @member {number} errCode
         * @memberof notify.Order
         * @instance
         */
        Order.prototype.errCode = 0;

        /**
         * Order s2c.
         * @member {notify.Order.IS2C|null|undefined} s2c
         * @memberof notify.Order
         * @instance
         */
        Order.prototype.s2c = null;

        /**
         * Creates a new Order instance using the specified properties.
         * @function create
         * @memberof notify.Order
         * @static
         * @param {notify.IOrder=} [properties] Properties to set
         * @returns {notify.Order} Order instance
         */
        Order.create = function create(properties) {
            return new Order(properties);
        };

        /**
         * Encodes the specified Order message. Does not implicitly {@link notify.Order.verify|verify} messages.
         * @function encode
         * @memberof notify.Order
         * @static
         * @param {notify.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.notify.Order.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Order message, length delimited. Does not implicitly {@link notify.Order.verify|verify} messages.
         * @function encodeDelimited
         * @memberof notify.Order
         * @static
         * @param {notify.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Order message from the specified reader or buffer.
         * @function decode
         * @memberof notify.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {notify.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.Order();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.notify.Order.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes an Order message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof notify.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {notify.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Order message.
         * @function verify
         * @memberof notify.Order
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Order.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.notify.Order.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates an Order message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof notify.Order
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {notify.Order} Order
         */
        Order.fromObject = function fromObject(object) {
            if (object instanceof $root.notify.Order)
                return object;
            let message = new $root.notify.Order();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".notify.Order.s2c: object expected");
                message.s2c = $root.notify.Order.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from an Order message. Also converts values to other types if specified.
         * @function toObject
         * @memberof notify.Order
         * @static
         * @param {notify.Order} message Order
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Order.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.notify.Order.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Order to JSON.
         * @function toJSON
         * @memberof notify.Order
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Order.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Order
         * @function getTypeUrl
         * @memberof notify.Order
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Order.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/notify.Order";
        };

        Order.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof notify.Order
             * @interface IS2C
             * @property {common.ITrdHeader} header S2C header
             * @property {common.IOrder} order S2C order
             */

            /**
             * Constructs a new S2C.
             * @memberof notify.Order
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {notify.Order.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C header.
             * @member {common.ITrdHeader} header
             * @memberof notify.Order.S2C
             * @instance
             */
            S2C.prototype.header = null;

            /**
             * S2C order.
             * @member {common.IOrder} order
             * @memberof notify.Order.S2C
             * @instance
             */
            S2C.prototype.order = null;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof notify.Order.S2C
             * @static
             * @param {notify.Order.IS2C=} [properties] Properties to set
             * @returns {notify.Order.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link notify.Order.S2C.verify|verify} messages.
             * @function encode
             * @memberof notify.Order.S2C
             * @static
             * @param {notify.Order.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                $root.common.Order.encode(message.order, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link notify.Order.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof notify.Order.S2C
             * @static
             * @param {notify.Order.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof notify.Order.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {notify.Order.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.Order.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.order = $root.common.Order.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                if (!message.hasOwnProperty("order"))
                    throw $util.ProtocolError("missing required 'order'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof notify.Order.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {notify.Order.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof notify.Order.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                {
                    let error = $root.common.Order.verify(message.order);
                    if (error)
                        return "order." + error;
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof notify.Order.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {notify.Order.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.notify.Order.S2C)
                    return object;
                let message = new $root.notify.Order.S2C();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".notify.Order.S2C.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.order != null) {
                    if (typeof object.order !== "object")
                        throw TypeError(".notify.Order.S2C.order: object expected");
                    message.order = $root.common.Order.fromObject(object.order);
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof notify.Order.S2C
             * @static
             * @param {notify.Order.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.header = null;
                    object.order = null;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = $root.common.Order.toObject(message.order, options);
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof notify.Order.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof notify.Order.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/notify.Order.S2C";
            };

            return S2C;
        })();

        return Order;
    })();

    notify.BasicQot = (function() {

        /**
         * Properties of a BasicQot.
         * @memberof notify
         * @interface IBasicQot
         * @property {number} retType BasicQot retType
         * @property {string|null} [retMsg] BasicQot retMsg
         * @property {number|null} [errCode] BasicQot errCode
         * @property {notify.BasicQot.IS2C|null} [s2c] BasicQot s2c
         */

        /**
         * Constructs a new BasicQot.
         * @memberof notify
         * @classdesc 实时报价
         * @implements IBasicQot
         * @constructor
         * @param {notify.IBasicQot=} [properties] Properties to set
         */
        function BasicQot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicQot retType.
         * @member {number} retType
         * @memberof notify.BasicQot
         * @instance
         */
        BasicQot.prototype.retType = 0;

        /**
         * BasicQot retMsg.
         * @member {string} retMsg
         * @memberof notify.BasicQot
         * @instance
         */
        BasicQot.prototype.retMsg = "";

        /**
         * BasicQot errCode.
         * @member {number} errCode
         * @memberof notify.BasicQot
         * @instance
         */
        BasicQot.prototype.errCode = 0;

        /**
         * BasicQot s2c.
         * @member {notify.BasicQot.IS2C|null|undefined} s2c
         * @memberof notify.BasicQot
         * @instance
         */
        BasicQot.prototype.s2c = null;

        /**
         * Creates a new BasicQot instance using the specified properties.
         * @function create
         * @memberof notify.BasicQot
         * @static
         * @param {notify.IBasicQot=} [properties] Properties to set
         * @returns {notify.BasicQot} BasicQot instance
         */
        BasicQot.create = function create(properties) {
            return new BasicQot(properties);
        };

        /**
         * Encodes the specified BasicQot message. Does not implicitly {@link notify.BasicQot.verify|verify} messages.
         * @function encode
         * @memberof notify.BasicQot
         * @static
         * @param {notify.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.notify.BasicQot.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BasicQot message, length delimited. Does not implicitly {@link notify.BasicQot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof notify.BasicQot
         * @static
         * @param {notify.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer.
         * @function decode
         * @memberof notify.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {notify.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.BasicQot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.notify.BasicQot.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof notify.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {notify.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicQot message.
         * @function verify
         * @memberof notify.BasicQot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicQot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.notify.BasicQot.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a BasicQot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof notify.BasicQot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {notify.BasicQot} BasicQot
         */
        BasicQot.fromObject = function fromObject(object) {
            if (object instanceof $root.notify.BasicQot)
                return object;
            let message = new $root.notify.BasicQot();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".notify.BasicQot.s2c: object expected");
                message.s2c = $root.notify.BasicQot.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a BasicQot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof notify.BasicQot
         * @static
         * @param {notify.BasicQot} message BasicQot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicQot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.notify.BasicQot.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this BasicQot to JSON.
         * @function toJSON
         * @memberof notify.BasicQot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicQot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BasicQot
         * @function getTypeUrl
         * @memberof notify.BasicQot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BasicQot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/notify.BasicQot";
        };

        BasicQot.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof notify.BasicQot
             * @interface IS2C
             * @property {Array.<common.IBasicQot>|null} [basicQotList] S2C basicQotList
             */

            /**
             * Constructs a new S2C.
             * @memberof notify.BasicQot
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {notify.BasicQot.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.basicQotList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C basicQotList.
             * @member {Array.<common.IBasicQot>} basicQotList
             * @memberof notify.BasicQot.S2C
             * @instance
             */
            S2C.prototype.basicQotList = $util.emptyArray;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {notify.BasicQot.IS2C=} [properties] Properties to set
             * @returns {notify.BasicQot.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link notify.BasicQot.S2C.verify|verify} messages.
             * @function encode
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {notify.BasicQot.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.basicQotList != null && message.basicQotList.length)
                    for (let i = 0; i < message.basicQotList.length; ++i)
                        $root.common.BasicQot.encode(message.basicQotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link notify.BasicQot.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {notify.BasicQot.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {notify.BasicQot.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.notify.BasicQot.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.basicQotList && message.basicQotList.length))
                                message.basicQotList = [];
                            message.basicQotList.push($root.common.BasicQot.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {notify.BasicQot.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.basicQotList != null && message.hasOwnProperty("basicQotList")) {
                    if (!Array.isArray(message.basicQotList))
                        return "basicQotList: array expected";
                    for (let i = 0; i < message.basicQotList.length; ++i) {
                        let error = $root.common.BasicQot.verify(message.basicQotList[i]);
                        if (error)
                            return "basicQotList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {notify.BasicQot.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.notify.BasicQot.S2C)
                    return object;
                let message = new $root.notify.BasicQot.S2C();
                if (object.basicQotList) {
                    if (!Array.isArray(object.basicQotList))
                        throw TypeError(".notify.BasicQot.S2C.basicQotList: array expected");
                    message.basicQotList = [];
                    for (let i = 0; i < object.basicQotList.length; ++i) {
                        if (typeof object.basicQotList[i] !== "object")
                            throw TypeError(".notify.BasicQot.S2C.basicQotList: object expected");
                        message.basicQotList[i] = $root.common.BasicQot.fromObject(object.basicQotList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {notify.BasicQot.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.basicQotList = [];
                if (message.basicQotList && message.basicQotList.length) {
                    object.basicQotList = [];
                    for (let j = 0; j < message.basicQotList.length; ++j)
                        object.basicQotList[j] = $root.common.BasicQot.toObject(message.basicQotList[j], options);
                }
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof notify.BasicQot.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof notify.BasicQot.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/notify.BasicQot.S2C";
            };

            return S2C;
        })();

        return BasicQot;
    })();

    return notify;
})();

export const order = $root.order = (() => {

    /**
     * Namespace order.
     * @exports order
     * @namespace
     */
    const order = {};

    order.CreateReq = (function() {

        /**
         * Properties of a CreateReq.
         * @memberof order
         * @interface ICreateReq
         * @property {order.CreateReq.IC2S} c2s CreateReq c2s
         */

        /**
         * Constructs a new CreateReq.
         * @memberof order
         * @classdesc 下单请求
         * @implements ICreateReq
         * @constructor
         * @param {order.ICreateReq=} [properties] Properties to set
         */
        function CreateReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateReq c2s.
         * @member {order.CreateReq.IC2S} c2s
         * @memberof order.CreateReq
         * @instance
         */
        CreateReq.prototype.c2s = null;

        /**
         * Creates a new CreateReq instance using the specified properties.
         * @function create
         * @memberof order.CreateReq
         * @static
         * @param {order.ICreateReq=} [properties] Properties to set
         * @returns {order.CreateReq} CreateReq instance
         */
        CreateReq.create = function create(properties) {
            return new CreateReq(properties);
        };

        /**
         * Encodes the specified CreateReq message. Does not implicitly {@link order.CreateReq.verify|verify} messages.
         * @function encode
         * @memberof order.CreateReq
         * @static
         * @param {order.ICreateReq} message CreateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.order.CreateReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateReq message, length delimited. Does not implicitly {@link order.CreateReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof order.CreateReq
         * @static
         * @param {order.ICreateReq} message CreateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateReq message from the specified reader or buffer.
         * @function decode
         * @memberof order.CreateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {order.CreateReq} CreateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.CreateReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.order.CreateReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a CreateReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof order.CreateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {order.CreateReq} CreateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateReq message.
         * @function verify
         * @memberof order.CreateReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.order.CreateReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a CreateReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof order.CreateReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {order.CreateReq} CreateReq
         */
        CreateReq.fromObject = function fromObject(object) {
            if (object instanceof $root.order.CreateReq)
                return object;
            let message = new $root.order.CreateReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".order.CreateReq.c2s: object expected");
                message.c2s = $root.order.CreateReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof order.CreateReq
         * @static
         * @param {order.CreateReq} message CreateReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.order.CreateReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this CreateReq to JSON.
         * @function toJSON
         * @memberof order.CreateReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateReq
         * @function getTypeUrl
         * @memberof order.CreateReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/order.CreateReq";
        };

        CreateReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof order.CreateReq
             * @interface IC2S
             * @property {common.IPacketID} packetID C2S packetID
             * @property {common.ITrdHeader} header C2S header
             * @property {common.TrdSide} trdSide C2S trdSide
             * @property {common.OrderType} orderType C2S orderType
             * @property {string} code C2S code
             * @property {number} qty C2S qty
             * @property {number} price C2S price
             * @property {boolean|null} [adjustPrice] C2S adjustPrice
             * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
             * @property {common.TrdSecMarket} secMarket C2S secMarket
             * @property {string|null} [remark] C2S remark
             * @property {common.TimeInForce|null} [timeInForce] C2S timeInForce
             * @property {boolean|null} [fillOutsideRTH] C2S fillOutsideRTH
             * @property {number|null} [auxPrice] C2S auxPrice
             * @property {common.TrailType|null} [trailType] C2S trailType
             * @property {number|null} [trailValue] C2S trailValue
             * @property {number|null} [trailSpread] C2S trailSpread
             */

            /**
             * Constructs a new C2S.
             * @memberof order.CreateReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {order.CreateReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S packetID.
             * @member {common.IPacketID} packetID
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.packetID = null;

            /**
             * C2S header.
             * @member {common.ITrdHeader} header
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.header = null;

            /**
             * C2S trdSide.
             * @member {common.TrdSide} trdSide
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.trdSide = 0;

            /**
             * C2S orderType.
             * @member {common.OrderType} orderType
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.orderType = 0;

            /**
             * C2S code.
             * @member {string} code
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.code = "";

            /**
             * C2S qty.
             * @member {number} qty
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.qty = 0;

            /**
             * C2S price.
             * @member {number} price
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.price = 0;

            /**
             * C2S adjustPrice.
             * @member {boolean} adjustPrice
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.adjustPrice = false;

            /**
             * C2S adjustSideAndLimit.
             * @member {number} adjustSideAndLimit
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.adjustSideAndLimit = 0;

            /**
             * C2S secMarket.
             * @member {common.TrdSecMarket} secMarket
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.secMarket = 0;

            /**
             * C2S remark.
             * @member {string} remark
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.remark = "";

            /**
             * C2S timeInForce.
             * @member {common.TimeInForce} timeInForce
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.timeInForce = 0;

            /**
             * C2S fillOutsideRTH.
             * @member {boolean} fillOutsideRTH
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.fillOutsideRTH = false;

            /**
             * C2S auxPrice.
             * @member {number} auxPrice
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.auxPrice = 0;

            /**
             * C2S trailType.
             * @member {common.TrailType} trailType
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.trailType = 0;

            /**
             * C2S trailValue.
             * @member {number} trailValue
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.trailValue = 0;

            /**
             * C2S trailSpread.
             * @member {number} trailSpread
             * @memberof order.CreateReq.C2S
             * @instance
             */
            C2S.prototype.trailSpread = 0;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof order.CreateReq.C2S
             * @static
             * @param {order.CreateReq.IC2S=} [properties] Properties to set
             * @returns {order.CreateReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link order.CreateReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof order.CreateReq.C2S
             * @static
             * @param {order.CreateReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.PacketID.encode(message.packetID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdSide);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.orderType);
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.code);
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.qty);
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.price);
                if (message.adjustPrice != null && Object.hasOwnProperty.call(message, "adjustPrice"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.adjustPrice);
                if (message.adjustSideAndLimit != null && Object.hasOwnProperty.call(message, "adjustSideAndLimit"))
                    writer.uint32(/* id 9, wireType 1 =*/73).double(message.adjustSideAndLimit);
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.secMarket);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.remark);
                if (message.timeInForce != null && Object.hasOwnProperty.call(message, "timeInForce"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.timeInForce);
                if (message.fillOutsideRTH != null && Object.hasOwnProperty.call(message, "fillOutsideRTH"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.fillOutsideRTH);
                if (message.auxPrice != null && Object.hasOwnProperty.call(message, "auxPrice"))
                    writer.uint32(/* id 14, wireType 1 =*/113).double(message.auxPrice);
                if (message.trailType != null && Object.hasOwnProperty.call(message, "trailType"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.trailType);
                if (message.trailValue != null && Object.hasOwnProperty.call(message, "trailValue"))
                    writer.uint32(/* id 16, wireType 1 =*/129).double(message.trailValue);
                if (message.trailSpread != null && Object.hasOwnProperty.call(message, "trailSpread"))
                    writer.uint32(/* id 17, wireType 1 =*/137).double(message.trailSpread);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link order.CreateReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof order.CreateReq.C2S
             * @static
             * @param {order.CreateReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof order.CreateReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {order.CreateReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.CreateReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.packetID = $root.common.PacketID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.trdSide = reader.int32();
                            break;
                        }
                    case 4: {
                            message.orderType = reader.int32();
                            break;
                        }
                    case 5: {
                            message.code = reader.string();
                            break;
                        }
                    case 6: {
                            message.qty = reader.double();
                            break;
                        }
                    case 7: {
                            message.price = reader.double();
                            break;
                        }
                    case 8: {
                            message.adjustPrice = reader.bool();
                            break;
                        }
                    case 9: {
                            message.adjustSideAndLimit = reader.double();
                            break;
                        }
                    case 10: {
                            message.secMarket = reader.int32();
                            break;
                        }
                    case 11: {
                            message.remark = reader.string();
                            break;
                        }
                    case 12: {
                            message.timeInForce = reader.int32();
                            break;
                        }
                    case 13: {
                            message.fillOutsideRTH = reader.bool();
                            break;
                        }
                    case 14: {
                            message.auxPrice = reader.double();
                            break;
                        }
                    case 15: {
                            message.trailType = reader.int32();
                            break;
                        }
                    case 16: {
                            message.trailValue = reader.double();
                            break;
                        }
                    case 17: {
                            message.trailSpread = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("packetID"))
                    throw $util.ProtocolError("missing required 'packetID'", { instance: message });
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                if (!message.hasOwnProperty("trdSide"))
                    throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
                if (!message.hasOwnProperty("orderType"))
                    throw $util.ProtocolError("missing required 'orderType'", { instance: message });
                if (!message.hasOwnProperty("code"))
                    throw $util.ProtocolError("missing required 'code'", { instance: message });
                if (!message.hasOwnProperty("qty"))
                    throw $util.ProtocolError("missing required 'qty'", { instance: message });
                if (!message.hasOwnProperty("price"))
                    throw $util.ProtocolError("missing required 'price'", { instance: message });
                if (!message.hasOwnProperty("secMarket"))
                    throw $util.ProtocolError("missing required 'secMarket'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof order.CreateReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {order.CreateReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof order.CreateReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.PacketID.verify(message.packetID);
                    if (error)
                        return "packetID." + error;
                }
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                switch (message.trdSide) {
                default:
                    return "trdSide: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
                switch (message.orderType) {
                default:
                    return "orderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                    break;
                }
                if (!$util.isString(message.code))
                    return "code: string expected";
                if (typeof message.qty !== "number")
                    return "qty: number expected";
                if (typeof message.price !== "number")
                    return "price: number expected";
                if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                    if (typeof message.adjustPrice !== "boolean")
                        return "adjustPrice: boolean expected";
                if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                    if (typeof message.adjustSideAndLimit !== "number")
                        return "adjustSideAndLimit: number expected";
                switch (message.secMarket) {
                default:
                    return "secMarket: enum value expected";
                case 0:
                case 1:
                case 2:
                case 31:
                case 32:
                case 41:
                case 51:
                case 61:
                case 71:
                case 81:
                case 91:
                    break;
                }
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                if (message.timeInForce != null && message.hasOwnProperty("timeInForce"))
                    switch (message.timeInForce) {
                    default:
                        return "timeInForce: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.fillOutsideRTH != null && message.hasOwnProperty("fillOutsideRTH"))
                    if (typeof message.fillOutsideRTH !== "boolean")
                        return "fillOutsideRTH: boolean expected";
                if (message.auxPrice != null && message.hasOwnProperty("auxPrice"))
                    if (typeof message.auxPrice !== "number")
                        return "auxPrice: number expected";
                if (message.trailType != null && message.hasOwnProperty("trailType"))
                    switch (message.trailType) {
                    default:
                        return "trailType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.trailValue != null && message.hasOwnProperty("trailValue"))
                    if (typeof message.trailValue !== "number")
                        return "trailValue: number expected";
                if (message.trailSpread != null && message.hasOwnProperty("trailSpread"))
                    if (typeof message.trailSpread !== "number")
                        return "trailSpread: number expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof order.CreateReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {order.CreateReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.order.CreateReq.C2S)
                    return object;
                let message = new $root.order.CreateReq.C2S();
                if (object.packetID != null) {
                    if (typeof object.packetID !== "object")
                        throw TypeError(".order.CreateReq.C2S.packetID: object expected");
                    message.packetID = $root.common.PacketID.fromObject(object.packetID);
                }
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".order.CreateReq.C2S.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                switch (object.trdSide) {
                default:
                    if (typeof object.trdSide === "number") {
                        message.trdSide = object.trdSide;
                        break;
                    }
                    break;
                case "TrdSide_Unknown":
                case 0:
                    message.trdSide = 0;
                    break;
                case "TrdSide_Buy":
                case 1:
                    message.trdSide = 1;
                    break;
                case "TrdSide_Sell":
                case 2:
                    message.trdSide = 2;
                    break;
                case "TrdSide_SellShort":
                case 3:
                    message.trdSide = 3;
                    break;
                case "TrdSide_BuyBack":
                case 4:
                    message.trdSide = 4;
                    break;
                }
                switch (object.orderType) {
                default:
                    if (typeof object.orderType === "number") {
                        message.orderType = object.orderType;
                        break;
                    }
                    break;
                case "OrderType_Unknown":
                case 0:
                    message.orderType = 0;
                    break;
                case "OrderType_Normal":
                case 1:
                    message.orderType = 1;
                    break;
                case "OrderType_Market":
                case 2:
                    message.orderType = 2;
                    break;
                case "OrderType_AbsoluteLimit":
                case 5:
                    message.orderType = 5;
                    break;
                case "OrderType_Auction":
                case 6:
                    message.orderType = 6;
                    break;
                case "OrderType_AuctionLimit":
                case 7:
                    message.orderType = 7;
                    break;
                case "OrderType_SpecialLimit":
                case 8:
                    message.orderType = 8;
                    break;
                case "OrderType_SpecialLimit_All":
                case 9:
                    message.orderType = 9;
                    break;
                case "OrderType_Stop":
                case 10:
                    message.orderType = 10;
                    break;
                case "OrderType_StopLimit":
                case 11:
                    message.orderType = 11;
                    break;
                case "OrderType_MarketifTouched":
                case 12:
                    message.orderType = 12;
                    break;
                case "OrderType_LimitifTouched":
                case 13:
                    message.orderType = 13;
                    break;
                case "OrderType_TrailingStop":
                case 14:
                    message.orderType = 14;
                    break;
                case "OrderType_TrailingStopLimit":
                case 15:
                    message.orderType = 15;
                    break;
                case "OrderType_TWAP":
                case 16:
                    message.orderType = 16;
                    break;
                case "OrderType_TWAP_LIMIT":
                case 17:
                    message.orderType = 17;
                    break;
                case "OrderType_VWAP":
                case 18:
                    message.orderType = 18;
                    break;
                case "OrderType_VWAP_LIMIT":
                case 19:
                    message.orderType = 19;
                    break;
                }
                if (object.code != null)
                    message.code = String(object.code);
                if (object.qty != null)
                    message.qty = Number(object.qty);
                if (object.price != null)
                    message.price = Number(object.price);
                if (object.adjustPrice != null)
                    message.adjustPrice = Boolean(object.adjustPrice);
                if (object.adjustSideAndLimit != null)
                    message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
                switch (object.secMarket) {
                default:
                    if (typeof object.secMarket === "number") {
                        message.secMarket = object.secMarket;
                        break;
                    }
                    break;
                case "TrdSecMarket_Unknown":
                case 0:
                    message.secMarket = 0;
                    break;
                case "TrdSecMarket_HK":
                case 1:
                    message.secMarket = 1;
                    break;
                case "TrdSecMarket_US":
                case 2:
                    message.secMarket = 2;
                    break;
                case "TrdSecMarket_CN_SH":
                case 31:
                    message.secMarket = 31;
                    break;
                case "TrdSecMarket_CN_SZ":
                case 32:
                    message.secMarket = 32;
                    break;
                case "TrdSecMarket_SG":
                case 41:
                    message.secMarket = 41;
                    break;
                case "TrdSecMarket_JP":
                case 51:
                    message.secMarket = 51;
                    break;
                case "TrdSecMarket_AU":
                case 61:
                    message.secMarket = 61;
                    break;
                case "TrdSecMarket_MY":
                case 71:
                    message.secMarket = 71;
                    break;
                case "TrdSecMarket_CA":
                case 81:
                    message.secMarket = 81;
                    break;
                case "TrdSecMarket_FX":
                case 91:
                    message.secMarket = 91;
                    break;
                }
                if (object.remark != null)
                    message.remark = String(object.remark);
                switch (object.timeInForce) {
                default:
                    if (typeof object.timeInForce === "number") {
                        message.timeInForce = object.timeInForce;
                        break;
                    }
                    break;
                case "TimeInForce_DAY":
                case 0:
                    message.timeInForce = 0;
                    break;
                case "TimeInForce_GTC":
                case 1:
                    message.timeInForce = 1;
                    break;
                }
                if (object.fillOutsideRTH != null)
                    message.fillOutsideRTH = Boolean(object.fillOutsideRTH);
                if (object.auxPrice != null)
                    message.auxPrice = Number(object.auxPrice);
                switch (object.trailType) {
                default:
                    if (typeof object.trailType === "number") {
                        message.trailType = object.trailType;
                        break;
                    }
                    break;
                case "TrailType_Unknown":
                case 0:
                    message.trailType = 0;
                    break;
                case "TrailType_Ratio":
                case 1:
                    message.trailType = 1;
                    break;
                case "TrailType_Amount":
                case 2:
                    message.trailType = 2;
                    break;
                }
                if (object.trailValue != null)
                    message.trailValue = Number(object.trailValue);
                if (object.trailSpread != null)
                    message.trailSpread = Number(object.trailSpread);
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof order.CreateReq.C2S
             * @static
             * @param {order.CreateReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.packetID = null;
                    object.header = null;
                    object.trdSide = options.enums === String ? "TrdSide_Unknown" : 0;
                    object.orderType = options.enums === String ? "OrderType_Unknown" : 0;
                    object.code = "";
                    object.qty = 0;
                    object.price = 0;
                    object.adjustPrice = false;
                    object.adjustSideAndLimit = 0;
                    object.secMarket = options.enums === String ? "TrdSecMarket_Unknown" : 0;
                    object.remark = "";
                    object.timeInForce = options.enums === String ? "TimeInForce_DAY" : 0;
                    object.fillOutsideRTH = false;
                    object.auxPrice = 0;
                    object.trailType = options.enums === String ? "TrailType_Unknown" : 0;
                    object.trailValue = 0;
                    object.trailSpread = 0;
                }
                if (message.packetID != null && message.hasOwnProperty("packetID"))
                    object.packetID = $root.common.PacketID.toObject(message.packetID, options);
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                    object.trdSide = options.enums === String ? $root.common.TrdSide[message.trdSide] === undefined ? message.trdSide : $root.common.TrdSide[message.trdSide] : message.trdSide;
                if (message.orderType != null && message.hasOwnProperty("orderType"))
                    object.orderType = options.enums === String ? $root.common.OrderType[message.orderType] === undefined ? message.orderType : $root.common.OrderType[message.orderType] : message.orderType;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.qty != null && message.hasOwnProperty("qty"))
                    object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
                if (message.price != null && message.hasOwnProperty("price"))
                    object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
                if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                    object.adjustPrice = message.adjustPrice;
                if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                    object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
                if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                    object.secMarket = options.enums === String ? $root.common.TrdSecMarket[message.secMarket] === undefined ? message.secMarket : $root.common.TrdSecMarket[message.secMarket] : message.secMarket;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                if (message.timeInForce != null && message.hasOwnProperty("timeInForce"))
                    object.timeInForce = options.enums === String ? $root.common.TimeInForce[message.timeInForce] === undefined ? message.timeInForce : $root.common.TimeInForce[message.timeInForce] : message.timeInForce;
                if (message.fillOutsideRTH != null && message.hasOwnProperty("fillOutsideRTH"))
                    object.fillOutsideRTH = message.fillOutsideRTH;
                if (message.auxPrice != null && message.hasOwnProperty("auxPrice"))
                    object.auxPrice = options.json && !isFinite(message.auxPrice) ? String(message.auxPrice) : message.auxPrice;
                if (message.trailType != null && message.hasOwnProperty("trailType"))
                    object.trailType = options.enums === String ? $root.common.TrailType[message.trailType] === undefined ? message.trailType : $root.common.TrailType[message.trailType] : message.trailType;
                if (message.trailValue != null && message.hasOwnProperty("trailValue"))
                    object.trailValue = options.json && !isFinite(message.trailValue) ? String(message.trailValue) : message.trailValue;
                if (message.trailSpread != null && message.hasOwnProperty("trailSpread"))
                    object.trailSpread = options.json && !isFinite(message.trailSpread) ? String(message.trailSpread) : message.trailSpread;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof order.CreateReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof order.CreateReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/order.CreateReq.C2S";
            };

            return C2S;
        })();

        return CreateReq;
    })();

    order.CreateRes = (function() {

        /**
         * Properties of a CreateRes.
         * @memberof order
         * @interface ICreateRes
         * @property {number} retType CreateRes retType
         * @property {string|null} [retMsg] CreateRes retMsg
         * @property {number|null} [errCode] CreateRes errCode
         * @property {order.CreateRes.IS2C|null} [s2c] CreateRes s2c
         */

        /**
         * Constructs a new CreateRes.
         * @memberof order
         * @classdesc 下单响应
         * @implements ICreateRes
         * @constructor
         * @param {order.ICreateRes=} [properties] Properties to set
         */
        function CreateRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRes retType.
         * @member {number} retType
         * @memberof order.CreateRes
         * @instance
         */
        CreateRes.prototype.retType = 0;

        /**
         * CreateRes retMsg.
         * @member {string} retMsg
         * @memberof order.CreateRes
         * @instance
         */
        CreateRes.prototype.retMsg = "";

        /**
         * CreateRes errCode.
         * @member {number} errCode
         * @memberof order.CreateRes
         * @instance
         */
        CreateRes.prototype.errCode = 0;

        /**
         * CreateRes s2c.
         * @member {order.CreateRes.IS2C|null|undefined} s2c
         * @memberof order.CreateRes
         * @instance
         */
        CreateRes.prototype.s2c = null;

        /**
         * Creates a new CreateRes instance using the specified properties.
         * @function create
         * @memberof order.CreateRes
         * @static
         * @param {order.ICreateRes=} [properties] Properties to set
         * @returns {order.CreateRes} CreateRes instance
         */
        CreateRes.create = function create(properties) {
            return new CreateRes(properties);
        };

        /**
         * Encodes the specified CreateRes message. Does not implicitly {@link order.CreateRes.verify|verify} messages.
         * @function encode
         * @memberof order.CreateRes
         * @static
         * @param {order.ICreateRes} message CreateRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.order.CreateRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRes message, length delimited. Does not implicitly {@link order.CreateRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof order.CreateRes
         * @static
         * @param {order.ICreateRes} message CreateRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRes message from the specified reader or buffer.
         * @function decode
         * @memberof order.CreateRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {order.CreateRes} CreateRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.CreateRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.order.CreateRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a CreateRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof order.CreateRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {order.CreateRes} CreateRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRes message.
         * @function verify
         * @memberof order.CreateRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.order.CreateRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a CreateRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof order.CreateRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {order.CreateRes} CreateRes
         */
        CreateRes.fromObject = function fromObject(object) {
            if (object instanceof $root.order.CreateRes)
                return object;
            let message = new $root.order.CreateRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".order.CreateRes.s2c: object expected");
                message.s2c = $root.order.CreateRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof order.CreateRes
         * @static
         * @param {order.CreateRes} message CreateRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.order.CreateRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this CreateRes to JSON.
         * @function toJSON
         * @memberof order.CreateRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateRes
         * @function getTypeUrl
         * @memberof order.CreateRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/order.CreateRes";
        };

        CreateRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof order.CreateRes
             * @interface IS2C
             * @property {common.ITrdHeader} header S2C header
             * @property {number|Long|null} [orderID] S2C orderID
             * @property {string|null} [orderIDEx] S2C orderIDEx
             */

            /**
             * Constructs a new S2C.
             * @memberof order.CreateRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {order.CreateRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C header.
             * @member {common.ITrdHeader} header
             * @memberof order.CreateRes.S2C
             * @instance
             */
            S2C.prototype.header = null;

            /**
             * S2C orderID.
             * @member {number|Long} orderID
             * @memberof order.CreateRes.S2C
             * @instance
             */
            S2C.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * S2C orderIDEx.
             * @member {string} orderIDEx
             * @memberof order.CreateRes.S2C
             * @instance
             */
            S2C.prototype.orderIDEx = "";

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof order.CreateRes.S2C
             * @static
             * @param {order.CreateRes.IS2C=} [properties] Properties to set
             * @returns {order.CreateRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link order.CreateRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof order.CreateRes.S2C
             * @static
             * @param {order.CreateRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orderID != null && Object.hasOwnProperty.call(message, "orderID"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.orderID);
                if (message.orderIDEx != null && Object.hasOwnProperty.call(message, "orderIDEx"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.orderIDEx);
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link order.CreateRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof order.CreateRes.S2C
             * @static
             * @param {order.CreateRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof order.CreateRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {order.CreateRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.CreateRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.orderID = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.orderIDEx = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof order.CreateRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {order.CreateRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof order.CreateRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.orderID != null && message.hasOwnProperty("orderID"))
                    if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                        return "orderID: integer|Long expected";
                if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                    if (!$util.isString(message.orderIDEx))
                        return "orderIDEx: string expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof order.CreateRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {order.CreateRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.order.CreateRes.S2C)
                    return object;
                let message = new $root.order.CreateRes.S2C();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".order.CreateRes.S2C.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.orderID != null)
                    if ($util.Long)
                        (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                    else if (typeof object.orderID === "string")
                        message.orderID = parseInt(object.orderID, 10);
                    else if (typeof object.orderID === "number")
                        message.orderID = object.orderID;
                    else if (typeof object.orderID === "object")
                        message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
                if (object.orderIDEx != null)
                    message.orderIDEx = String(object.orderIDEx);
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof order.CreateRes.S2C
             * @static
             * @param {order.CreateRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.header = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.orderID = options.longs === String ? "0" : 0;
                    object.orderIDEx = "";
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.orderID != null && message.hasOwnProperty("orderID"))
                    if (typeof message.orderID === "number")
                        object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                    else
                        object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
                if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                    object.orderIDEx = message.orderIDEx;
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof order.CreateRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof order.CreateRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/order.CreateRes.S2C";
            };

            return S2C;
        })();

        return CreateRes;
    })();

    order.FeeReq = (function() {

        /**
         * Properties of a FeeReq.
         * @memberof order
         * @interface IFeeReq
         * @property {order.FeeReq.IC2S} c2s FeeReq c2s
         */

        /**
         * Constructs a new FeeReq.
         * @memberof order
         * @classdesc 订单费用请求
         * @implements IFeeReq
         * @constructor
         * @param {order.IFeeReq=} [properties] Properties to set
         */
        function FeeReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeReq c2s.
         * @member {order.FeeReq.IC2S} c2s
         * @memberof order.FeeReq
         * @instance
         */
        FeeReq.prototype.c2s = null;

        /**
         * Creates a new FeeReq instance using the specified properties.
         * @function create
         * @memberof order.FeeReq
         * @static
         * @param {order.IFeeReq=} [properties] Properties to set
         * @returns {order.FeeReq} FeeReq instance
         */
        FeeReq.create = function create(properties) {
            return new FeeReq(properties);
        };

        /**
         * Encodes the specified FeeReq message. Does not implicitly {@link order.FeeReq.verify|verify} messages.
         * @function encode
         * @memberof order.FeeReq
         * @static
         * @param {order.IFeeReq} message FeeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.order.FeeReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeeReq message, length delimited. Does not implicitly {@link order.FeeReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof order.FeeReq
         * @static
         * @param {order.IFeeReq} message FeeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeReq message from the specified reader or buffer.
         * @function decode
         * @memberof order.FeeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {order.FeeReq} FeeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.FeeReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.order.FeeReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a FeeReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof order.FeeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {order.FeeReq} FeeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeReq message.
         * @function verify
         * @memberof order.FeeReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.order.FeeReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a FeeReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof order.FeeReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {order.FeeReq} FeeReq
         */
        FeeReq.fromObject = function fromObject(object) {
            if (object instanceof $root.order.FeeReq)
                return object;
            let message = new $root.order.FeeReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".order.FeeReq.c2s: object expected");
                message.c2s = $root.order.FeeReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeeReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof order.FeeReq
         * @static
         * @param {order.FeeReq} message FeeReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.order.FeeReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this FeeReq to JSON.
         * @function toJSON
         * @memberof order.FeeReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FeeReq
         * @function getTypeUrl
         * @memberof order.FeeReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/order.FeeReq";
        };

        FeeReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof order.FeeReq
             * @interface IC2S
             * @property {common.ITrdHeader} header C2S header
             * @property {Array.<string>|null} [orderIdExList] C2S orderIdExList
             */

            /**
             * Constructs a new C2S.
             * @memberof order.FeeReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {order.FeeReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                this.orderIdExList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S header.
             * @member {common.ITrdHeader} header
             * @memberof order.FeeReq.C2S
             * @instance
             */
            C2S.prototype.header = null;

            /**
             * C2S orderIdExList.
             * @member {Array.<string>} orderIdExList
             * @memberof order.FeeReq.C2S
             * @instance
             */
            C2S.prototype.orderIdExList = $util.emptyArray;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof order.FeeReq.C2S
             * @static
             * @param {order.FeeReq.IC2S=} [properties] Properties to set
             * @returns {order.FeeReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link order.FeeReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof order.FeeReq.C2S
             * @static
             * @param {order.FeeReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orderIdExList != null && message.orderIdExList.length)
                    for (let i = 0; i < message.orderIdExList.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.orderIdExList[i]);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link order.FeeReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof order.FeeReq.C2S
             * @static
             * @param {order.FeeReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof order.FeeReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {order.FeeReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.FeeReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.orderIdExList && message.orderIdExList.length))
                                message.orderIdExList = [];
                            message.orderIdExList.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof order.FeeReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {order.FeeReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof order.FeeReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.orderIdExList != null && message.hasOwnProperty("orderIdExList")) {
                    if (!Array.isArray(message.orderIdExList))
                        return "orderIdExList: array expected";
                    for (let i = 0; i < message.orderIdExList.length; ++i)
                        if (!$util.isString(message.orderIdExList[i]))
                            return "orderIdExList: string[] expected";
                }
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof order.FeeReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {order.FeeReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.order.FeeReq.C2S)
                    return object;
                let message = new $root.order.FeeReq.C2S();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".order.FeeReq.C2S.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.orderIdExList) {
                    if (!Array.isArray(object.orderIdExList))
                        throw TypeError(".order.FeeReq.C2S.orderIdExList: array expected");
                    message.orderIdExList = [];
                    for (let i = 0; i < object.orderIdExList.length; ++i)
                        message.orderIdExList[i] = String(object.orderIdExList[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof order.FeeReq.C2S
             * @static
             * @param {order.FeeReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.orderIdExList = [];
                if (options.defaults)
                    object.header = null;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.orderIdExList && message.orderIdExList.length) {
                    object.orderIdExList = [];
                    for (let j = 0; j < message.orderIdExList.length; ++j)
                        object.orderIdExList[j] = message.orderIdExList[j];
                }
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof order.FeeReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof order.FeeReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/order.FeeReq.C2S";
            };

            return C2S;
        })();

        return FeeReq;
    })();

    order.FeeRes = (function() {

        /**
         * Properties of a FeeRes.
         * @memberof order
         * @interface IFeeRes
         * @property {number} retType FeeRes retType
         * @property {string|null} [retMsg] FeeRes retMsg
         * @property {number|null} [errCode] FeeRes errCode
         * @property {order.FeeRes.IS2C|null} [s2c] FeeRes s2c
         */

        /**
         * Constructs a new FeeRes.
         * @memberof order
         * @classdesc 订单费用响应
         * @implements IFeeRes
         * @constructor
         * @param {order.IFeeRes=} [properties] Properties to set
         */
        function FeeRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeRes retType.
         * @member {number} retType
         * @memberof order.FeeRes
         * @instance
         */
        FeeRes.prototype.retType = -400;

        /**
         * FeeRes retMsg.
         * @member {string} retMsg
         * @memberof order.FeeRes
         * @instance
         */
        FeeRes.prototype.retMsg = "";

        /**
         * FeeRes errCode.
         * @member {number} errCode
         * @memberof order.FeeRes
         * @instance
         */
        FeeRes.prototype.errCode = 0;

        /**
         * FeeRes s2c.
         * @member {order.FeeRes.IS2C|null|undefined} s2c
         * @memberof order.FeeRes
         * @instance
         */
        FeeRes.prototype.s2c = null;

        /**
         * Creates a new FeeRes instance using the specified properties.
         * @function create
         * @memberof order.FeeRes
         * @static
         * @param {order.IFeeRes=} [properties] Properties to set
         * @returns {order.FeeRes} FeeRes instance
         */
        FeeRes.create = function create(properties) {
            return new FeeRes(properties);
        };

        /**
         * Encodes the specified FeeRes message. Does not implicitly {@link order.FeeRes.verify|verify} messages.
         * @function encode
         * @memberof order.FeeRes
         * @static
         * @param {order.IFeeRes} message FeeRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.order.FeeRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeeRes message, length delimited. Does not implicitly {@link order.FeeRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof order.FeeRes
         * @static
         * @param {order.IFeeRes} message FeeRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeRes message from the specified reader or buffer.
         * @function decode
         * @memberof order.FeeRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {order.FeeRes} FeeRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.FeeRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.order.FeeRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a FeeRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof order.FeeRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {order.FeeRes} FeeRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeRes message.
         * @function verify
         * @memberof order.FeeRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.order.FeeRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a FeeRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof order.FeeRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {order.FeeRes} FeeRes
         */
        FeeRes.fromObject = function fromObject(object) {
            if (object instanceof $root.order.FeeRes)
                return object;
            let message = new $root.order.FeeRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".order.FeeRes.s2c: object expected");
                message.s2c = $root.order.FeeRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeeRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof order.FeeRes
         * @static
         * @param {order.FeeRes} message FeeRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.order.FeeRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this FeeRes to JSON.
         * @function toJSON
         * @memberof order.FeeRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FeeRes
         * @function getTypeUrl
         * @memberof order.FeeRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/order.FeeRes";
        };

        FeeRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof order.FeeRes
             * @interface IS2C
             * @property {common.ITrdHeader} header S2C header
             * @property {Array.<common.IOrderFee>|null} [orderFeeList] S2C orderFeeList
             */

            /**
             * Constructs a new S2C.
             * @memberof order.FeeRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {order.FeeRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.orderFeeList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C header.
             * @member {common.ITrdHeader} header
             * @memberof order.FeeRes.S2C
             * @instance
             */
            S2C.prototype.header = null;

            /**
             * S2C orderFeeList.
             * @member {Array.<common.IOrderFee>} orderFeeList
             * @memberof order.FeeRes.S2C
             * @instance
             */
            S2C.prototype.orderFeeList = $util.emptyArray;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof order.FeeRes.S2C
             * @static
             * @param {order.FeeRes.IS2C=} [properties] Properties to set
             * @returns {order.FeeRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link order.FeeRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof order.FeeRes.S2C
             * @static
             * @param {order.FeeRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orderFeeList != null && message.orderFeeList.length)
                    for (let i = 0; i < message.orderFeeList.length; ++i)
                        $root.common.OrderFee.encode(message.orderFeeList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link order.FeeRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof order.FeeRes.S2C
             * @static
             * @param {order.FeeRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof order.FeeRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {order.FeeRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.order.FeeRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.common.TrdHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.orderFeeList && message.orderFeeList.length))
                                message.orderFeeList = [];
                            message.orderFeeList.push($root.common.OrderFee.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("header"))
                    throw $util.ProtocolError("missing required 'header'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof order.FeeRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {order.FeeRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof order.FeeRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    let error = $root.common.TrdHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.orderFeeList != null && message.hasOwnProperty("orderFeeList")) {
                    if (!Array.isArray(message.orderFeeList))
                        return "orderFeeList: array expected";
                    for (let i = 0; i < message.orderFeeList.length; ++i) {
                        let error = $root.common.OrderFee.verify(message.orderFeeList[i]);
                        if (error)
                            return "orderFeeList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof order.FeeRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {order.FeeRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.order.FeeRes.S2C)
                    return object;
                let message = new $root.order.FeeRes.S2C();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".order.FeeRes.S2C.header: object expected");
                    message.header = $root.common.TrdHeader.fromObject(object.header);
                }
                if (object.orderFeeList) {
                    if (!Array.isArray(object.orderFeeList))
                        throw TypeError(".order.FeeRes.S2C.orderFeeList: array expected");
                    message.orderFeeList = [];
                    for (let i = 0; i < object.orderFeeList.length; ++i) {
                        if (typeof object.orderFeeList[i] !== "object")
                            throw TypeError(".order.FeeRes.S2C.orderFeeList: object expected");
                        message.orderFeeList[i] = $root.common.OrderFee.fromObject(object.orderFeeList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof order.FeeRes.S2C
             * @static
             * @param {order.FeeRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.orderFeeList = [];
                if (options.defaults)
                    object.header = null;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.TrdHeader.toObject(message.header, options);
                if (message.orderFeeList && message.orderFeeList.length) {
                    object.orderFeeList = [];
                    for (let j = 0; j < message.orderFeeList.length; ++j)
                        object.orderFeeList[j] = $root.common.OrderFee.toObject(message.orderFeeList[j], options);
                }
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof order.FeeRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof order.FeeRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/order.FeeRes.S2C";
            };

            return S2C;
        })();

        return FeeRes;
    })();

    return order;
})();

export const sub = $root.sub = (() => {

    /**
     * Namespace sub.
     * @exports sub
     * @namespace
     */
    const sub = {};

    sub.ToggleReq = (function() {

        /**
         * Properties of a ToggleReq.
         * @memberof sub
         * @interface IToggleReq
         * @property {sub.ToggleReq.IC2S} c2s ToggleReq c2s
         */

        /**
         * Constructs a new ToggleReq.
         * @memberof sub
         * @classdesc 订阅 or 取消订阅请求
         * @implements IToggleReq
         * @constructor
         * @param {sub.IToggleReq=} [properties] Properties to set
         */
        function ToggleReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ToggleReq c2s.
         * @member {sub.ToggleReq.IC2S} c2s
         * @memberof sub.ToggleReq
         * @instance
         */
        ToggleReq.prototype.c2s = null;

        /**
         * Creates a new ToggleReq instance using the specified properties.
         * @function create
         * @memberof sub.ToggleReq
         * @static
         * @param {sub.IToggleReq=} [properties] Properties to set
         * @returns {sub.ToggleReq} ToggleReq instance
         */
        ToggleReq.create = function create(properties) {
            return new ToggleReq(properties);
        };

        /**
         * Encodes the specified ToggleReq message. Does not implicitly {@link sub.ToggleReq.verify|verify} messages.
         * @function encode
         * @memberof sub.ToggleReq
         * @static
         * @param {sub.IToggleReq} message ToggleReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToggleReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.sub.ToggleReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ToggleReq message, length delimited. Does not implicitly {@link sub.ToggleReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sub.ToggleReq
         * @static
         * @param {sub.IToggleReq} message ToggleReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToggleReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ToggleReq message from the specified reader or buffer.
         * @function decode
         * @memberof sub.ToggleReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sub.ToggleReq} ToggleReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToggleReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.ToggleReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.sub.ToggleReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a ToggleReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sub.ToggleReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sub.ToggleReq} ToggleReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToggleReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ToggleReq message.
         * @function verify
         * @memberof sub.ToggleReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ToggleReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.sub.ToggleReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a ToggleReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sub.ToggleReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sub.ToggleReq} ToggleReq
         */
        ToggleReq.fromObject = function fromObject(object) {
            if (object instanceof $root.sub.ToggleReq)
                return object;
            let message = new $root.sub.ToggleReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".sub.ToggleReq.c2s: object expected");
                message.c2s = $root.sub.ToggleReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a ToggleReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sub.ToggleReq
         * @static
         * @param {sub.ToggleReq} message ToggleReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ToggleReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.sub.ToggleReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this ToggleReq to JSON.
         * @function toJSON
         * @memberof sub.ToggleReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ToggleReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ToggleReq
         * @function getTypeUrl
         * @memberof sub.ToggleReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ToggleReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/sub.ToggleReq";
        };

        ToggleReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof sub.ToggleReq
             * @interface IC2S
             * @property {Array.<common.ISecurity>|null} [securityList] C2S securityList
             * @property {Array.<common.SubType>|null} [subTypeList] C2S subTypeList
             * @property {boolean} isSubOrUnSub C2S isSubOrUnSub
             * @property {boolean|null} [isRegOrUnRegPush] C2S isRegOrUnRegPush
             * @property {Array.<number>|null} [regPushRehabTypeList] C2S regPushRehabTypeList
             * @property {boolean|null} [isFirstPush] C2S isFirstPush
             * @property {boolean|null} [isUnsubAll] C2S isUnsubAll
             * @property {boolean|null} [isSubOrderBookDetail] C2S isSubOrderBookDetail
             * @property {boolean|null} [extendedTime] C2S extendedTime
             */

            /**
             * Constructs a new C2S.
             * @memberof sub.ToggleReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {sub.ToggleReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                this.securityList = [];
                this.subTypeList = [];
                this.regPushRehabTypeList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S securityList.
             * @member {Array.<common.ISecurity>} securityList
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.securityList = $util.emptyArray;

            /**
             * C2S subTypeList.
             * @member {Array.<common.SubType>} subTypeList
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.subTypeList = $util.emptyArray;

            /**
             * C2S isSubOrUnSub.
             * @member {boolean} isSubOrUnSub
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.isSubOrUnSub = false;

            /**
             * C2S isRegOrUnRegPush.
             * @member {boolean} isRegOrUnRegPush
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.isRegOrUnRegPush = false;

            /**
             * C2S regPushRehabTypeList.
             * @member {Array.<number>} regPushRehabTypeList
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.regPushRehabTypeList = $util.emptyArray;

            /**
             * C2S isFirstPush.
             * @member {boolean} isFirstPush
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.isFirstPush = false;

            /**
             * C2S isUnsubAll.
             * @member {boolean} isUnsubAll
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.isUnsubAll = false;

            /**
             * C2S isSubOrderBookDetail.
             * @member {boolean} isSubOrderBookDetail
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.isSubOrderBookDetail = false;

            /**
             * C2S extendedTime.
             * @member {boolean} extendedTime
             * @memberof sub.ToggleReq.C2S
             * @instance
             */
            C2S.prototype.extendedTime = false;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {sub.ToggleReq.IC2S=} [properties] Properties to set
             * @returns {sub.ToggleReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link sub.ToggleReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {sub.ToggleReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.securityList != null && message.securityList.length)
                    for (let i = 0; i < message.securityList.length; ++i)
                        $root.common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.subTypeList != null && message.subTypeList.length)
                    for (let i = 0; i < message.subTypeList.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.subTypeList[i]);
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSubOrUnSub);
                if (message.isRegOrUnRegPush != null && Object.hasOwnProperty.call(message, "isRegOrUnRegPush"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isRegOrUnRegPush);
                if (message.regPushRehabTypeList != null && message.regPushRehabTypeList.length)
                    for (let i = 0; i < message.regPushRehabTypeList.length; ++i)
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.regPushRehabTypeList[i]);
                if (message.isFirstPush != null && Object.hasOwnProperty.call(message, "isFirstPush"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isFirstPush);
                if (message.isUnsubAll != null && Object.hasOwnProperty.call(message, "isUnsubAll"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isUnsubAll);
                if (message.isSubOrderBookDetail != null && Object.hasOwnProperty.call(message, "isSubOrderBookDetail"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.isSubOrderBookDetail);
                if (message.extendedTime != null && Object.hasOwnProperty.call(message, "extendedTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.extendedTime);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link sub.ToggleReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {sub.ToggleReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {sub.ToggleReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.ToggleReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.securityList && message.securityList.length))
                                message.securityList = [];
                            message.securityList.push($root.common.Security.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.subTypeList && message.subTypeList.length))
                                message.subTypeList = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.subTypeList.push(reader.int32());
                            } else
                                message.subTypeList.push(reader.int32());
                            break;
                        }
                    case 3: {
                            message.isSubOrUnSub = reader.bool();
                            break;
                        }
                    case 4: {
                            message.isRegOrUnRegPush = reader.bool();
                            break;
                        }
                    case 5: {
                            if (!(message.regPushRehabTypeList && message.regPushRehabTypeList.length))
                                message.regPushRehabTypeList = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.regPushRehabTypeList.push(reader.int32());
                            } else
                                message.regPushRehabTypeList.push(reader.int32());
                            break;
                        }
                    case 6: {
                            message.isFirstPush = reader.bool();
                            break;
                        }
                    case 7: {
                            message.isUnsubAll = reader.bool();
                            break;
                        }
                    case 8: {
                            message.isSubOrderBookDetail = reader.bool();
                            break;
                        }
                    case 9: {
                            message.extendedTime = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("isSubOrUnSub"))
                    throw $util.ProtocolError("missing required 'isSubOrUnSub'", { instance: message });
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {sub.ToggleReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.securityList != null && message.hasOwnProperty("securityList")) {
                    if (!Array.isArray(message.securityList))
                        return "securityList: array expected";
                    for (let i = 0; i < message.securityList.length; ++i) {
                        let error = $root.common.Security.verify(message.securityList[i]);
                        if (error)
                            return "securityList." + error;
                    }
                }
                if (message.subTypeList != null && message.hasOwnProperty("subTypeList")) {
                    if (!Array.isArray(message.subTypeList))
                        return "subTypeList: array expected";
                    for (let i = 0; i < message.subTypeList.length; ++i)
                        switch (message.subTypeList[i]) {
                        default:
                            return "subTypeList: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                            break;
                        }
                }
                if (typeof message.isSubOrUnSub !== "boolean")
                    return "isSubOrUnSub: boolean expected";
                if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                    if (typeof message.isRegOrUnRegPush !== "boolean")
                        return "isRegOrUnRegPush: boolean expected";
                if (message.regPushRehabTypeList != null && message.hasOwnProperty("regPushRehabTypeList")) {
                    if (!Array.isArray(message.regPushRehabTypeList))
                        return "regPushRehabTypeList: array expected";
                    for (let i = 0; i < message.regPushRehabTypeList.length; ++i)
                        if (!$util.isInteger(message.regPushRehabTypeList[i]))
                            return "regPushRehabTypeList: integer[] expected";
                }
                if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                    if (typeof message.isFirstPush !== "boolean")
                        return "isFirstPush: boolean expected";
                if (message.isUnsubAll != null && message.hasOwnProperty("isUnsubAll"))
                    if (typeof message.isUnsubAll !== "boolean")
                        return "isUnsubAll: boolean expected";
                if (message.isSubOrderBookDetail != null && message.hasOwnProperty("isSubOrderBookDetail"))
                    if (typeof message.isSubOrderBookDetail !== "boolean")
                        return "isSubOrderBookDetail: boolean expected";
                if (message.extendedTime != null && message.hasOwnProperty("extendedTime"))
                    if (typeof message.extendedTime !== "boolean")
                        return "extendedTime: boolean expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {sub.ToggleReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.sub.ToggleReq.C2S)
                    return object;
                let message = new $root.sub.ToggleReq.C2S();
                if (object.securityList) {
                    if (!Array.isArray(object.securityList))
                        throw TypeError(".sub.ToggleReq.C2S.securityList: array expected");
                    message.securityList = [];
                    for (let i = 0; i < object.securityList.length; ++i) {
                        if (typeof object.securityList[i] !== "object")
                            throw TypeError(".sub.ToggleReq.C2S.securityList: object expected");
                        message.securityList[i] = $root.common.Security.fromObject(object.securityList[i]);
                    }
                }
                if (object.subTypeList) {
                    if (!Array.isArray(object.subTypeList))
                        throw TypeError(".sub.ToggleReq.C2S.subTypeList: array expected");
                    message.subTypeList = [];
                    for (let i = 0; i < object.subTypeList.length; ++i)
                        switch (object.subTypeList[i]) {
                        default:
                            if (typeof object.subTypeList[i] === "number") {
                                message.subTypeList[i] = object.subTypeList[i];
                                break;
                            }
                        case "SubType_None":
                        case 0:
                            message.subTypeList[i] = 0;
                            break;
                        case "SubType_Basic":
                        case 1:
                            message.subTypeList[i] = 1;
                            break;
                        case "SubType_OrderBook":
                        case 2:
                            message.subTypeList[i] = 2;
                            break;
                        case "SubType_Ticker":
                        case 4:
                            message.subTypeList[i] = 4;
                            break;
                        case "SubType_RT":
                        case 5:
                            message.subTypeList[i] = 5;
                            break;
                        case "SubType_KL_Day":
                        case 6:
                            message.subTypeList[i] = 6;
                            break;
                        case "SubType_KL_5Min":
                        case 7:
                            message.subTypeList[i] = 7;
                            break;
                        case "SubType_KL_15Min":
                        case 8:
                            message.subTypeList[i] = 8;
                            break;
                        case "SubType_KL_30Min":
                        case 9:
                            message.subTypeList[i] = 9;
                            break;
                        case "SubType_KL_60Min":
                        case 10:
                            message.subTypeList[i] = 10;
                            break;
                        case "SubType_KL_1Min":
                        case 11:
                            message.subTypeList[i] = 11;
                            break;
                        case "SubType_KL_Week":
                        case 12:
                            message.subTypeList[i] = 12;
                            break;
                        case "SubType_KL_Month":
                        case 13:
                            message.subTypeList[i] = 13;
                            break;
                        case "SubType_Broker":
                        case 14:
                            message.subTypeList[i] = 14;
                            break;
                        case "SubType_KL_Qurater":
                        case 15:
                            message.subTypeList[i] = 15;
                            break;
                        case "SubType_KL_Year":
                        case 16:
                            message.subTypeList[i] = 16;
                            break;
                        case "SubType_KL_3Min":
                        case 17:
                            message.subTypeList[i] = 17;
                            break;
                        }
                }
                if (object.isSubOrUnSub != null)
                    message.isSubOrUnSub = Boolean(object.isSubOrUnSub);
                if (object.isRegOrUnRegPush != null)
                    message.isRegOrUnRegPush = Boolean(object.isRegOrUnRegPush);
                if (object.regPushRehabTypeList) {
                    if (!Array.isArray(object.regPushRehabTypeList))
                        throw TypeError(".sub.ToggleReq.C2S.regPushRehabTypeList: array expected");
                    message.regPushRehabTypeList = [];
                    for (let i = 0; i < object.regPushRehabTypeList.length; ++i)
                        message.regPushRehabTypeList[i] = object.regPushRehabTypeList[i] | 0;
                }
                if (object.isFirstPush != null)
                    message.isFirstPush = Boolean(object.isFirstPush);
                if (object.isUnsubAll != null)
                    message.isUnsubAll = Boolean(object.isUnsubAll);
                if (object.isSubOrderBookDetail != null)
                    message.isSubOrderBookDetail = Boolean(object.isSubOrderBookDetail);
                if (object.extendedTime != null)
                    message.extendedTime = Boolean(object.extendedTime);
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {sub.ToggleReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.securityList = [];
                    object.subTypeList = [];
                    object.regPushRehabTypeList = [];
                }
                if (options.defaults) {
                    object.isSubOrUnSub = false;
                    object.isRegOrUnRegPush = false;
                    object.isFirstPush = false;
                    object.isUnsubAll = false;
                    object.isSubOrderBookDetail = false;
                    object.extendedTime = false;
                }
                if (message.securityList && message.securityList.length) {
                    object.securityList = [];
                    for (let j = 0; j < message.securityList.length; ++j)
                        object.securityList[j] = $root.common.Security.toObject(message.securityList[j], options);
                }
                if (message.subTypeList && message.subTypeList.length) {
                    object.subTypeList = [];
                    for (let j = 0; j < message.subTypeList.length; ++j)
                        object.subTypeList[j] = options.enums === String ? $root.common.SubType[message.subTypeList[j]] === undefined ? message.subTypeList[j] : $root.common.SubType[message.subTypeList[j]] : message.subTypeList[j];
                }
                if (message.isSubOrUnSub != null && message.hasOwnProperty("isSubOrUnSub"))
                    object.isSubOrUnSub = message.isSubOrUnSub;
                if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                    object.isRegOrUnRegPush = message.isRegOrUnRegPush;
                if (message.regPushRehabTypeList && message.regPushRehabTypeList.length) {
                    object.regPushRehabTypeList = [];
                    for (let j = 0; j < message.regPushRehabTypeList.length; ++j)
                        object.regPushRehabTypeList[j] = message.regPushRehabTypeList[j];
                }
                if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                    object.isFirstPush = message.isFirstPush;
                if (message.isUnsubAll != null && message.hasOwnProperty("isUnsubAll"))
                    object.isUnsubAll = message.isUnsubAll;
                if (message.isSubOrderBookDetail != null && message.hasOwnProperty("isSubOrderBookDetail"))
                    object.isSubOrderBookDetail = message.isSubOrderBookDetail;
                if (message.extendedTime != null && message.hasOwnProperty("extendedTime"))
                    object.extendedTime = message.extendedTime;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof sub.ToggleReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof sub.ToggleReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/sub.ToggleReq.C2S";
            };

            return C2S;
        })();

        return ToggleReq;
    })();

    sub.ToggleRes = (function() {

        /**
         * Properties of a ToggleRes.
         * @memberof sub
         * @interface IToggleRes
         * @property {number} retType ToggleRes retType
         * @property {string|null} [retMsg] ToggleRes retMsg
         * @property {number|null} [errCode] ToggleRes errCode
         */

        /**
         * Constructs a new ToggleRes.
         * @memberof sub
         * @classdesc 订阅 or 取消订阅响应
         * @implements IToggleRes
         * @constructor
         * @param {sub.IToggleRes=} [properties] Properties to set
         */
        function ToggleRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ToggleRes retType.
         * @member {number} retType
         * @memberof sub.ToggleRes
         * @instance
         */
        ToggleRes.prototype.retType = -400;

        /**
         * ToggleRes retMsg.
         * @member {string} retMsg
         * @memberof sub.ToggleRes
         * @instance
         */
        ToggleRes.prototype.retMsg = "";

        /**
         * ToggleRes errCode.
         * @member {number} errCode
         * @memberof sub.ToggleRes
         * @instance
         */
        ToggleRes.prototype.errCode = 0;

        /**
         * Creates a new ToggleRes instance using the specified properties.
         * @function create
         * @memberof sub.ToggleRes
         * @static
         * @param {sub.IToggleRes=} [properties] Properties to set
         * @returns {sub.ToggleRes} ToggleRes instance
         */
        ToggleRes.create = function create(properties) {
            return new ToggleRes(properties);
        };

        /**
         * Encodes the specified ToggleRes message. Does not implicitly {@link sub.ToggleRes.verify|verify} messages.
         * @function encode
         * @memberof sub.ToggleRes
         * @static
         * @param {sub.IToggleRes} message ToggleRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToggleRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            return writer;
        };

        /**
         * Encodes the specified ToggleRes message, length delimited. Does not implicitly {@link sub.ToggleRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sub.ToggleRes
         * @static
         * @param {sub.IToggleRes} message ToggleRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToggleRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ToggleRes message from the specified reader or buffer.
         * @function decode
         * @memberof sub.ToggleRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sub.ToggleRes} ToggleRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToggleRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.ToggleRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a ToggleRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sub.ToggleRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sub.ToggleRes} ToggleRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToggleRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ToggleRes message.
         * @function verify
         * @memberof sub.ToggleRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ToggleRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            return null;
        };

        /**
         * Creates a ToggleRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sub.ToggleRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sub.ToggleRes} ToggleRes
         */
        ToggleRes.fromObject = function fromObject(object) {
            if (object instanceof $root.sub.ToggleRes)
                return object;
            let message = new $root.sub.ToggleRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            return message;
        };

        /**
         * Creates a plain object from a ToggleRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sub.ToggleRes
         * @static
         * @param {sub.ToggleRes} message ToggleRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ToggleRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            return object;
        };

        /**
         * Converts this ToggleRes to JSON.
         * @function toJSON
         * @memberof sub.ToggleRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ToggleRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ToggleRes
         * @function getTypeUrl
         * @memberof sub.ToggleRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ToggleRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/sub.ToggleRes";
        };

        return ToggleRes;
    })();

    sub.AccReq = (function() {

        /**
         * Properties of an AccReq.
         * @memberof sub
         * @interface IAccReq
         * @property {sub.AccReq.IC2S} c2s AccReq c2s
         */

        /**
         * Constructs a new AccReq.
         * @memberof sub
         * @classdesc 订阅交易推送请求
         * @implements IAccReq
         * @constructor
         * @param {sub.IAccReq=} [properties] Properties to set
         */
        function AccReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccReq c2s.
         * @member {sub.AccReq.IC2S} c2s
         * @memberof sub.AccReq
         * @instance
         */
        AccReq.prototype.c2s = null;

        /**
         * Creates a new AccReq instance using the specified properties.
         * @function create
         * @memberof sub.AccReq
         * @static
         * @param {sub.IAccReq=} [properties] Properties to set
         * @returns {sub.AccReq} AccReq instance
         */
        AccReq.create = function create(properties) {
            return new AccReq(properties);
        };

        /**
         * Encodes the specified AccReq message. Does not implicitly {@link sub.AccReq.verify|verify} messages.
         * @function encode
         * @memberof sub.AccReq
         * @static
         * @param {sub.IAccReq} message AccReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.sub.AccReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccReq message, length delimited. Does not implicitly {@link sub.AccReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sub.AccReq
         * @static
         * @param {sub.IAccReq} message AccReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccReq message from the specified reader or buffer.
         * @function decode
         * @memberof sub.AccReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sub.AccReq} AccReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.AccReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.sub.AccReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes an AccReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sub.AccReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sub.AccReq} AccReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccReq message.
         * @function verify
         * @memberof sub.AccReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.sub.AccReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates an AccReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sub.AccReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sub.AccReq} AccReq
         */
        AccReq.fromObject = function fromObject(object) {
            if (object instanceof $root.sub.AccReq)
                return object;
            let message = new $root.sub.AccReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".sub.AccReq.c2s: object expected");
                message.c2s = $root.sub.AccReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sub.AccReq
         * @static
         * @param {sub.AccReq} message AccReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.sub.AccReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this AccReq to JSON.
         * @function toJSON
         * @memberof sub.AccReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccReq
         * @function getTypeUrl
         * @memberof sub.AccReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/sub.AccReq";
        };

        AccReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof sub.AccReq
             * @interface IC2S
             * @property {Array.<number|Long>|null} [accIDList] C2S accIDList
             */

            /**
             * Constructs a new C2S.
             * @memberof sub.AccReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {sub.AccReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                this.accIDList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2S accIDList.
             * @member {Array.<number|Long>} accIDList
             * @memberof sub.AccReq.C2S
             * @instance
             */
            C2S.prototype.accIDList = $util.emptyArray;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof sub.AccReq.C2S
             * @static
             * @param {sub.AccReq.IC2S=} [properties] Properties to set
             * @returns {sub.AccReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link sub.AccReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof sub.AccReq.C2S
             * @static
             * @param {sub.AccReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accIDList != null && message.accIDList.length)
                    for (let i = 0; i < message.accIDList.length; ++i)
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.accIDList[i]);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link sub.AccReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof sub.AccReq.C2S
             * @static
             * @param {sub.AccReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof sub.AccReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {sub.AccReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.AccReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.accIDList && message.accIDList.length))
                                message.accIDList = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.accIDList.push(reader.uint64());
                            } else
                                message.accIDList.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof sub.AccReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {sub.AccReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof sub.AccReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accIDList != null && message.hasOwnProperty("accIDList")) {
                    if (!Array.isArray(message.accIDList))
                        return "accIDList: array expected";
                    for (let i = 0; i < message.accIDList.length; ++i)
                        if (!$util.isInteger(message.accIDList[i]) && !(message.accIDList[i] && $util.isInteger(message.accIDList[i].low) && $util.isInteger(message.accIDList[i].high)))
                            return "accIDList: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof sub.AccReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {sub.AccReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.sub.AccReq.C2S)
                    return object;
                let message = new $root.sub.AccReq.C2S();
                if (object.accIDList) {
                    if (!Array.isArray(object.accIDList))
                        throw TypeError(".sub.AccReq.C2S.accIDList: array expected");
                    message.accIDList = [];
                    for (let i = 0; i < object.accIDList.length; ++i)
                        if ($util.Long)
                            (message.accIDList[i] = $util.Long.fromValue(object.accIDList[i])).unsigned = true;
                        else if (typeof object.accIDList[i] === "string")
                            message.accIDList[i] = parseInt(object.accIDList[i], 10);
                        else if (typeof object.accIDList[i] === "number")
                            message.accIDList[i] = object.accIDList[i];
                        else if (typeof object.accIDList[i] === "object")
                            message.accIDList[i] = new $util.LongBits(object.accIDList[i].low >>> 0, object.accIDList[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof sub.AccReq.C2S
             * @static
             * @param {sub.AccReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.accIDList = [];
                if (message.accIDList && message.accIDList.length) {
                    object.accIDList = [];
                    for (let j = 0; j < message.accIDList.length; ++j)
                        if (typeof message.accIDList[j] === "number")
                            object.accIDList[j] = options.longs === String ? String(message.accIDList[j]) : message.accIDList[j];
                        else
                            object.accIDList[j] = options.longs === String ? $util.Long.prototype.toString.call(message.accIDList[j]) : options.longs === Number ? new $util.LongBits(message.accIDList[j].low >>> 0, message.accIDList[j].high >>> 0).toNumber(true) : message.accIDList[j];
                }
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof sub.AccReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof sub.AccReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/sub.AccReq.C2S";
            };

            return C2S;
        })();

        return AccReq;
    })();

    sub.AccRes = (function() {

        /**
         * Properties of an AccRes.
         * @memberof sub
         * @interface IAccRes
         * @property {number} retType AccRes retType
         * @property {string|null} [retMsg] AccRes retMsg
         * @property {number|null} [errCode] AccRes errCode
         * @property {sub.AccRes.IS2C|null} [s2c] AccRes s2c
         */

        /**
         * Constructs a new AccRes.
         * @memberof sub
         * @classdesc 订阅交易推送响应
         * @implements IAccRes
         * @constructor
         * @param {sub.IAccRes=} [properties] Properties to set
         */
        function AccRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccRes retType.
         * @member {number} retType
         * @memberof sub.AccRes
         * @instance
         */
        AccRes.prototype.retType = -400;

        /**
         * AccRes retMsg.
         * @member {string} retMsg
         * @memberof sub.AccRes
         * @instance
         */
        AccRes.prototype.retMsg = "";

        /**
         * AccRes errCode.
         * @member {number} errCode
         * @memberof sub.AccRes
         * @instance
         */
        AccRes.prototype.errCode = 0;

        /**
         * AccRes s2c.
         * @member {sub.AccRes.IS2C|null|undefined} s2c
         * @memberof sub.AccRes
         * @instance
         */
        AccRes.prototype.s2c = null;

        /**
         * Creates a new AccRes instance using the specified properties.
         * @function create
         * @memberof sub.AccRes
         * @static
         * @param {sub.IAccRes=} [properties] Properties to set
         * @returns {sub.AccRes} AccRes instance
         */
        AccRes.create = function create(properties) {
            return new AccRes(properties);
        };

        /**
         * Encodes the specified AccRes message. Does not implicitly {@link sub.AccRes.verify|verify} messages.
         * @function encode
         * @memberof sub.AccRes
         * @static
         * @param {sub.IAccRes} message AccRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.sub.AccRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccRes message, length delimited. Does not implicitly {@link sub.AccRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sub.AccRes
         * @static
         * @param {sub.IAccRes} message AccRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccRes message from the specified reader or buffer.
         * @function decode
         * @memberof sub.AccRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sub.AccRes} AccRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.AccRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.sub.AccRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes an AccRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sub.AccRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sub.AccRes} AccRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccRes message.
         * @function verify
         * @memberof sub.AccRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.sub.AccRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates an AccRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sub.AccRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sub.AccRes} AccRes
         */
        AccRes.fromObject = function fromObject(object) {
            if (object instanceof $root.sub.AccRes)
                return object;
            let message = new $root.sub.AccRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".sub.AccRes.s2c: object expected");
                message.s2c = $root.sub.AccRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sub.AccRes
         * @static
         * @param {sub.AccRes} message AccRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.sub.AccRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this AccRes to JSON.
         * @function toJSON
         * @memberof sub.AccRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccRes
         * @function getTypeUrl
         * @memberof sub.AccRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/sub.AccRes";
        };

        AccRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof sub.AccRes
             * @interface IS2C
             */

            /**
             * Constructs a new S2C.
             * @memberof sub.AccRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {sub.AccRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof sub.AccRes.S2C
             * @static
             * @param {sub.AccRes.IS2C=} [properties] Properties to set
             * @returns {sub.AccRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link sub.AccRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof sub.AccRes.S2C
             * @static
             * @param {sub.AccRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link sub.AccRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof sub.AccRes.S2C
             * @static
             * @param {sub.AccRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof sub.AccRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {sub.AccRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.AccRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof sub.AccRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {sub.AccRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof sub.AccRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof sub.AccRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {sub.AccRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.sub.AccRes.S2C)
                    return object;
                return new $root.sub.AccRes.S2C();
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof sub.AccRes.S2C
             * @static
             * @param {sub.AccRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof sub.AccRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof sub.AccRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/sub.AccRes.S2C";
            };

            return S2C;
        })();

        return AccRes;
    })();

    sub.InfoRes = (function() {

        /**
         * Properties of an InfoRes.
         * @memberof sub
         * @interface IInfoRes
         * @property {number} retType InfoRes retType
         * @property {string|null} [retMsg] InfoRes retMsg
         * @property {number|null} [errCode] InfoRes errCode
         * @property {sub.InfoRes.IS2C|null} [s2c] InfoRes s2c
         */

        /**
         * Constructs a new InfoRes.
         * @memberof sub
         * @classdesc 获取订阅信息响应
         * @implements IInfoRes
         * @constructor
         * @param {sub.IInfoRes=} [properties] Properties to set
         */
        function InfoRes(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InfoRes retType.
         * @member {number} retType
         * @memberof sub.InfoRes
         * @instance
         */
        InfoRes.prototype.retType = 0;

        /**
         * InfoRes retMsg.
         * @member {string} retMsg
         * @memberof sub.InfoRes
         * @instance
         */
        InfoRes.prototype.retMsg = "";

        /**
         * InfoRes errCode.
         * @member {number} errCode
         * @memberof sub.InfoRes
         * @instance
         */
        InfoRes.prototype.errCode = 0;

        /**
         * InfoRes s2c.
         * @member {sub.InfoRes.IS2C|null|undefined} s2c
         * @memberof sub.InfoRes
         * @instance
         */
        InfoRes.prototype.s2c = null;

        /**
         * Creates a new InfoRes instance using the specified properties.
         * @function create
         * @memberof sub.InfoRes
         * @static
         * @param {sub.IInfoRes=} [properties] Properties to set
         * @returns {sub.InfoRes} InfoRes instance
         */
        InfoRes.create = function create(properties) {
            return new InfoRes(properties);
        };

        /**
         * Encodes the specified InfoRes message. Does not implicitly {@link sub.InfoRes.verify|verify} messages.
         * @function encode
         * @memberof sub.InfoRes
         * @static
         * @param {sub.IInfoRes} message InfoRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoRes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && Object.hasOwnProperty.call(message, "retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && Object.hasOwnProperty.call(message, "errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && Object.hasOwnProperty.call(message, "s2c"))
                $root.sub.InfoRes.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InfoRes message, length delimited. Does not implicitly {@link sub.InfoRes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sub.InfoRes
         * @static
         * @param {sub.IInfoRes} message InfoRes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoRes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InfoRes message from the specified reader or buffer.
         * @function decode
         * @memberof sub.InfoRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sub.InfoRes} InfoRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoRes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.InfoRes();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retType = reader.int32();
                        break;
                    }
                case 2: {
                        message.retMsg = reader.string();
                        break;
                    }
                case 3: {
                        message.errCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.s2c = $root.sub.InfoRes.S2C.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes an InfoRes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sub.InfoRes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sub.InfoRes} InfoRes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoRes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InfoRes message.
         * @function verify
         * @memberof sub.InfoRes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InfoRes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                let error = $root.sub.InfoRes.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates an InfoRes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sub.InfoRes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sub.InfoRes} InfoRes
         */
        InfoRes.fromObject = function fromObject(object) {
            if (object instanceof $root.sub.InfoRes)
                return object;
            let message = new $root.sub.InfoRes();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".sub.InfoRes.s2c: object expected");
                message.s2c = $root.sub.InfoRes.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from an InfoRes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sub.InfoRes
         * @static
         * @param {sub.InfoRes} message InfoRes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InfoRes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.retType = 0;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.sub.InfoRes.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this InfoRes to JSON.
         * @function toJSON
         * @memberof sub.InfoRes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InfoRes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InfoRes
         * @function getTypeUrl
         * @memberof sub.InfoRes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InfoRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/sub.InfoRes";
        };

        InfoRes.S2C = (function() {

            /**
             * Properties of a S2C.
             * @memberof sub.InfoRes
             * @interface IS2C
             * @property {Array.<common.IConnSubInfo>|null} [connSubInfoList] S2C connSubInfoList
             * @property {number} totalUsedQuota S2C totalUsedQuota
             * @property {number} remainQuota S2C remainQuota
             */

            /**
             * Constructs a new S2C.
             * @memberof sub.InfoRes
             * @classdesc Represents a S2C.
             * @implements IS2C
             * @constructor
             * @param {sub.InfoRes.IS2C=} [properties] Properties to set
             */
            function S2C(properties) {
                this.connSubInfoList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * S2C connSubInfoList.
             * @member {Array.<common.IConnSubInfo>} connSubInfoList
             * @memberof sub.InfoRes.S2C
             * @instance
             */
            S2C.prototype.connSubInfoList = $util.emptyArray;

            /**
             * S2C totalUsedQuota.
             * @member {number} totalUsedQuota
             * @memberof sub.InfoRes.S2C
             * @instance
             */
            S2C.prototype.totalUsedQuota = 0;

            /**
             * S2C remainQuota.
             * @member {number} remainQuota
             * @memberof sub.InfoRes.S2C
             * @instance
             */
            S2C.prototype.remainQuota = 0;

            /**
             * Creates a new S2C instance using the specified properties.
             * @function create
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {sub.InfoRes.IS2C=} [properties] Properties to set
             * @returns {sub.InfoRes.S2C} S2C instance
             */
            S2C.create = function create(properties) {
                return new S2C(properties);
            };

            /**
             * Encodes the specified S2C message. Does not implicitly {@link sub.InfoRes.S2C.verify|verify} messages.
             * @function encode
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {sub.InfoRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connSubInfoList != null && message.connSubInfoList.length)
                    for (let i = 0; i < message.connSubInfoList.length; ++i)
                        $root.common.ConnSubInfo.encode(message.connSubInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.totalUsedQuota);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.remainQuota);
                return writer;
            };

            /**
             * Encodes the specified S2C message, length delimited. Does not implicitly {@link sub.InfoRes.S2C.verify|verify} messages.
             * @function encodeDelimited
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {sub.InfoRes.IS2C} message S2C message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            S2C.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a S2C message from the specified reader or buffer.
             * @function decode
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {sub.InfoRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.InfoRes.S2C();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.connSubInfoList && message.connSubInfoList.length))
                                message.connSubInfoList = [];
                            message.connSubInfoList.push($root.common.ConnSubInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.totalUsedQuota = reader.int32();
                            break;
                        }
                    case 3: {
                            message.remainQuota = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("totalUsedQuota"))
                    throw $util.ProtocolError("missing required 'totalUsedQuota'", { instance: message });
                if (!message.hasOwnProperty("remainQuota"))
                    throw $util.ProtocolError("missing required 'remainQuota'", { instance: message });
                return message;
            };

            /**
             * Decodes a S2C message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {sub.InfoRes.S2C} S2C
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            S2C.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a S2C message.
             * @function verify
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            S2C.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connSubInfoList != null && message.hasOwnProperty("connSubInfoList")) {
                    if (!Array.isArray(message.connSubInfoList))
                        return "connSubInfoList: array expected";
                    for (let i = 0; i < message.connSubInfoList.length; ++i) {
                        let error = $root.common.ConnSubInfo.verify(message.connSubInfoList[i]);
                        if (error)
                            return "connSubInfoList." + error;
                    }
                }
                if (!$util.isInteger(message.totalUsedQuota))
                    return "totalUsedQuota: integer expected";
                if (!$util.isInteger(message.remainQuota))
                    return "remainQuota: integer expected";
                return null;
            };

            /**
             * Creates a S2C message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {sub.InfoRes.S2C} S2C
             */
            S2C.fromObject = function fromObject(object) {
                if (object instanceof $root.sub.InfoRes.S2C)
                    return object;
                let message = new $root.sub.InfoRes.S2C();
                if (object.connSubInfoList) {
                    if (!Array.isArray(object.connSubInfoList))
                        throw TypeError(".sub.InfoRes.S2C.connSubInfoList: array expected");
                    message.connSubInfoList = [];
                    for (let i = 0; i < object.connSubInfoList.length; ++i) {
                        if (typeof object.connSubInfoList[i] !== "object")
                            throw TypeError(".sub.InfoRes.S2C.connSubInfoList: object expected");
                        message.connSubInfoList[i] = $root.common.ConnSubInfo.fromObject(object.connSubInfoList[i]);
                    }
                }
                if (object.totalUsedQuota != null)
                    message.totalUsedQuota = object.totalUsedQuota | 0;
                if (object.remainQuota != null)
                    message.remainQuota = object.remainQuota | 0;
                return message;
            };

            /**
             * Creates a plain object from a S2C message. Also converts values to other types if specified.
             * @function toObject
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {sub.InfoRes.S2C} message S2C
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            S2C.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.connSubInfoList = [];
                if (options.defaults) {
                    object.totalUsedQuota = 0;
                    object.remainQuota = 0;
                }
                if (message.connSubInfoList && message.connSubInfoList.length) {
                    object.connSubInfoList = [];
                    for (let j = 0; j < message.connSubInfoList.length; ++j)
                        object.connSubInfoList[j] = $root.common.ConnSubInfo.toObject(message.connSubInfoList[j], options);
                }
                if (message.totalUsedQuota != null && message.hasOwnProperty("totalUsedQuota"))
                    object.totalUsedQuota = message.totalUsedQuota;
                if (message.remainQuota != null && message.hasOwnProperty("remainQuota"))
                    object.remainQuota = message.remainQuota;
                return object;
            };

            /**
             * Converts this S2C to JSON.
             * @function toJSON
             * @memberof sub.InfoRes.S2C
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            S2C.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for S2C
             * @function getTypeUrl
             * @memberof sub.InfoRes.S2C
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            S2C.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/sub.InfoRes.S2C";
            };

            return S2C;
        })();

        return InfoRes;
    })();

    sub.InfoReq = (function() {

        /**
         * Properties of an InfoReq.
         * @memberof sub
         * @interface IInfoReq
         * @property {sub.InfoReq.IC2S} c2s InfoReq c2s
         */

        /**
         * Constructs a new InfoReq.
         * @memberof sub
         * @classdesc 获取订阅信息请求
         * @implements IInfoReq
         * @constructor
         * @param {sub.IInfoReq=} [properties] Properties to set
         */
        function InfoReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InfoReq c2s.
         * @member {sub.InfoReq.IC2S} c2s
         * @memberof sub.InfoReq
         * @instance
         */
        InfoReq.prototype.c2s = null;

        /**
         * Creates a new InfoReq instance using the specified properties.
         * @function create
         * @memberof sub.InfoReq
         * @static
         * @param {sub.IInfoReq=} [properties] Properties to set
         * @returns {sub.InfoReq} InfoReq instance
         */
        InfoReq.create = function create(properties) {
            return new InfoReq(properties);
        };

        /**
         * Encodes the specified InfoReq message. Does not implicitly {@link sub.InfoReq.verify|verify} messages.
         * @function encode
         * @memberof sub.InfoReq
         * @static
         * @param {sub.IInfoReq} message InfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.sub.InfoReq.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InfoReq message, length delimited. Does not implicitly {@link sub.InfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sub.InfoReq
         * @static
         * @param {sub.IInfoReq} message InfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof sub.InfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sub.InfoReq} InfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.InfoReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.c2s = $root.sub.InfoReq.C2S.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes an InfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sub.InfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sub.InfoReq} InfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InfoReq message.
         * @function verify
         * @memberof sub.InfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.sub.InfoReq.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates an InfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sub.InfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sub.InfoReq} InfoReq
         */
        InfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.sub.InfoReq)
                return object;
            let message = new $root.sub.InfoReq();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".sub.InfoReq.c2s: object expected");
                message.c2s = $root.sub.InfoReq.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from an InfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sub.InfoReq
         * @static
         * @param {sub.InfoReq} message InfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.sub.InfoReq.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this InfoReq to JSON.
         * @function toJSON
         * @memberof sub.InfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InfoReq
         * @function getTypeUrl
         * @memberof sub.InfoReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InfoReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/sub.InfoReq";
        };

        InfoReq.C2S = (function() {

            /**
             * Properties of a C2S.
             * @memberof sub.InfoReq
             * @interface IC2S
             * @property {boolean|null} [isReqAllConn] 是否返回所有连接的订阅状态,不传或者传 false 只返回当前连接数据
             */

            /**
             * Constructs a new C2S.
             * @memberof sub.InfoReq
             * @classdesc Represents a C2S.
             * @implements IC2S
             * @constructor
             * @param {sub.InfoReq.IC2S=} [properties] Properties to set
             */
            function C2S(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * 是否返回所有连接的订阅状态,不传或者传 false 只返回当前连接数据
             * @member {boolean} isReqAllConn
             * @memberof sub.InfoReq.C2S
             * @instance
             */
            C2S.prototype.isReqAllConn = false;

            /**
             * Creates a new C2S instance using the specified properties.
             * @function create
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {sub.InfoReq.IC2S=} [properties] Properties to set
             * @returns {sub.InfoReq.C2S} C2S instance
             */
            C2S.create = function create(properties) {
                return new C2S(properties);
            };

            /**
             * Encodes the specified C2S message. Does not implicitly {@link sub.InfoReq.C2S.verify|verify} messages.
             * @function encode
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {sub.InfoReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isReqAllConn != null && Object.hasOwnProperty.call(message, "isReqAllConn"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isReqAllConn);
                return writer;
            };

            /**
             * Encodes the specified C2S message, length delimited. Does not implicitly {@link sub.InfoReq.C2S.verify|verify} messages.
             * @function encodeDelimited
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {sub.InfoReq.IC2S} message C2S message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2S.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2S message from the specified reader or buffer.
             * @function decode
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {sub.InfoReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.sub.InfoReq.C2S();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isReqAllConn = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a C2S message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {sub.InfoReq.C2S} C2S
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2S.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2S message.
             * @function verify
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2S.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                    if (typeof message.isReqAllConn !== "boolean")
                        return "isReqAllConn: boolean expected";
                return null;
            };

            /**
             * Creates a C2S message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {sub.InfoReq.C2S} C2S
             */
            C2S.fromObject = function fromObject(object) {
                if (object instanceof $root.sub.InfoReq.C2S)
                    return object;
                let message = new $root.sub.InfoReq.C2S();
                if (object.isReqAllConn != null)
                    message.isReqAllConn = Boolean(object.isReqAllConn);
                return message;
            };

            /**
             * Creates a plain object from a C2S message. Also converts values to other types if specified.
             * @function toObject
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {sub.InfoReq.C2S} message C2S
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2S.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.isReqAllConn = false;
                if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                    object.isReqAllConn = message.isReqAllConn;
                return object;
            };

            /**
             * Converts this C2S to JSON.
             * @function toJSON
             * @memberof sub.InfoReq.C2S
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2S.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for C2S
             * @function getTypeUrl
             * @memberof sub.InfoReq.C2S
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            C2S.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/sub.InfoReq.C2S";
            };

            return C2S;
        })();

        return InfoReq;
    })();

    return sub;
})();

export { $root as default };
